<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>石林坤</title>
  
  
  <link href="http://www.shicoder.top/atom.xml" rel="self"/>
  
  <link href="http://www.shicoder.top/"/>
  <updated>2022-03-31T07:05:42.712Z</updated>
  <id>http://www.shicoder.top/</id>
  
  <author>
    <name>shilinkun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis数据结构</title>
    <link href="http://www.shicoder.top/posts/2882215823.html"/>
    <id>http://www.shicoder.top/posts/2882215823.html</id>
    <published>2022-03-30T09:15:18.000Z</published>
    <updated>2022-03-31T07:05:42.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>从本次开始，对Redis设计与实现进行阅读及相关读书笔记的记录。Redis版本为3.0</p><span id="more"></span><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="简单动态字符串SDS"><a href="#简单动态字符串SDS" class="headerlink" title="简单动态字符串SDS"></a>简单动态字符串SDS</h2><p><code>sds</code>数据结构位于<code>sds.h/sdshdr</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存字符串对象的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sdshdr</span> &#123;</span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度</span></span><br><span class="line">    <span class="type">int</span> free;</span><br><span class="line">    <span class="comment">// 数据空间</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相对于C语言的字符串，SDS的优点在于</p><ul><li>常数复杂度获取字符串长度</li><li>杜绝缓冲区溢出</li><li>减少修改字符串所带来的内存重新分配（注意，释放空间时候，不会真的释放，而是设置free的值）</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表的相关代码在<code>adlist.h</code>中</p><p>链表节点<code>listNode</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">listNode</span> &#123;</span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">listNode</span> *prev;</span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">listNode</span> *next;</span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><p>由多个<code>listNode</code>组成的双端链表</p><p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331111939637.png" alt="image-20220331111939637"></p><p>链表结构<code>list</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">list</span> &#123;</span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="built_in">void</span> (*free)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="built_in">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure><p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331112050968.png" alt="image-20220331112050968"></p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p><code>redis</code>中的字典使用哈希表实现，其代码在<code>dict.h</code>中</p><p>哈希表结构<code>dictht</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 哈希表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每个字典都使用两个哈希表，从而实现渐进式 rehash 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dictht</span> &#123;</span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;    </span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1 比如7号，当计算索引时候， 7&amp;sizemask就可以得到</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>其中<code>dictEntry</code>为一个键值对</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 哈希表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dictEntry</span> &#123;    </span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表 表明是一个链地址法解决哈希冲突</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dictEntry</span> *next;</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>下面为了形象表示一个哈希表，给出一个例子</p><p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331112501821.png" alt="image-20220331112501821"></p><p>下面给出一个多个<code>dictEntry</code>连接的哈希表</p><p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331113154852.png" alt="image-20220331113154852"></p><p>最终<code>Redis</code>中的字典数据结构如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字典</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dict</span> &#123;</span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="type">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="comment">// 目前正在运行的安全迭代器的数量</span></span><br><span class="line">    <span class="type">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>本次首先对Redis的相关数据结构进行介绍。Redis对象主要分为5种：REDIS_STRING、REDIS_LIST、REDIS_HASH、REDIS_SET、REDIS_ZSET。下面首先给出Redis中对对象的代码表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_STRING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_LIST 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_SET 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ZSET 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_HASH 4</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_LRU_BITS 24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_LRU_CLOCK_MAX ((1<span class="string">&lt;&lt;REDIS_LRU_BITS)-1) /* Max value of obj-&gt;</span>lru */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_LRU_CLOCK_RESOLUTION 1000 <span class="comment">/* LRU clock resolution in ms */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisObject</span> &#123;</span><br><span class="line">    <span class="comment">// 类型   类型说明符      位域名：位域长度   标识type占4个二进制位 因为有可能不需要一个完整的字节</span></span><br><span class="line">    <span class="comment">// 1个字节8位</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 对象最后一次被访问的时间</span></span><br><span class="line">    <span class="type">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="comment">// 指向实际值的指针</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>首先看到有2个字段，为类型和编码，类型就是redis的5种类型，编码就是这个类型底层是用什么编码方式实现</p><p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331110406889.png" alt="image-20220331110406889"></p><p>但实际上，Redis的内部并不只是这5种对象，对于上面5种对象，都有几种底层实现方式，下面给出各数据结构底层实现的对应方式</p><h2 id="REDIS-STRING"><a href="#REDIS-STRING" class="headerlink" title="REDIS_STRING"></a>REDIS_STRING</h2><p>​    REDIS_STRING表示redis中的字符串类型，其底层由以下三种实现方式</p><p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331101805672.png" alt="image-20220331101805672"></p><h3 id="REDIS-ENCODING-INT"><a href="#REDIS-ENCODING-INT" class="headerlink" title="REDIS_ENCODING_INT"></a>REDIS_ENCODING_INT</h3><p>如果一个字符串对象保存的是整数值，且这个整数值可以用long类型表示，则字符串对象会奖整数值保存在字符串对象的ptr属性中，此时会将ptr的void*转换为long</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set number &quot;1&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding number</span><br><span class="line">&quot;int&quot;</span><br></pre></td></tr></table></figure><h3 id="REDIS-ENCODING-RAW"><a href="#REDIS-ENCODING-RAW" class="headerlink" title="REDIS_ENCODING_RAW"></a>REDIS_ENCODING_RAW</h3><p>​    如果字符串保存的是一个字符串值，且长度大于32字节，redis的字符串对象就会采用简单动态字符串（SDS）实现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set longstr &quot;Hello, my name is Shi Linkun, is a programmer who loves code, I hope that each blog can let myself consolidate their knowledge, but also let everyone get a little knowledge, thank you&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding longstr</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure><p>这里先不对SDS进行详细简介，后续单独对其进行描述</p><h3 id="REDIS-ENCODING-EMBSTR"><a href="#REDIS-ENCODING-EMBSTR" class="headerlink" title="REDIS_ENCODING_EMBSTR"></a>REDIS_ENCODING_EMBSTR</h3><p>如果字符串对象保存的是一个字符串，且长度小于等于32字节，则使用embstr编码实现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set story &quot;hello my name is shilinkun&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding story</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure><p>注意redis3.0版本中实际间隔为39字节</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ENCODING_EMBSTR_SIZE_LIMIT 39</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= REDIS_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">createEmbeddedStringObject</span>(ptr,len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">createRawStringObject</span>(ptr,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么是39字节，这里参考这个<a href="https://www.zhihu.com/question/25624589">知乎</a>的解释</p><p>embstr是一块连续的内存区域，由redisObject和sdshdr组成。其中redisObject占16个字节，当buf内的字符串长度是39时，sdshdr的大小为8+39+1&#x3D;48，那一个字节是’\0’。加起来刚好64。是不是发现了什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从2.4版本开始，redis开始使用jemalloc内存分配器。这个比glibc的malloc要好不少，还省内存。在这里可以简单理解，jemalloc会分配8，16，32，64等字节的内存。embstr最小为16+8+8+1&#x3D;33，所以最小分配64字节。当字符数小于39时，都会分配64字节。</p></blockquote><h3 id="三个编码的转换"><a href="#三个编码的转换" class="headerlink" title="三个编码的转换"></a>三个编码的转换</h3><ul><li><p>int-&gt;raw</p><p>  向一个保存整数数值的字符串对象使用APPEND命令，就会使得int转变为raw</p></li><li><p>embstr-&gt;raw</p><p>  对embstr类型的字符串，执行任何的修改命令，都会变为raw</p></li></ul><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><p>字符串命令的实现在t_string.c中</p><p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331110234918.png" alt="image-20220331110234918"></p><h2 id="REDIS-LIST"><a href="#REDIS-LIST" class="headerlink" title="REDIS_LIST"></a>REDIS_LIST</h2><p>列表对象底层主要由2种编码方式：REDIS_ENCODING_ZIPLIST、REDIS_ENCODING_LINKEDLIST</p><p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331110752306.png" alt="image-20220331110752306"></p><h3 id="REDIS-ENCODING-ZIPLIST"><a href="#REDIS-ENCODING-ZIPLIST" class="headerlink" title="REDIS_ENCODING_ZIPLIST"></a>REDIS_ENCODING_ZIPLIST</h3><p>ziplist是指使用压缩列表实现</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;从本次开始，对Redis设计与实现进行阅读及相关读书笔记的记录。Redis版本为3.0&lt;/p&gt;</summary>
    
    
    
    <category term="后端开发" scheme="http://www.shicoder.top/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="导航" scheme="http://www.shicoder.top/tags/%E5%AF%BC%E8%88%AA/"/>
    
    <category term="分享" scheme="http://www.shicoder.top/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>muduo源码分析之回调模块</title>
    <link href="http://www.shicoder.top/posts/3047269001.html"/>
    <id>http://www.shicoder.top/posts/3047269001.html</id>
    <published>2022-02-20T07:43:39.000Z</published>
    <updated>2022-02-24T07:00:37.906Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们主要来说说<code>muduo</code>库中大量使用的回调机制。<code>muduo</code>主要使用的是利用<code>Callback</code>的方式来实现回调，首先我们在自己的<code>EchoServer</code>构造函数中有这样几行代码</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">EchoServer</span>(EventLoop *loop,</span><br><span class="line">        <span class="type">const</span> InetAddress &amp;addr, </span><br><span class="line">        <span class="type">const</span> std::string &amp;name)</span><br><span class="line">    : <span class="built_in">server_</span>(loop, addr, name)</span><br><span class="line">    , <span class="built_in">loop_</span>(loop)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注册回调函数</span></span><br><span class="line">    server_.<span class="built_in">setConnectionCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;EchoServer::onConnection, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    server_.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;EchoServer::onMessage, <span class="keyword">this</span>,</span><br><span class="line">            std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置合适的loop线程数量 loopthread</span></span><br><span class="line">    server_.<span class="built_in">setThreadNum</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了<code>setConnectionCallback</code>和<code>setMessageCallback</code>，我们去看下<code>TcpServer</code>对<code>setConnectionCallback</code>怎么实现的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setConnectionCallback</span><span class="params">(<span class="type">const</span> ConnectionCallback &amp;cb)</span> </span>&#123; connectionCallback_ = cb; &#125;</span><br></pre></td></tr></table></figure><p>这样当有新的连接建立时候，就会执行我们设置的<code>EchoServer::onConnection</code>，这样我们就给<code>TcpServer</code>设置了一个回调函数，同时当<code>TcpServer</code>中的<code>Acceptor</code>接受到一个新的连接，<code>TcpServer</code>就会去用这个<code>connfd</code>和对应的<code>peerAddr</code>建立一个新的<code>TcpConnection</code>，同时<code>TcpServer</code>会给这个<code>TcpConnection</code>设置一个回调，而这个回调就是我们给<code>TcpServer</code>设置的回调</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 根据连接成功的sockfd,创建TcpConnection</span></span><br><span class="line">   <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(</span></span></span><br><span class="line"><span class="params"><span class="function">                           ioLoop,</span></span></span><br><span class="line"><span class="params"><span class="function">                           connName,</span></span></span><br><span class="line"><span class="params"><span class="function">                           sockfd,   <span class="comment">// Socket Channel</span></span></span></span><br><span class="line"><span class="params"><span class="function">                           localAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                           peerAddr))</span></span>;</span><br><span class="line">   connections_[connName] = conn;</span><br><span class="line"><span class="comment">// 下面的回调时用户设置给TcpServer，TcpServer又设置给TcpConnection，TcpConnetion又设置给Channel，Channel又设置给Poller，Poller通知channel调用这个回调</span></span><br><span class="line">   conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">   conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">   conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br></pre></td></tr></table></figure><p>当已经建立的连接有新消息来的时候，<code>conn-&gt;setMessageCallback(messageCallback_);</code>这一行代码表示我们给这个<code>conn</code>设置了一个有消息来的时候回调，我们去看下<code>TcpConnection</code>中对<code>setMessageCallback</code>是怎么处理的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setConnectionCallback</span><span class="params">(<span class="type">const</span> ConnectionCallback&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123; connectionCallback_ = cb; &#125;</span><br></pre></td></tr></table></figure><p>所以有消息来的时候，就会执行我们所设置的回调函数<code>onMessage</code>。到这里我么就基本知道新连接的建立和旧连接的消息到来应该做什么，下一章我们说一下消息之间发送的<code>Buffer</code>类。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这次我们主要来说说&lt;code&gt;muduo&lt;/code&gt;库中大量使用的回调机制。&lt;code&gt;muduo&lt;/code&gt;主要使用的是利用&lt;code&gt;Callback&lt;/code&gt;的方式来实现回调，首先我们在自己的&lt;code&gt;EchoServer&lt;/code&gt;构造函数中有这样几行代码&lt;/p&gt;</summary>
    
    
    
    <category term="后端开发" scheme="http://www.shicoder.top/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="导航" scheme="http://www.shicoder.top/tags/%E5%AF%BC%E8%88%AA/"/>
    
    <category term="分享" scheme="http://www.shicoder.top/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>muduo源码分析之TcpServer模块</title>
    <link href="http://www.shicoder.top/posts/335272509.html"/>
    <id>http://www.shicoder.top/posts/335272509.html</id>
    <published>2022-02-20T07:41:20.000Z</published>
    <updated>2022-03-31T07:04:39.485Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们开始<code>muduo</code>源代码的实际编写，首先我们知道<code>muduo</code>是<code>LT</code>模式，<code>Reactor</code>模式，下图为<code>Reactor</code>模式的流程图[来源1]</p><span id="more"></span><p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220220154310731.png" alt="image-20220220154310731"></p><p>然后我们来看下<code>muduo</code>的整体架构[来源1]</p><p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20210422204939773.png" alt="muduo"></p><p>首先<code>muduo</code>有一个主反应堆<code>mainReactor</code>以及几个子反应堆<code>subReactor</code>，其中子反应堆的个数由用户使用<code>setThreadNum</code>函数设置，<code>mainReactor</code>中主要有一个<code>Acceptor</code>，当用户建立新的连接的时候，<code>Acceptor</code>会将<code>connfd</code>和对应的事件打包为一个<code>channel</code>然后采用轮询的算法，指定将该<code>channel</code>给所选择的<code>subReactor</code>，以后该<code>subReactor</code>就负责该<code>channel</code>的所有工作。</p><h1 id="TcpServer类"><a href="#TcpServer类" class="headerlink" title="TcpServer类"></a>TcpServer类</h1><p>我们按照从上到下的思路进行讲解，以下内容我们按照一个简单的<code>EchoServer</code>的实现思路来讲解，我们知道当我们自己实现一个<code>Server</code>的时候，会在构造函数中实例化一个<code>TcpServer</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">EchoServer</span>(EventLoop *loop,</span><br><span class="line">           <span class="type">const</span> InetAddress &amp;addr, </span><br><span class="line">           <span class="type">const</span> std::string &amp;name)</span><br><span class="line">    : <span class="built_in">server_</span>(loop, addr, name)</span><br><span class="line">        , <span class="built_in">loop_</span>(loop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注册回调函数</span></span><br><span class="line">        server_.<span class="built_in">setConnectionCallback</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onConnection, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        server_.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onMessage, <span class="keyword">this</span>,</span><br><span class="line">                      std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置合适的loop线程数量 loopthread 不包括baseloop</span></span><br><span class="line">        server_.<span class="built_in">setThreadNum</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>于是我们去看下<code>TcpServer</code>的构造函数是在干什么</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TcpServer::<span class="built_in">TcpServer</span>(EventLoop *loop,</span><br><span class="line">                <span class="type">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                <span class="type">const</span> std::string &amp;nameArg,</span><br><span class="line">                Option option)</span><br><span class="line">                : <span class="built_in">loop_</span>(<span class="built_in">CheckLoopNotNull</span>(loop))</span><br><span class="line">                , <span class="built_in">ipPort_</span>(listenAddr.<span class="built_in">toIpPort</span>())</span><br><span class="line">                , <span class="built_in">name_</span>(nameArg)</span><br><span class="line">                , <span class="built_in">acceptor_</span>(<span class="keyword">new</span> <span class="built_in">Acceptor</span>(loop, listenAddr, option == kReusePort))</span><br><span class="line">                , <span class="built_in">threadPool_</span>(<span class="keyword">new</span> <span class="built_in">EventLoopThreadPool</span>(loop, name_))</span><br><span class="line">                , <span class="built_in">connectionCallback_</span>()</span><br><span class="line">                , <span class="built_in">messageCallback_</span>()</span><br><span class="line">                , <span class="built_in">nextConnId_</span>(<span class="number">1</span>)</span><br><span class="line">                , <span class="built_in">started_</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当有新用户连接时候，会执行该回调函数</span></span><br><span class="line">    acceptor_-&gt;<span class="built_in">setNewConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::newConnection, <span class="keyword">this</span>, </span><br><span class="line">        std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要关注<code>acceptor_(new Acceptor(loop, listenAddr, option == kReusePort))</code>和<code>threadPool_(new EventLoopThreadPool(loop, name_))</code><br>首先很明确的一点，构造了一个<code>Acceptor</code>，我们首先要知道<code>Acceptor</code>主要就是连接新用户并打包为一个<code>Channel</code>，所以我们就应该知道<code>Acceptor</code>按道理应该实现<code>socket</code>，<code>bind</code>，<code>listen</code>，<code>accept</code>这四个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Acceptor::<span class="built_in">Acceptor</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr, <span class="type">bool</span> reuseport)</span><br><span class="line">    : <span class="built_in">loop_</span>(loop), <span class="built_in">acceptSocket_</span>(<span class="built_in">createNonblocking</span>()) <span class="comment">// socket</span></span><br><span class="line">      ,</span><br><span class="line">      <span class="built_in">acceptChannel_</span>(loop, acceptSocket_.<span class="built_in">fd</span>()), <span class="built_in">listenning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    acceptSocket_.<span class="built_in">setReuseAddr</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">setReusePort</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">bindAddress</span>(listenAddr); <span class="comment">// 绑定套接字</span></span><br><span class="line">    <span class="comment">// 有新用户的连接，执行一个回调（打包为channel）</span></span><br><span class="line">    acceptChannel_.<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::handleRead, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>Acceptor</code>中有个<code>acceptSocket_</code>，其实就是我们平时所用的<code>listenfd</code>，构造函数中实现了<code>socket</code>，<code>bind</code>，而其余的两个函数的使用在其余代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启服务器监听</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 防止一个TcpServer被start多次</span></span><br><span class="line">    <span class="keyword">if</span> (started_++ == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        threadPool_-&gt;<span class="built_in">start</span>(threadInitCallback_); <span class="comment">// 启动底层的loop线程池,这里会按照设定了threadnum设置pool的数量</span></span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::listen, acceptor_.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，当我们设置了<code>threadnum</code>之后，就会有一个<code>mainloop</code>，那么这个<code>loop_</code>就是那个<code>mainloop</code>，其中可以看见这个<code>loop_</code>就只做一个事情<code>Acceptor::listen</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listenning_ = <span class="literal">true</span>;</span><br><span class="line">    acceptSocket_.<span class="built_in">listen</span>();         <span class="comment">// listen</span></span><br><span class="line">    acceptChannel_.<span class="built_in">enableReading</span>(); <span class="comment">// acceptChannel_ =&gt; Poller</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里就实现了<code>listen</code>函数，还有最后一个函数<code>accept</code>，我们慢慢向下分析，从代码可以知道<code>acceptChannel_.enableReading()</code>之后就会使得这个<code>listenfd</code>所在的<code>channel</code>对读事件感兴趣，那什么时候会有读事件呢，就是当用户建立新连接的时候，那么我们应该想一下，那当感兴趣的事件发生之后，<code>listenfd</code>应该干什么呢，应该执行一个回调函数呀。注意<code>Acceptor</code>构造函数中有这样一行代码<code>acceptChannel_.setReadCallback(std::bind(&amp;Acceptor::handleRead, this));</code>这就是那个回调，我们去看下<code>handleRead</code>在干嘛。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// listenfd有事件发生了，就是有新用户连接了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InetAddress peerAddr;</span><br><span class="line">    <span class="type">int</span> connfd = acceptSocket_.<span class="built_in">accept</span>(&amp;peerAddr);</span><br><span class="line">    <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若用户实现定义了，则执行，否则说明用户对新到来的连接没有需要执行的，所以直接关闭</span></span><br><span class="line">        <span class="keyword">if</span> (newConnectionCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">newConnectionCallback_</span>(connfd, peerAddr); <span class="comment">// 轮询找到subLoop，唤醒，分发当前的新客户端的Channel</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ::<span class="built_in">close</span>(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是不是就实现了<code>accept</code>函数，至此当用户建立一个新的连接时候，<code>Acceptor</code>就会得到一个<code>connfd</code>和其对应的<code>peerAddr</code>返回给<code>mainloop</code>，这时候我们在注意到<code>TcpServer</code>构造函数中有这样一行代码<code>acceptor_-&gt;setNewConnectionCallback(std::bind(&amp;TcpServer::newConnection, this,std::placeholders::_1, std::placeholders::_2));</code>我们给<code>acceptor_</code>设置了一个<code>newConnectionCallback_</code>，于是由上面的代码就可以知道，<code>if (newConnectionCallback_)</code>为真，就会执行这个回调函数，于是就会执行<code>TcpServer::newConnection</code>，我们去看下这个函数是在干嘛。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress &amp;peerAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 轮询算法选择一个subloop来管理对应的这个新连接</span></span><br><span class="line">    EventLoop *ioLoop = threadPool_-&gt;<span class="built_in">getNextLoop</span>(); </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;-%s#%d&quot;</span>, ipPort_.<span class="built_in">c_str</span>(), nextConnId_);</span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    std::string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpServer::newConnection [%s] - new connection [%s] from %s \n&quot;</span>,</span><br><span class="line">        name_.<span class="built_in">c_str</span>(), connName.<span class="built_in">c_str</span>(), peerAddr.<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过sockfd获取其绑定的本地ip和端口</span></span><br><span class="line">    sockaddr_in local;</span><br><span class="line">    ::<span class="built_in">bzero</span>(&amp;local, <span class="keyword">sizeof</span> local);</span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span> local;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">getsockname</span>(sockfd, (sockaddr*)&amp;local, &amp;addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;sockets::getLocalAddr&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(local)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据连接成功的sockfd,创建TcpConnection</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(</span></span></span><br><span class="line"><span class="params"><span class="function">                            ioLoop,</span></span></span><br><span class="line"><span class="params"><span class="function">                            connName,</span></span></span><br><span class="line"><span class="params"><span class="function">                            sockfd,   <span class="comment">// Socket Channel</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            localAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                            peerAddr))</span></span>;</span><br><span class="line">    connections_[connName] = conn;</span><br><span class="line"><span class="comment">// 下面的回调时用户设置给TcpServer，TcpServer又设置给TcpConnection，TcpConnetion又设置给Channel，Channel又设置给Poller，Poller通知channel调用这个回调</span></span><br><span class="line">    conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置了如何关闭连接的回调</span></span><br><span class="line">    conn-&gt;<span class="built_in">setCloseCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接调用connectEstablished</span></span><br><span class="line">    ioLoop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就比较长了，我先说下大概他干了啥事情：首先通过轮询找到下一个<code>subloop</code>，然后将刚刚返回的<code>connfd</code>和对应的<code>peerAddr</code>以及<code>localAddr</code>构造为一个<code>TcpConnection</code>给<code>subloop</code>，然后给这个<code>conn</code>设置了一系列的回调函数，比如读回调，写回调，断开回调等等。下一章我们来说下上面的代码最后几行在干嘛。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这次我们开始&lt;code&gt;muduo&lt;/code&gt;源代码的实际编写，首先我们知道&lt;code&gt;muduo&lt;/code&gt;是&lt;code&gt;LT&lt;/code&gt;模式，&lt;code&gt;Reactor&lt;/code&gt;模式，下图为&lt;code&gt;Reactor&lt;/code&gt;模式的流程图[来源1]&lt;/p&gt;</summary>
    
    
    
    <category term="后端开发" scheme="http://www.shicoder.top/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="导航" scheme="http://www.shicoder.top/tags/%E5%AF%BC%E8%88%AA/"/>
    
    <category term="分享" scheme="http://www.shicoder.top/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>muduo源码分析之muduo简单运用</title>
    <link href="http://www.shicoder.top/posts/713527548.html"/>
    <id>http://www.shicoder.top/posts/713527548.html</id>
    <published>2022-02-20T07:39:55.000Z</published>
    <updated>2022-02-24T07:00:37.900Z</updated>
    
    <content type="html"><![CDATA[<p>今天不先实现<code>muduo</code>项目，我们先来看下<code>muduo</code>库的基本使用，只有了解了如何用，才能在写代码的时候知道自己写的找个函数是干嘛的，实际上是怎么使用的这个函数。首先说简单点，就是定义一个<code>Server</code>，设置两个回调函数</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调连接相关的事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line"><span class="comment">// 回调读写事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, Buffer *buffer, Timestamp time)</span></span>;</span><br></pre></td></tr></table></figure><p>意思就是当有客户连接或者断开连接的时候，需要<code>Server</code>做什么，当连接上有读写事件发生时候，需要<code>Server</code>做什么。<br>比如一个<code>EchoServer</code>，当建立连接的时候，会自动调用<code>onConnection</code>函数，当比如我们发送一个消息时候，会自动调用<code>onMessage</code>函数。还有2个重要函数<code>loop</code>，<code>start</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="built_in">start</span>();</span><br><span class="line">loop.<span class="built_in">loop</span>();</span><br></pre></td></tr></table></figure><p>这里简答讲下这2个的区别，其实如果和<code>Epoll</code>做对比的话，<code>start</code>就相当于<code>epoll_create</code>，<code>loop</code>就相当于<code>epoll_wait</code>，后面再根据代码具体说明2个的区别。</br><br>以上就是基本的<code>muduo</code>使用，下一章就开始具体的<code>muduo</code>代码实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天不先实现&lt;code&gt;muduo&lt;/code&gt;项目，我们先来看下&lt;code&gt;muduo&lt;/code&gt;库的基本使用，只有了解了如何用，才能在写代码的时候知道自己写的找个函数是干嘛的，实际上是怎么使用的这个函数。首先说简单点，就是定义一个&lt;code&gt;Server&lt;/code&gt;，设置两个回调函数&lt;/p&gt;</summary>
    
    
    
    <category term="后端开发" scheme="http://www.shicoder.top/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="导航" scheme="http://www.shicoder.top/tags/%E5%AF%BC%E8%88%AA/"/>
    
    <category term="分享" scheme="http://www.shicoder.top/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>muduo源码分析之Buffer</title>
    <link href="http://www.shicoder.top/posts/620043534.html"/>
    <id>http://www.shicoder.top/posts/620043534.html</id>
    <published>2022-02-20T07:37:47.000Z</published>
    <updated>2022-03-31T07:04:13.820Z</updated>
    
    <content type="html"><![CDATA[<p>这一次我们来分析下<code>muduo</code>中<code>Buffer</code>的作用，我们知道，当我们客户端向服务器发送数据时候，服务器就会读取我们发送的数据，然后进行一系列处理，然后再发送到其他地方，在这里我们想象一下最简单的<code>EchoServer</code>服务器，客户端建立一个连接，以后服务器和客户端之间的通信都是通过这个<code>connfd</code>发送和接受数据，于是每一个<code>connfd</code>都应该有一个自己<code>buffer</code>，当我们发送数据太快，服务器发送的太慢，则服务器会将待发送的数据这个<code>buffer</code>中，所以这就是这个类的作用。我们先看下<code>buffer</code>的结构是什么：</p><p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/d2466fdf-c322-417a-9a80-2900d415d81d.png" alt="buffer1"></p><p>我们这里主要针对<code>connfd</code>这个对应的<code>channel</code>进行分析，首先上图是<code>buffer</code>的初始状态，前面<code>8</code>个字节中表示该<code>buffer</code>的大小，初始大小为<code>1024</code>。当客户端发送数据给服务器，同时若服务器接受缓慢，则会向<code>buffer</code>中开始写数据，则<code>writerIndex_</code>会向右移动，假如此时移动到如下形式：</p><p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/10505139-a325-4e85-bea0-b845fad0fd51.png" alt="buffer2"></p><p>则此时缓冲区可以读的数据为<code>writerIndex_ - readerIndex_</code>，可以写的数据为<code>buffer_.size() - writerIndex_</code>。这时候当服务器有多余资源进行读操作，就可以去缓冲区读数据了，假如这时候的状态为如下：</p><p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/c2fc3414-189b-41bf-b649-1c0ba90763e1.png" alt="buffer3"></p><p>这就是常见的几个状态，下面我们去看几个重点的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 把onMessage函数上报的buffer内容转为string</span></span><br><span class="line">  <span class="function">std::string <span class="title">retrieveAllAsString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">retrieveAsString</span>(<span class="built_in">readableBytes</span>()); <span class="comment">// 应用可读取数据的长度</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 可读的数据 就是存放的是即发送的数据</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">readableBytes</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> writerIndex_ - readerIndex_;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">std::string <span class="title">retrieveAsString</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"><span class="comment">// 从可读数据开始位置，长度为len的char构造为一个string</span></span><br><span class="line">      <span class="function">std::string <span class="title">result</span><span class="params">(peek(), len)</span></span>;</span><br><span class="line">      <span class="built_in">retrieve</span>(len); <span class="comment">// 上面一句把缓冲区中可读的数据，已经读取出来，这里肯定要对缓冲区进行复位操作</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将缓冲区len的长度进行复位</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">retrieve</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"><span class="comment">// 表示还没有读完数据</span></span><br><span class="line">      <span class="keyword">if</span> (len &lt; <span class="built_in">readableBytes</span>())</span><br><span class="line">      &#123;</span><br><span class="line">          readerIndex_ += len; <span class="comment">// 应用只读取了刻度缓冲区数据的一部分，就是len，还剩下readerIndex_ += len -&gt; writerIndex_</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>   <span class="comment">// len == readableBytes()</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">retrieveAll</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上是基本的操作，下面的2个函数很重要，一个是向<code>connfd</code>写数据，一个是读数据，对于一个<code>TcpConnection</code>而言，当有数据来的时候，回去调用<code>handleRead</code>回调函数。我们知道<code>muduo</code>设置的每次读取的大小为<code>65536</code>字节，当缓冲区可写的数据大小大于<code>65536</code>，就会直接将读到的数据写入到缓冲区中，但当缓冲区的可写数据大小小于<code>65536</code>的时候，就会将剩余数据先写到一个额外的空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::readFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> extrabuf[<span class="number">65536</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 栈上的内存空间  64K</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> vec[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 这是buffer可写的数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> writable = <span class="built_in">writableBytes</span>(); </span><br><span class="line">    vec[<span class="number">0</span>].iov_base = <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">    vec[<span class="number">0</span>].iov_len = writable;</span><br><span class="line"></span><br><span class="line">    vec[<span class="number">1</span>].iov_base = extrabuf;</span><br><span class="line">    vec[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span> extrabuf;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iovcnt = (writable &lt; <span class="keyword">sizeof</span> extrabuf) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 去百度下readv</span></span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> n = ::<span class="built_in">readv</span>(fd, vec, iovcnt);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= writable) <span class="comment">// Buffer的可写缓冲区已经够存储读出来的数据了</span></span><br><span class="line">    &#123;</span><br><span class="line">        writerIndex_ += n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// extrabuf 也写了数据</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        writerIndex_ = buffer_.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">append</span>(extrabuf, n - writable);  <span class="comment">// writerIndex_开始写 n - writable大小的数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里巧妙的使用了一个<code>readv</code>函数，可以通过按照大小自动写到不同的地方。其中当<code>extrabuf</code>也写了数据，就会调用<code>append</code>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要写len长度的数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ensureWriteableBytes</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">makeSpace</span>(len); <span class="comment">// 扩容函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向缓冲区添加数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ensureWriteableBytes</span>(len);</span><br><span class="line">    std::<span class="built_in">copy</span>(data, data+len, <span class="built_in">beginWrite</span>());</span><br><span class="line">    writerIndex_ += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到有一个<code>makeSpace</code>函数，其中有一个注意点，比如当如下这种状态的时候：</p><p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/c2fc3414-189b-41bf-b649-1c0ba90763e1.png" alt="buffer4"></p><p>此时<code>readerIndex_</code>前面有一部分其实已经被读完了，是空的数据，所以<code>makeSpace</code>函数考虑了这一点，采用内存重组的方式，将<code>readerIndex_</code>向前移动到<code>kCheapPrepend</code>处，然后就可以让空余的内存挨在一起</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeSpace</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() + <span class="built_in">prependableBytes</span>() &lt; len + kCheapPrepend)</span><br><span class="line">    &#123;</span><br><span class="line">        buffer_.<span class="built_in">resize</span>(writerIndex_ + len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> readalbe = <span class="built_in">readableBytes</span>();</span><br><span class="line">        std::<span class="built_in">copy</span>(<span class="built_in">begin</span>() + readerIndex_, </span><br><span class="line">                <span class="built_in">begin</span>() + writerIndex_,</span><br><span class="line">                <span class="built_in">begin</span>() + kCheapPrepend);</span><br><span class="line">        readerIndex_ = kCheapPrepend;</span><br><span class="line">        writerIndex_ = readerIndex_ + readalbe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当向<code>connfd</code>发送数据的时候就比较简单了，直接将可读的数据发送给出去就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过fd发送数据</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::writeFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n = ::<span class="built_in">write</span>(fd, <span class="built_in">peek</span>(), <span class="built_in">readableBytes</span>());</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一次我们来分析下&lt;code&gt;muduo&lt;/code&gt;中&lt;code&gt;Buffer&lt;/code&gt;的作用，我们知道，当我们客户端向服务器发送数据时候，服务器就会读取我们发送的数据，然后进行一系列处理，然后再发送到其他地方，在这里我们想象一下最简单的&lt;code&gt;EchoServe</summary>
      
    
    
    
    <category term="后端开发" scheme="http://www.shicoder.top/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="导航" scheme="http://www.shicoder.top/tags/%E5%AF%BC%E8%88%AA/"/>
    
    <category term="分享" scheme="http://www.shicoder.top/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>muduo项目介绍</title>
    <link href="http://www.shicoder.top/posts/3331102393.html"/>
    <id>http://www.shicoder.top/posts/3331102393.html</id>
    <published>2022-02-20T07:26:15.000Z</published>
    <updated>2022-02-24T07:00:37.907Z</updated>
    
    <content type="html"><![CDATA[<p>在上一个<a href="https://juejin.cn/post/6950230361594920996"><strong>集群聊天服务器</strong></a>项目中，我使用了<code>muduo</code>作为网络库，然后主要实现了业务逻辑等，所以为了深入网络库的代码和实现，我跟着一位老师的代码去实现了<code>muduo</code>库的基本原理和作用，当然只是实现了主体的代码，有些细节便没有深究，以下是自己的目标:</p><ol><li>从开源C++ muduo网络库，学习优秀的代码设计</li><li>掌握基于事件驱动和事件回调的epoll+线程池面向对象编程</li><li>实现<code>TcpServer</code>、<code>TcpConnection</code>、<code>Poller</code>、<code>Chanel</code>等重要部分</li><li>重写muduo核心组件，去依赖boost，用C++11重构</li><li>测试代码是否成功</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在上一个&lt;a href=&quot;https://juejin.cn/post/6950230361594920996&quot;&gt;&lt;strong&gt;集群聊天服务器&lt;/strong&gt;&lt;/a&gt;项目中，我使用了&lt;code&gt;muduo&lt;/code&gt;作为网络库，然后主要实现了业务逻辑等，所以为了深入网</summary>
      
    
    
    
    <category term="后端开发" scheme="http://www.shicoder.top/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="导航" scheme="http://www.shicoder.top/tags/%E5%AF%BC%E8%88%AA/"/>
    
    <category term="分享" scheme="http://www.shicoder.top/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>关于我自己</title>
    <link href="http://www.shicoder.top/posts/404665547.html"/>
    <id>http://www.shicoder.top/posts/404665547.html</id>
    <published>2022-02-20T06:55:53.000Z</published>
    <updated>2022-02-24T07:00:37.915Z</updated>
    
    <content type="html"><![CDATA[<p>这里先自我介绍下：</p><p>本人是一名在读的机械研三学生，转行到计算机，准备2022年7月入职字节，有想转行的同学可以加我QQ(153604363)，大家可以一起学习啦</p><span id="more"></span><h1 id="为什么做这个博客"><a href="#为什么做这个博客" class="headerlink" title="为什么做这个博客"></a>为什么做这个博客</h1><p>这个博客主要记录自己的后端学习记录和一些刷题记录，同时可能会写一些自己的心得感悟，也为自己后面学习有一个知识点仓库，因此可能博客的内容不那么专业，更多的是以我这个水平的同学之间参考</p><p>如果大家觉得博客内容还可以的，也希望可以帮忙转发给朋友啦。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这里先自我介绍下：&lt;/p&gt;
&lt;p&gt;本人是一名在读的机械研三学生，转行到计算机，准备2022年7月入职字节，有想转行的同学可以加我QQ(153604363)，大家可以一起学习啦&lt;/p&gt;</summary>
    
    
    
    <category term="日记杂事" scheme="http://www.shicoder.top/categories/%E6%97%A5%E8%AE%B0%E6%9D%82%E4%BA%8B/"/>
    
    
    <category term="导航" scheme="http://www.shicoder.top/tags/%E5%AF%BC%E8%88%AA/"/>
    
    <category term="分享" scheme="http://www.shicoder.top/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
</feed>
