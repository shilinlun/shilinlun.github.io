<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>石林坤</title>
  
  
  <link href="http://www.shicoder.top/atom.xml" rel="self"/>
  
  <link href="http://www.shicoder.top/"/>
  <updated>2022-03-30T09:16:40.336Z</updated>
  <id>http://www.shicoder.top/</id>
  
  <author>
    <name>shilinkun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis数据结构</title>
    <link href="http://www.shicoder.top/posts/2882215823.html"/>
    <id>http://www.shicoder.top/posts/2882215823.html</id>
    <published>2022-03-30T09:15:18.000Z</published>
    <updated>2022-03-30T09:16:40.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>本次首先对Redis的相关数据结构进行介绍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;p&gt;本次首先对Redis的相关数据结构进行介绍&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端开发" scheme="http://www.shicoder.top/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="导航" scheme="http://www.shicoder.top/tags/%E5%AF%BC%E8%88%AA/"/>
    
    <category term="分享" scheme="http://www.shicoder.top/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>muduo源码分析之回调模块</title>
    <link href="http://www.shicoder.top/posts/3047269001.html"/>
    <id>http://www.shicoder.top/posts/3047269001.html</id>
    <published>2022-02-20T07:43:39.000Z</published>
    <updated>2022-02-24T07:00:37.906Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们主要来说说<code>muduo</code>库中大量使用的回调机制。<code>muduo</code>主要使用的是利用<code>Callback</code>的方式来实现回调，首先我们在自己的<code>EchoServer</code>构造函数中有这样几行代码</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">EchoServer</span>(EventLoop *loop,</span><br><span class="line">        <span class="type">const</span> InetAddress &amp;addr, </span><br><span class="line">        <span class="type">const</span> std::string &amp;name)</span><br><span class="line">    : <span class="built_in">server_</span>(loop, addr, name)</span><br><span class="line">    , <span class="built_in">loop_</span>(loop)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注册回调函数</span></span><br><span class="line">    server_.<span class="built_in">setConnectionCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;EchoServer::onConnection, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    server_.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;EchoServer::onMessage, <span class="keyword">this</span>,</span><br><span class="line">            std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置合适的loop线程数量 loopthread</span></span><br><span class="line">    server_.<span class="built_in">setThreadNum</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了<code>setConnectionCallback</code>和<code>setMessageCallback</code>，我们去看下<code>TcpServer</code>对<code>setConnectionCallback</code>怎么实现的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setConnectionCallback</span><span class="params">(<span class="type">const</span> ConnectionCallback &amp;cb)</span> </span>&#123; connectionCallback_ = cb; &#125;</span><br></pre></td></tr></table></figure><p>这样当有新的连接建立时候，就会执行我们设置的<code>EchoServer::onConnection</code>，这样我们就给<code>TcpServer</code>设置了一个回调函数，同时当<code>TcpServer</code>中的<code>Acceptor</code>接受到一个新的连接，<code>TcpServer</code>就会去用这个<code>connfd</code>和对应的<code>peerAddr</code>建立一个新的<code>TcpConnection</code>，同时<code>TcpServer</code>会给这个<code>TcpConnection</code>设置一个回调，而这个回调就是我们给<code>TcpServer</code>设置的回调</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 根据连接成功的sockfd,创建TcpConnection</span></span><br><span class="line">   <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(</span></span></span><br><span class="line"><span class="params"><span class="function">                           ioLoop,</span></span></span><br><span class="line"><span class="params"><span class="function">                           connName,</span></span></span><br><span class="line"><span class="params"><span class="function">                           sockfd,   <span class="comment">// Socket Channel</span></span></span></span><br><span class="line"><span class="params"><span class="function">                           localAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                           peerAddr))</span></span>;</span><br><span class="line">   connections_[connName] = conn;</span><br><span class="line"><span class="comment">// 下面的回调时用户设置给TcpServer，TcpServer又设置给TcpConnection，TcpConnetion又设置给Channel，Channel又设置给Poller，Poller通知channel调用这个回调</span></span><br><span class="line">   conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">   conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">   conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br></pre></td></tr></table></figure><p>当已经建立的连接有新消息来的时候，<code>conn-&gt;setMessageCallback(messageCallback_);</code>这一行代码表示我们给这个<code>conn</code>设置了一个有消息来的时候回调，我们去看下<code>TcpConnection</code>中对<code>setMessageCallback</code>是怎么处理的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setConnectionCallback</span><span class="params">(<span class="type">const</span> ConnectionCallback&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123; connectionCallback_ = cb; &#125;</span><br></pre></td></tr></table></figure><p>所以有消息来的时候，就会执行我们所设置的回调函数<code>onMessage</code>。到这里我么就基本知道新连接的建立和旧连接的消息到来应该做什么，下一章我们说一下消息之间发送的<code>Buffer</code>类。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这次我们主要来说说&lt;code&gt;muduo&lt;/code&gt;库中大量使用的回调机制。&lt;code&gt;muduo&lt;/code&gt;主要使用的是利用&lt;code&gt;Callback&lt;/code&gt;的方式来实现回调，首先我们在自己的&lt;code&gt;EchoServer&lt;/code&gt;构造函数中有这样几行代码&lt;/p&gt;</summary>
    
    
    
    <category term="后端开发" scheme="http://www.shicoder.top/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="导航" scheme="http://www.shicoder.top/tags/%E5%AF%BC%E8%88%AA/"/>
    
    <category term="分享" scheme="http://www.shicoder.top/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>muduo源码分析之TcpServer模块</title>
    <link href="http://www.shicoder.top/posts/335272509.html"/>
    <id>http://www.shicoder.top/posts/335272509.html</id>
    <published>2022-02-20T07:41:20.000Z</published>
    <updated>2022-02-24T07:00:37.898Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们开始<code>muduo</code>源代码的实际编写，首先我们知道<code>muduo</code>是<code>LT</code>模式，<code>Reactor</code>模式，下图为<code>Reactor</code>模式的流程图[来源1]</p><span id="more"></span><p><img src="https://gitee.com/shi_lin_kun/mypicture2/raw/master/img/image-20220220154310731.png" alt="image-20220220154310731"></p><p>然后我们来看下<code>muduo</code>的整体架构[来源1]</p><p><img src="https://gitee.com/shi_lin_kun/pictures/raw/master/image/image-20210422204939773.png" alt="muduo"></p><p>首先<code>muduo</code>有一个主反应堆<code>mainReactor</code>以及几个子反应堆<code>subReactor</code>，其中子反应堆的个数由用户使用<code>setThreadNum</code>函数设置，<code>mainReactor</code>中主要有一个<code>Acceptor</code>，当用户建立新的连接的时候，<code>Acceptor</code>会将<code>connfd</code>和对应的事件打包为一个<code>channel</code>然后采用轮询的算法，指定将该<code>channel</code>给所选择的<code>subReactor</code>，以后该<code>subReactor</code>就负责该<code>channel</code>的所有工作。</p><h1 id="TcpServer类"><a href="#TcpServer类" class="headerlink" title="TcpServer类"></a>TcpServer类</h1><p>我们按照从上到下的思路进行讲解，以下内容我们按照一个简单的<code>EchoServer</code>的实现思路来讲解，我们知道当我们自己实现一个<code>Server</code>的时候，会在构造函数中实例化一个<code>TcpServer</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">EchoServer</span>(EventLoop *loop,</span><br><span class="line">           <span class="type">const</span> InetAddress &amp;addr, </span><br><span class="line">           <span class="type">const</span> std::string &amp;name)</span><br><span class="line">    : <span class="built_in">server_</span>(loop, addr, name)</span><br><span class="line">        , <span class="built_in">loop_</span>(loop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注册回调函数</span></span><br><span class="line">        server_.<span class="built_in">setConnectionCallback</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onConnection, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        server_.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onMessage, <span class="keyword">this</span>,</span><br><span class="line">                      std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置合适的loop线程数量 loopthread 不包括baseloop</span></span><br><span class="line">        server_.<span class="built_in">setThreadNum</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>于是我们去看下<code>TcpServer</code>的构造函数是在干什么</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TcpServer::<span class="built_in">TcpServer</span>(EventLoop *loop,</span><br><span class="line">                <span class="type">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                <span class="type">const</span> std::string &amp;nameArg,</span><br><span class="line">                Option option)</span><br><span class="line">                : <span class="built_in">loop_</span>(<span class="built_in">CheckLoopNotNull</span>(loop))</span><br><span class="line">                , <span class="built_in">ipPort_</span>(listenAddr.<span class="built_in">toIpPort</span>())</span><br><span class="line">                , <span class="built_in">name_</span>(nameArg)</span><br><span class="line">                , <span class="built_in">acceptor_</span>(<span class="keyword">new</span> <span class="built_in">Acceptor</span>(loop, listenAddr, option == kReusePort))</span><br><span class="line">                , <span class="built_in">threadPool_</span>(<span class="keyword">new</span> <span class="built_in">EventLoopThreadPool</span>(loop, name_))</span><br><span class="line">                , <span class="built_in">connectionCallback_</span>()</span><br><span class="line">                , <span class="built_in">messageCallback_</span>()</span><br><span class="line">                , <span class="built_in">nextConnId_</span>(<span class="number">1</span>)</span><br><span class="line">                , <span class="built_in">started_</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当有新用户连接时候，会执行该回调函数</span></span><br><span class="line">    acceptor_-&gt;<span class="built_in">setNewConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::newConnection, <span class="keyword">this</span>, </span><br><span class="line">        std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要关注<code>acceptor_(new Acceptor(loop, listenAddr, option == kReusePort))</code>和<code>threadPool_(new EventLoopThreadPool(loop, name_))</code><br>首先很明确的一点，构造了一个<code>Acceptor</code>，我们首先要知道<code>Acceptor</code>主要就是连接新用户并打包为一个<code>Channel</code>，所以我们就应该知道<code>Acceptor</code>按道理应该实现<code>socket</code>，<code>bind</code>，<code>listen</code>，<code>accept</code>这四个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Acceptor::<span class="built_in">Acceptor</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr, <span class="type">bool</span> reuseport)</span><br><span class="line">    : <span class="built_in">loop_</span>(loop), <span class="built_in">acceptSocket_</span>(<span class="built_in">createNonblocking</span>()) <span class="comment">// socket</span></span><br><span class="line">      ,</span><br><span class="line">      <span class="built_in">acceptChannel_</span>(loop, acceptSocket_.<span class="built_in">fd</span>()), <span class="built_in">listenning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    acceptSocket_.<span class="built_in">setReuseAddr</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">setReusePort</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">bindAddress</span>(listenAddr); <span class="comment">// 绑定套接字</span></span><br><span class="line">    <span class="comment">// 有新用户的连接，执行一个回调（打包为channel）</span></span><br><span class="line">    acceptChannel_.<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::handleRead, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>Acceptor</code>中有个<code>acceptSocket_</code>，其实就是我们平时所用的<code>listenfd</code>，构造函数中实现了<code>socket</code>，<code>bind</code>，而其余的两个函数的使用在其余代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启服务器监听</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 防止一个TcpServer被start多次</span></span><br><span class="line">    <span class="keyword">if</span> (started_++ == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        threadPool_-&gt;<span class="built_in">start</span>(threadInitCallback_); <span class="comment">// 启动底层的loop线程池,这里会按照设定了threadnum设置pool的数量</span></span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::listen, acceptor_.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，当我们设置了<code>threadnum</code>之后，就会有一个<code>mainloop</code>，那么这个<code>loop_</code>就是那个<code>mainloop</code>，其中可以看见这个<code>loop_</code>就只做一个事情<code>Acceptor::listen</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listenning_ = <span class="literal">true</span>;</span><br><span class="line">    acceptSocket_.<span class="built_in">listen</span>();         <span class="comment">// listen</span></span><br><span class="line">    acceptChannel_.<span class="built_in">enableReading</span>(); <span class="comment">// acceptChannel_ =&gt; Poller</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里就实现了<code>listen</code>函数，还有最后一个函数<code>accept</code>，我们慢慢向下分析，从代码可以知道<code>acceptChannel_.enableReading()</code>之后就会使得这个<code>listenfd</code>所在的<code>channel</code>对读事件感兴趣，那什么时候会有读事件呢，就是当用户建立新连接的时候，那么我们应该想一下，那当感兴趣的事件发生之后，<code>listenfd</code>应该干什么呢，应该执行一个回调函数呀。注意<code>Acceptor</code>构造函数中有这样一行代码<code>acceptChannel_.setReadCallback(std::bind(&amp;Acceptor::handleRead, this));</code>这就是那个回调，我们去看下<code>handleRead</code>在干嘛。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// listenfd有事件发生了，就是有新用户连接了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InetAddress peerAddr;</span><br><span class="line">    <span class="type">int</span> connfd = acceptSocket_.<span class="built_in">accept</span>(&amp;peerAddr);</span><br><span class="line">    <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若用户实现定义了，则执行，否则说明用户对新到来的连接没有需要执行的，所以直接关闭</span></span><br><span class="line">        <span class="keyword">if</span> (newConnectionCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">newConnectionCallback_</span>(connfd, peerAddr); <span class="comment">// 轮询找到subLoop，唤醒，分发当前的新客户端的Channel</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ::<span class="built_in">close</span>(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是不是就实现了<code>accept</code>函数，至此当用户建立一个新的连接时候，<code>Acceptor</code>就会得到一个<code>connfd</code>和其对应的<code>peerAddr</code>返回给<code>mainloop</code>，这时候我们在注意到<code>TcpServer</code>构造函数中有这样一行代码<code>acceptor_-&gt;setNewConnectionCallback(std::bind(&amp;TcpServer::newConnection, this,std::placeholders::_1, std::placeholders::_2));</code>我们给<code>acceptor_</code>设置了一个<code>newConnectionCallback_</code>，于是由上面的代码就可以知道，<code>if (newConnectionCallback_)</code>为真，就会执行这个回调函数，于是就会执行<code>TcpServer::newConnection</code>，我们去看下这个函数是在干嘛。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress &amp;peerAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 轮询算法选择一个subloop来管理对应的这个新连接</span></span><br><span class="line">    EventLoop *ioLoop = threadPool_-&gt;<span class="built_in">getNextLoop</span>(); </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;-%s#%d&quot;</span>, ipPort_.<span class="built_in">c_str</span>(), nextConnId_);</span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    std::string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpServer::newConnection [%s] - new connection [%s] from %s \n&quot;</span>,</span><br><span class="line">        name_.<span class="built_in">c_str</span>(), connName.<span class="built_in">c_str</span>(), peerAddr.<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过sockfd获取其绑定的本地ip和端口</span></span><br><span class="line">    sockaddr_in local;</span><br><span class="line">    ::<span class="built_in">bzero</span>(&amp;local, <span class="keyword">sizeof</span> local);</span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span> local;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">getsockname</span>(sockfd, (sockaddr*)&amp;local, &amp;addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;sockets::getLocalAddr&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(local)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据连接成功的sockfd,创建TcpConnection</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(</span></span></span><br><span class="line"><span class="params"><span class="function">                            ioLoop,</span></span></span><br><span class="line"><span class="params"><span class="function">                            connName,</span></span></span><br><span class="line"><span class="params"><span class="function">                            sockfd,   <span class="comment">// Socket Channel</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            localAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                            peerAddr))</span></span>;</span><br><span class="line">    connections_[connName] = conn;</span><br><span class="line"><span class="comment">// 下面的回调时用户设置给TcpServer，TcpServer又设置给TcpConnection，TcpConnetion又设置给Channel，Channel又设置给Poller，Poller通知channel调用这个回调</span></span><br><span class="line">    conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置了如何关闭连接的回调</span></span><br><span class="line">    conn-&gt;<span class="built_in">setCloseCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接调用connectEstablished</span></span><br><span class="line">    ioLoop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就比较长了，我先说下大概他干了啥事情：首先通过轮询找到下一个<code>subloop</code>，然后将刚刚返回的<code>connfd</code>和对应的<code>peerAddr</code>以及<code>localAddr</code>构造为一个<code>TcpConnection</code>给<code>subloop</code>，然后给这个<code>conn</code>设置了一系列的回调函数，比如读回调，写回调，断开回调等等。下一章我们来说下上面的代码最后几行在干嘛。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这次我们开始&lt;code&gt;muduo&lt;/code&gt;源代码的实际编写，首先我们知道&lt;code&gt;muduo&lt;/code&gt;是&lt;code&gt;LT&lt;/code&gt;模式，&lt;code&gt;Reactor&lt;/code&gt;模式，下图为&lt;code&gt;Reactor&lt;/code&gt;模式的流程图[来源1]&lt;/p&gt;</summary>
    
    
    
    <category term="后端开发" scheme="http://www.shicoder.top/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="导航" scheme="http://www.shicoder.top/tags/%E5%AF%BC%E8%88%AA/"/>
    
    <category term="分享" scheme="http://www.shicoder.top/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>muduo源码分析之muduo简单运用</title>
    <link href="http://www.shicoder.top/posts/713527548.html"/>
    <id>http://www.shicoder.top/posts/713527548.html</id>
    <published>2022-02-20T07:39:55.000Z</published>
    <updated>2022-02-24T07:00:37.900Z</updated>
    
    <content type="html"><![CDATA[<p>今天不先实现<code>muduo</code>项目，我们先来看下<code>muduo</code>库的基本使用，只有了解了如何用，才能在写代码的时候知道自己写的找个函数是干嘛的，实际上是怎么使用的这个函数。首先说简单点，就是定义一个<code>Server</code>，设置两个回调函数</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调连接相关的事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line"><span class="comment">// 回调读写事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, Buffer *buffer, Timestamp time)</span></span>;</span><br></pre></td></tr></table></figure><p>意思就是当有客户连接或者断开连接的时候，需要<code>Server</code>做什么，当连接上有读写事件发生时候，需要<code>Server</code>做什么。<br>比如一个<code>EchoServer</code>，当建立连接的时候，会自动调用<code>onConnection</code>函数，当比如我们发送一个消息时候，会自动调用<code>onMessage</code>函数。还有2个重要函数<code>loop</code>，<code>start</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="built_in">start</span>();</span><br><span class="line">loop.<span class="built_in">loop</span>();</span><br></pre></td></tr></table></figure><p>这里简答讲下这2个的区别，其实如果和<code>Epoll</code>做对比的话，<code>start</code>就相当于<code>epoll_create</code>，<code>loop</code>就相当于<code>epoll_wait</code>，后面再根据代码具体说明2个的区别。</br><br>以上就是基本的<code>muduo</code>使用，下一章就开始具体的<code>muduo</code>代码实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天不先实现&lt;code&gt;muduo&lt;/code&gt;项目，我们先来看下&lt;code&gt;muduo&lt;/code&gt;库的基本使用，只有了解了如何用，才能在写代码的时候知道自己写的找个函数是干嘛的，实际上是怎么使用的这个函数。首先说简单点，就是定义一个&lt;code&gt;Server&lt;/code&gt;，设置两个回调函数&lt;/p&gt;</summary>
    
    
    
    <category term="后端开发" scheme="http://www.shicoder.top/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="导航" scheme="http://www.shicoder.top/tags/%E5%AF%BC%E8%88%AA/"/>
    
    <category term="分享" scheme="http://www.shicoder.top/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>muduo源码分析之Buffer</title>
    <link href="http://www.shicoder.top/posts/620043534.html"/>
    <id>http://www.shicoder.top/posts/620043534.html</id>
    <published>2022-02-20T07:37:47.000Z</published>
    <updated>2022-02-24T07:00:37.917Z</updated>
    
    <content type="html"><![CDATA[<p>这一次我们来分析下<code>muduo</code>中<code>Buffer</code>的作用，我们知道，当我们客户端向服务器发送数据时候，服务器就会读取我们发送的数据，然后进行一系列处理，然后再发送到其他地方，在这里我们想象一下最简单的<code>EchoServer</code>服务器，客户端建立一个连接，以后服务器和客户端之间的通信都是通过这个<code>connfd</code>发送和接受数据，于是每一个<code>connfd</code>都应该有一个自己<code>buffer</code>，当我们发送数据太快，服务器发送的太慢，则服务器会将待发送的数据这个<code>buffer</code>中，所以这就是这个类的作用。我们先看下<code>buffer</code>的结构是什么：</p><p><img src="https://gitee.com/shi_lin_kun/pictures/raw/master/img/d2466fdf-c322-417a-9a80-2900d415d81d.png" alt="buffer1"></p><p>我们这里主要针对<code>connfd</code>这个对应的<code>channel</code>进行分析，首先上图是<code>buffer</code>的初始状态，前面<code>8</code>个字节中表示该<code>buffer</code>的大小，初始大小为<code>1024</code>。当客户端发送数据给服务器，同时若服务器接受缓慢，则会向<code>buffer</code>中开始写数据，则<code>writerIndex_</code>会向右移动，假如此时移动到如下形式：</p><p><img src="https://gitee.com/shi_lin_kun/pictures/raw/master/img/10505139-a325-4e85-bea0-b845fad0fd51.png" alt="buffer2"></p><p>则此时缓冲区可以读的数据为<code>writerIndex_ - readerIndex_</code>，可以写的数据为<code>buffer_.size() - writerIndex_</code>。这时候当服务器有多余资源进行读操作，就可以去缓冲区读数据了，假如这时候的状态为如下：</p><p><img src="https://gitee.com/shi_lin_kun/pictures/raw/master/img/c2fc3414-189b-41bf-b649-1c0ba90763e1.png" alt="buffer3"></p><p>这就是常见的几个状态，下面我们去看几个重点的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 把onMessage函数上报的buffer内容转为string</span></span><br><span class="line">  <span class="function">std::string <span class="title">retrieveAllAsString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">retrieveAsString</span>(<span class="built_in">readableBytes</span>()); <span class="comment">// 应用可读取数据的长度</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 可读的数据 就是存放的是即发送的数据</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">readableBytes</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> writerIndex_ - readerIndex_;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">std::string <span class="title">retrieveAsString</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"><span class="comment">// 从可读数据开始位置，长度为len的char构造为一个string</span></span><br><span class="line">      <span class="function">std::string <span class="title">result</span><span class="params">(peek(), len)</span></span>;</span><br><span class="line">      <span class="built_in">retrieve</span>(len); <span class="comment">// 上面一句把缓冲区中可读的数据，已经读取出来，这里肯定要对缓冲区进行复位操作</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将缓冲区len的长度进行复位</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">retrieve</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"><span class="comment">// 表示还没有读完数据</span></span><br><span class="line">      <span class="keyword">if</span> (len &lt; <span class="built_in">readableBytes</span>())</span><br><span class="line">      &#123;</span><br><span class="line">          readerIndex_ += len; <span class="comment">// 应用只读取了刻度缓冲区数据的一部分，就是len，还剩下readerIndex_ += len -&gt; writerIndex_</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>   <span class="comment">// len == readableBytes()</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">retrieveAll</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上是基本的操作，下面的2个函数很重要，一个是向<code>connfd</code>写数据，一个是读数据，对于一个<code>TcpConnection</code>而言，当有数据来的时候，回去调用<code>handleRead</code>回调函数。我们知道<code>muduo</code>设置的每次读取的大小为<code>65536</code>字节，当缓冲区可写的数据大小大于<code>65536</code>，就会直接将读到的数据写入到缓冲区中，但当缓冲区的可写数据大小小于<code>65536</code>的时候，就会将剩余数据先写到一个额外的空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::readFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> extrabuf[<span class="number">65536</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 栈上的内存空间  64K</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> vec[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 这是buffer可写的数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> writable = <span class="built_in">writableBytes</span>(); </span><br><span class="line">    vec[<span class="number">0</span>].iov_base = <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">    vec[<span class="number">0</span>].iov_len = writable;</span><br><span class="line"></span><br><span class="line">    vec[<span class="number">1</span>].iov_base = extrabuf;</span><br><span class="line">    vec[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span> extrabuf;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iovcnt = (writable &lt; <span class="keyword">sizeof</span> extrabuf) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 去百度下readv</span></span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> n = ::<span class="built_in">readv</span>(fd, vec, iovcnt);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= writable) <span class="comment">// Buffer的可写缓冲区已经够存储读出来的数据了</span></span><br><span class="line">    &#123;</span><br><span class="line">        writerIndex_ += n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// extrabuf 也写了数据</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        writerIndex_ = buffer_.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">append</span>(extrabuf, n - writable);  <span class="comment">// writerIndex_开始写 n - writable大小的数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里巧妙的使用了一个<code>readv</code>函数，可以通过按照大小自动写到不同的地方。其中当<code>extrabuf</code>也写了数据，就会调用<code>append</code>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要写len长度的数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ensureWriteableBytes</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">makeSpace</span>(len); <span class="comment">// 扩容函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向缓冲区添加数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ensureWriteableBytes</span>(len);</span><br><span class="line">    std::<span class="built_in">copy</span>(data, data+len, <span class="built_in">beginWrite</span>());</span><br><span class="line">    writerIndex_ += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到有一个<code>makeSpace</code>函数，其中有一个注意点，比如当如下这种状态的时候：</p><p><img src="https://gitee.com/shi_lin_kun/pictures/raw/master/img/c2fc3414-189b-41bf-b649-1c0ba90763e1.png" alt="buffer4"></p><p>此时<code>readerIndex_</code>前面有一部分其实已经被读完了，是空的数据，所以<code>makeSpace</code>函数考虑了这一点，采用内存重组的方式，将<code>readerIndex_</code>向前移动到<code>kCheapPrepend</code>处，然后就可以让空余的内存挨在一起</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeSpace</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() + <span class="built_in">prependableBytes</span>() &lt; len + kCheapPrepend)</span><br><span class="line">    &#123;</span><br><span class="line">        buffer_.<span class="built_in">resize</span>(writerIndex_ + len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> readalbe = <span class="built_in">readableBytes</span>();</span><br><span class="line">        std::<span class="built_in">copy</span>(<span class="built_in">begin</span>() + readerIndex_, </span><br><span class="line">                <span class="built_in">begin</span>() + writerIndex_,</span><br><span class="line">                <span class="built_in">begin</span>() + kCheapPrepend);</span><br><span class="line">        readerIndex_ = kCheapPrepend;</span><br><span class="line">        writerIndex_ = readerIndex_ + readalbe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当向<code>connfd</code>发送数据的时候就比较简单了，直接将可读的数据发送给出去就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过fd发送数据</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::writeFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n = ::<span class="built_in">write</span>(fd, <span class="built_in">peek</span>(), <span class="built_in">readableBytes</span>());</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一次我们来分析下&lt;code&gt;muduo&lt;/code&gt;中&lt;code&gt;Buffer&lt;/code&gt;的作用，我们知道，当我们客户端向服务器发送数据时候，服务器就会读取我们发送的数据，然后进行一系列处理，然后再发送到其他地方，在这里我们想象一下最简单的&lt;code&gt;EchoServe</summary>
      
    
    
    
    <category term="后端开发" scheme="http://www.shicoder.top/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="导航" scheme="http://www.shicoder.top/tags/%E5%AF%BC%E8%88%AA/"/>
    
    <category term="分享" scheme="http://www.shicoder.top/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>muduo项目介绍</title>
    <link href="http://www.shicoder.top/posts/3331102393.html"/>
    <id>http://www.shicoder.top/posts/3331102393.html</id>
    <published>2022-02-20T07:26:15.000Z</published>
    <updated>2022-02-24T07:00:37.907Z</updated>
    
    <content type="html"><![CDATA[<p>在上一个<a href="https://juejin.cn/post/6950230361594920996"><strong>集群聊天服务器</strong></a>项目中，我使用了<code>muduo</code>作为网络库，然后主要实现了业务逻辑等，所以为了深入网络库的代码和实现，我跟着一位老师的代码去实现了<code>muduo</code>库的基本原理和作用，当然只是实现了主体的代码，有些细节便没有深究，以下是自己的目标:</p><ol><li>从开源C++ muduo网络库，学习优秀的代码设计</li><li>掌握基于事件驱动和事件回调的epoll+线程池面向对象编程</li><li>实现<code>TcpServer</code>、<code>TcpConnection</code>、<code>Poller</code>、<code>Chanel</code>等重要部分</li><li>重写muduo核心组件，去依赖boost，用C++11重构</li><li>测试代码是否成功</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在上一个&lt;a href=&quot;https://juejin.cn/post/6950230361594920996&quot;&gt;&lt;strong&gt;集群聊天服务器&lt;/strong&gt;&lt;/a&gt;项目中，我使用了&lt;code&gt;muduo&lt;/code&gt;作为网络库，然后主要实现了业务逻辑等，所以为了深入网</summary>
      
    
    
    
    <category term="后端开发" scheme="http://www.shicoder.top/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="导航" scheme="http://www.shicoder.top/tags/%E5%AF%BC%E8%88%AA/"/>
    
    <category term="分享" scheme="http://www.shicoder.top/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>关于我自己</title>
    <link href="http://www.shicoder.top/posts/404665547.html"/>
    <id>http://www.shicoder.top/posts/404665547.html</id>
    <published>2022-02-20T06:55:53.000Z</published>
    <updated>2022-02-24T07:00:37.915Z</updated>
    
    <content type="html"><![CDATA[<p>这里先自我介绍下：</p><p>本人是一名在读的机械研三学生，转行到计算机，准备2022年7月入职字节，有想转行的同学可以加我QQ(153604363)，大家可以一起学习啦</p><span id="more"></span><h1 id="为什么做这个博客"><a href="#为什么做这个博客" class="headerlink" title="为什么做这个博客"></a>为什么做这个博客</h1><p>这个博客主要记录自己的后端学习记录和一些刷题记录，同时可能会写一些自己的心得感悟，也为自己后面学习有一个知识点仓库，因此可能博客的内容不那么专业，更多的是以我这个水平的同学之间参考</p><p>如果大家觉得博客内容还可以的，也希望可以帮忙转发给朋友啦。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这里先自我介绍下：&lt;/p&gt;
&lt;p&gt;本人是一名在读的机械研三学生，转行到计算机，准备2022年7月入职字节，有想转行的同学可以加我QQ(153604363)，大家可以一起学习啦&lt;/p&gt;</summary>
    
    
    
    <category term="日记杂事" scheme="http://www.shicoder.top/categories/%E6%97%A5%E8%AE%B0%E6%9D%82%E4%BA%8B/"/>
    
    
    <category term="导航" scheme="http://www.shicoder.top/tags/%E5%AF%BC%E8%88%AA/"/>
    
    <category term="分享" scheme="http://www.shicoder.top/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
</feed>
