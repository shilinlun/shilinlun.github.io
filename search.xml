<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于我自己</title>
    <url>/posts/404665547.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<p>这里先自我介绍下：</p>
<p>本人是一名在读的机械研三学生，转行到计算机，准备2022年7月入职字节，有想转行的同学可以加我QQ(153604363)，大家可以一起学习啦</p>
<span id="more"></span>

<h1 id="为什么做这个博客"><a href="#为什么做这个博客" class="headerlink" title="为什么做这个博客"></a>为什么做这个博客</h1><p>这个博客主要记录自己的后端学习记录和一些刷题记录，同时可能会写一些自己的心得感悟，也为自己后面学习有一个知识点仓库，因此可能博客的内容不那么专业，更多的是以我这个水平的同学之间参考</p>
<p>如果大家觉得博客内容还可以的，也希望可以帮忙转发给朋友啦。</p>
]]></content>
      <categories>
        <category>日记杂事</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实现-loader</title>
    <url>/posts/4161701290.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<p>大家好呀，终于我们到了操作系统的loader部分了，loader也是操作系统中最重要的一个部分，承接上面的boot，启下下面的kernel，那我们就开始吧!!!</p>
<span id="more"></span>

<h1 id="内存检测"><a href="#内存检测" class="headerlink" title="内存检测"></a>内存检测</h1><p>在loader中，最重要的一点就是检测内存，检测一些系统参数，到时候给kernel使用，那么下面我们就介绍下loader中如何检测内存。还是一样，我们先看下检测内存的代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">detect_memory:</span><br><span class="line">    ; 置为0</span><br><span class="line">    xor ebx, ebx</span><br><span class="line"></span><br><span class="line">    ; es:di赋值</span><br><span class="line">    mov ax, 0</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov edi, ards_buffer</span><br><span class="line"></span><br><span class="line">    mov edx, 0x534d4150 ;固定签名</span><br><span class="line"></span><br><span class="line">.next:</span><br><span class="line">    mov eax, 0xe820</span><br><span class="line">    mov ecx, 20</span><br><span class="line">    ; 执行系统调用</span><br><span class="line">    int 0x15</span><br><span class="line"></span><br><span class="line">    ; 检测cf标志位</span><br><span class="line">    jc error</span><br><span class="line">    ; 将缓存指针指向下一个结构体</span><br><span class="line">    add di, cx</span><br><span class="line"></span><br><span class="line">    ; 将结构体数量+1</span><br><span class="line">    inc word [ards_count]</span><br><span class="line">    ; 检测ebx是否为0</span><br><span class="line">    cmp ebx, 0</span><br><span class="line">    jnz .next</span><br><span class="line"></span><br><span class="line">    mov si, detecting</span><br><span class="line">    call print</span><br></pre></td></tr></table></figure>

<p>注意，我们这里获取内存的方式是采用BIOS中int 0x15中子功能0xE820。我们先给出int 0x15下3个子功能的具体描述</p>
<ul>
<li>EAX&#x3D;0xE820 ：遍历主机上全部内存</li>
<li>AX&#x3D;0xE801：分别检测第15MB和16MB-4GB的内存</li>
<li>AH&#x3D;0x88：最多检测出64MB内存</li>
</ul>
<p>内存的相关值共同组成一个结构体：ARDS（地址范围描述符），共20字节如下</p>
<ul>
<li>BaseAddrLow（4字节）：基地址的低32位</li>
<li>BaseAddrHigh（4字节）：基地址的高32位</li>
<li>LengthLow（4字节）：内存长度的低32位，以字节为单位</li>
<li>LengthHigh（4字节）：内存长度的高32位，以字节为单位</li>
<li>Type（4字节）：本段内存的类型</li>
</ul>
<p>返回值如下</p>
<ul>
<li>CF位：若CF位为0表示调用未出错</li>
<li>EAX：0x534d4150</li>
<li>ED:DI：ARDS的地址</li>
<li>ECX：写入到ARDS的字节数，一般为20字节</li>
<li>EBX：下一个ARDS的地址，当CF&#x3D;0，且EBX&#x3D;0，表示结束</li>
</ul>
<p>通过上述代码，就可以将ARDS的个数存在ards_count中，将每一个ARDS的值放在ards_buffer中。</p>
<h1 id="准备进入保护模式"><a href="#准备进入保护模式" class="headerlink" title="准备进入保护模式"></a>准备进入保护模式</h1><p>进入保护模式需要三个步骤</p>
<ul>
<li>打开A20</li>
<li>加载GDT</li>
<li>将cr0的pe位置1</li>
</ul>
<h2 id="全局描述符表"><a href="#全局描述符表" class="headerlink" title="全局描述符表"></a>全局描述符表</h2><p>在实模式下，访问一个地址的方式为</p>
<p>段地址 &lt;&lt; 4 + 偏移地址</p>
<p>但是在进入保护模式后，地址线是足够的，共32条，所以并不需要上面的方式，其寻址方式为</p>
<p>段选择子（16位）：段内偏移（32位）</p>
<p>我们来说下段选择子。段选择子有16位，3-15位为描述符索引（13位可表示8192个），第2位为TI位，TI&#x3D;0，表示从全局描述符表中取，TI&#x3D;1，表示从局部描述符表中取。第0-1位为特权级RPL（熟悉的特权级0-3级，用2位描述），代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">selector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> RPL : <span class="number">2</span>; <span class="comment">// Request PL </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> TI : <span class="number">1</span>; <span class="comment">// 0  全局描述符 1 局部描述符 LDT Local </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> index : <span class="number">13</span>; <span class="comment">// 全局描述符表索引</span></span><br><span class="line">&#125; __attribute__((packed)) selector;</span><br></pre></td></tr></table></figure>

<p>上面出现了一个全局描述符表的东西（GDT），全局描述符表中每一项都是一个全局描述符，每个全局描述符都指向内存中的一个位置，下面的图展示了其关系</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220427214535140.png" alt="image-20220427214535140"></p>
<p>因此如何描述这一段内存，就变得尤为重要，全局描述符的结构如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">descriptor</span> <span class="comment">/* 共 8 个字节 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> limit_low;      <span class="comment">// 段界限 0 ~ 15 位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> base_low : <span class="number">24</span>;    <span class="comment">// 基地址 0 ~ 23 位 16M</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> type : <span class="number">4</span>;        <span class="comment">// 段类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> segment : <span class="number">1</span>;     <span class="comment">// 1 表示代码段或数据段，0 表示系统段</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> DPL : <span class="number">2</span>;         <span class="comment">// Descriptor Privilege Level 描述符特权等级 0 ~ 3</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> present : <span class="number">1</span>;     <span class="comment">// 存在位，1 在内存中，0 在磁盘上</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> limit_high : <span class="number">4</span>;  <span class="comment">// 段界限 16 ~ 19;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> available : <span class="number">1</span>;   <span class="comment">// 该安排的都安排了，送给操作系统吧</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> long_mode : <span class="number">1</span>;   <span class="comment">// 64 位扩展标志</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> big : <span class="number">1</span>;         <span class="comment">// 32 位 还是 16 位;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> granularity : <span class="number">1</span>; <span class="comment">// 粒度 4KB 或 1B</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> base_high;       <span class="comment">// 基地址 24 ~ 31 位</span></span><br><span class="line">&#125; __attribute__((packed)) descriptor;</span><br></pre></td></tr></table></figure>

<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220427214816129.png" alt="image-20220427214816129"></p>
<p>则全局描述符表就有8192项，每一项都是指示一片内存的全局描述符，且表的第0项是NULL。有一个特殊寄存器GDT register指向它，只要读取这个寄存器的值，就可以找到这个表，然后通过段选择子就可以知道是哪一个下标。GDT register有48位，结构如下，0-15位共16位标识GDT界限，共65536字节，每个全局描述符8字节，所以一共65536&#x2F;8&#x3D;8192个</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220427215152160.png" alt="image-20220427215152160"></p>
<p>下面给出相关代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">memory_base equ 0 ; 内存开始的位置</span><br><span class="line">; 32位下，内存为4G，然后选用的粒度为4KB</span><br><span class="line">memory_limit equ ((1024 * 1024 * 1024 * 4) / (1024 * 4) - 1) ; 内存界限 4G / 4k -1</span><br><span class="line"></span><br><span class="line">; 准备进入保护模式</span><br><span class="line">prepare_protected_mode:</span><br><span class="line"></span><br><span class="line">    cli; 关闭中断</span><br><span class="line">	...</span><br><span class="line">    ; 加载GDT</span><br><span class="line">    lgdt [gdt_ptr]</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdt_ptr:</span><br><span class="line">    dw (gdt_end-gdt_base)-1</span><br><span class="line">    dd gdt_base</span><br><span class="line">gdt_base:</span><br><span class="line">    ; dd 4个字节，全局描述符表中第一个8字节为null描述符</span><br><span class="line">    dd 0,0 ;null描述符</span><br><span class="line">gdt_code:</span><br><span class="line">    dw memory_limit &amp; 0xffff ; 段界限 0 ~ 15 位</span><br><span class="line">    dw memory_base &amp; 0xffff ; 基地址 0 ~ 15 位</span><br><span class="line">    db (memory_base &gt;&gt; 16) &amp; 0xff ; 基地址 16 ~ 23 位</span><br><span class="line">    ; 存在位，1 在内存中</span><br><span class="line">    ; 特权等级 00</span><br><span class="line">    ; 1 表示代码段或数据段</span><br><span class="line">    ; 段类型 | X | C/E | R/W | A | 1 0 1 0 代码段-非依从-可读-没有访问</span><br><span class="line">    db 0b_1_00_1_1_0_1_0</span><br><span class="line">    ; 1 粒度 4KB</span><br><span class="line">    ; 1 32 位</span><br><span class="line">    ; 0 非64 位扩展标志</span><br><span class="line">    ; 0 available 随意</span><br><span class="line">    ; 段界限 16 ~ 19</span><br><span class="line">    db 0b_1_1_0_0_0000 | (memory_limit &gt;&gt; 16) &amp; 0xf</span><br><span class="line">    ; 基地址 24 ~ 31 位</span><br><span class="line">    db (memory_base &gt;&gt; 24) &amp; 0xff</span><br><span class="line"></span><br><span class="line">gdt_data:</span><br><span class="line">    dw memory_limit &amp; 0xffff ; 段界限 0 ~ 15 位</span><br><span class="line">    dw memory_base &amp; 0xffff ; 基地址 0 ~ 15 位</span><br><span class="line">    db (memory_base &gt;&gt; 16) &amp; 0xff ; 基地址 16 ~ 23 位</span><br><span class="line">    ; 存在位，1 在内存中</span><br><span class="line">    ; 特权等级 00</span><br><span class="line">    ; 1 表示代码段或数据段</span><br><span class="line">    ; 段类型 | X | C/E | R/W | A | 0 0 1 0 数据段-向上-可写-没有访问</span><br><span class="line">    db 0b_1_00_1_0_0_1_0</span><br><span class="line">    ; 1 粒度 4KB</span><br><span class="line">    ; 1 32 位</span><br><span class="line">    ; 0 非64 位扩展标志</span><br><span class="line">    ; 0 available 随意</span><br><span class="line">    ; 段界限 16 ~ 19</span><br><span class="line">    db 0b_1_1_0_0_0000 | (memory_limit &gt;&gt; 16) &amp; 0xf</span><br><span class="line">    ; 基地址 24 ~ 31 位</span><br><span class="line">    db (memory_base &gt;&gt; 24) &amp; 0xff</span><br><span class="line">gdt_end:</span><br></pre></td></tr></table></figure>

<p>我们重点来看重点部分，其他我们后续来说</p>
<p>我们前面说过，在进入保护模式前，我们要加载GDT，以便在保护模式后，其他地方要用到，所以使用如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lgdt [gdt_ptr]; 加载GDT 将gdt_ptr所指向的区域加载到GDT register中</span><br><span class="line">sgdt [gdt_ptr]; 保存 gdt 将GDT register中的内容保存到gdt_ptr所指向的区域</span><br></pre></td></tr></table></figure>

<p>然后我们构建代码段和数据段的段选择子，通过选择子的结构进行构建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">; 构建代码段和数据段的段选择子</span><br><span class="line">; 1 &lt;&lt; 3 =&gt; 0001 根据段选择子的结构，第0-1位为 RPL ,第2位为TI ,后面为index</span><br><span class="line">code_selector equ (1 &lt;&lt; 3)</span><br><span class="line">data_selector equ (2 &lt;&lt; 3)</span><br></pre></td></tr></table></figure>

<h2 id="A20线"><a href="#A20线" class="headerlink" title="A20线"></a>A20线</h2><p>其实就是为了在保护模式下可以使用更大的寻址线，因此打开A20线，方式很简单，就是将端口0x92的第1位置1就可以，代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">; 打开A20线</span><br><span class="line">in al, 0x92</span><br><span class="line">or al, 0b10 ; 第1位置1</span><br><span class="line">out 0x92, al</span><br></pre></td></tr></table></figure>

<h2 id="CR0寄存器"><a href="#CR0寄存器" class="headerlink" title="CR0寄存器"></a>CR0寄存器</h2><p>我们需要将CR0寄存器的第0位（PE位）Protection Enable打开，方式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mov eax, cr0</span><br><span class="line">or eax, 1 ; 第0位置1</span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure>

<h2 id="刷新流水线"><a href="#刷新流水线" class="headerlink" title="刷新流水线"></a>刷新流水线</h2><p>我们可以看到一条很奇怪的jmp指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">; 用跳转来刷新缓存，启用保护模式</span><br><span class="line">jmp dword code_selector:protect_mode</span><br><span class="line"></span><br><span class="line">; 提醒编译器，到了32位的保护模式</span><br><span class="line">[bits 32]</span><br><span class="line">protect_mode:</span><br></pre></td></tr></table></figure>

<p>因为我们知道在跳转前是实模式，可能是16位，但是跳转到保护模式后，需要在32位下进行，那么CPU指令却不知道，仍然可能用16位的方式去解析32位指令，就会出错，因此采用1个jmp模式进行</p>
<h1 id="进入保护模式"><a href="#进入保护模式" class="headerlink" title="进入保护模式"></a>进入保护模式</h1><p>经过前面的步骤，我们终于来到了保护模式<code>protect_mode</code>。这个版本的操作系统我们设置的保护模式很简单，代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line">protect_mode:</span><br><span class="line"></span><br><span class="line">    mov ax, data_selector</span><br><span class="line">    ; 初始化段寄存器</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov fs, ax</span><br><span class="line">    mov gs, ax</span><br><span class="line">    mov ss, ax</span><br><span class="line"></span><br><span class="line">    ; 在0x7e00-0x9fbff可用区域间随便找一个位置</span><br><span class="line">    mov esp, 0x10000 ;修改栈顶</span><br><span class="line"></span><br><span class="line">    ; 因为system.bin(kernel文件夹里面的程序编译的)是从第10个扇区开始写入，写了200个扇区</span><br><span class="line">    mov edi, 0x10000;读取的目标内存</span><br><span class="line">    mov ecx, 10 ;起始扇区</span><br><span class="line">    mov bl, 200 ;扇区数量</span><br><span class="line">    call read_disk</span><br><span class="line">    ; 内核代码被放在0x10000处，所以跳转到这里执行内核代码</span><br><span class="line">    jmp dword code_selector: 0x10000</span><br></pre></td></tr></table></figure>

<p>我们在编译的时候，先将system.bin写入到磁盘的第10个扇区，命令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=system.bin of=master.img bs=512 count=200 seek=10 conv=notrunc  </span><br></pre></td></tr></table></figure>

<p>终于我们可以编写c语言了，前面写汇编实在难受，哈哈哈。</p>
<p>内核的主程序在main.c中，先简单实现下把，后续再补充</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">kernel_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> *video = (<span class="type">char</span>*)<span class="number">0xb8000</span>; <span class="comment">// 文本显示器的内存位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(message); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 第一个位是字符，第二个位是该字符的特性，比如是闪烁还是不闪烁等，所以每个字符要在内存位置占2个位</span></span><br><span class="line">        video[i*<span class="number">2</span>] = message[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意下0xb8000，在这个系列的第2章中，有如下代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">; 0xb8000 文本显示器的内存区域</span><br><span class="line">mov ax, 0xb800</span><br><span class="line">mov ds, ax</span><br><span class="line">mov byte [0], &#x27;H&#x27;</span><br></pre></td></tr></table></figure>

<p>0xb8000已经超过16位了，所以在实模式下，需要使用<code>( 16 位段基址 &lt;&lt; 4 ) + 16 位偏移地址</code>方式，而在保护模式下有32位，所以可以直接访问</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实现-boot.asm实现</title>
    <url>/posts/3107354293.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<p>这一次我们进入操作系统实现的真实编码， 这一次主要是完善对boot.asm文件的全部实现，开始吧。。。</p>
<span id="more"></span>

<p>首先我们先来理一下boot.asm需要干什么</p>
<ul>
<li>打印出<code>Booting System...</code></li>
<li>实现磁盘读写</li>
<li>将后续的<code>loader.asm</code>所在的区域读入到<code>0x1000</code>处，然后跳转进入<code>loader.asm</code>程序</li>
<li>开始执行<code>loader.asm</code>程序（这一节我们下次实现）</li>
</ul>
<h1 id="实模式下的print"><a href="#实模式下的print" class="headerlink" title="实模式下的print"></a>实模式下的print</h1><p>在我们平时编写c语言时候，可以直接使用，但是在boot.asm中，完全就没有可以用库函数，因此为了在开始打印处start boot，我们需要自己实现print</p>
<p>先来看下代码把</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mov si, booting</span><br><span class="line">call print</span><br><span class="line"></span><br><span class="line">print:</span><br><span class="line">    mov ah, 0x0e</span><br><span class="line">.next:</span><br><span class="line">    mov al, [si]</span><br><span class="line">    cmp al, 0</span><br><span class="line">    jz .done</span><br><span class="line">    int 0x10</span><br><span class="line">    inc si</span><br><span class="line">    jmp .next</span><br><span class="line">.done:</span><br><span class="line">    ret</span><br><span class="line">booting:</span><br><span class="line">    db &quot;Booting System...&quot;, 10, 13, 0; \n\r</span><br></pre></td></tr></table></figure>

<p>这段程序主要使用使用BIOS的<code>int 10h</code>来实现一个<code>print</code>功能，<code>al</code>寄存器存储要显示的字符串</p>
<h1 id="磁盘读写"><a href="#磁盘读写" class="headerlink" title="磁盘读写"></a>磁盘读写</h1><p>因为<code>boot.asm</code>在主引导扇区，磁盘内存太小，不能在<code>boot.asm</code>中实现<code>loader.asm</code>的功能，因此我们将<code>loader.asm</code>保存在磁盘的一个地方，在<code>boot.asm</code>中利用磁盘读的方式，将代码读入到内存的一个区域，然后跳转到那个地方</p>
<p>先来看下磁盘读的功能实现</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">; 函数参数</span><br><span class="line">; edi 将磁盘内容读到哪里</span><br><span class="line">; ecx 从磁盘哪一个扇区开始 </span><br><span class="line">; bl 要读多少个扇区</span><br><span class="line">read_disk:</span><br><span class="line">    ; 设置读写扇区的数量</span><br><span class="line">    ; 0x1f2 是硬盘控制端口，表示读写扇区的数量</span><br><span class="line">    mov dx, 0x1f2</span><br><span class="line">    mov al, bl</span><br><span class="line">    ; 写端口用OUT指令 将al的值写入到dx端口</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    inc dx; 0x1f3 起始扇区前8位端口</span><br><span class="line">    ; 因为ecx为起始扇区 </span><br><span class="line">    ; ecx中的cl就是0-7位</span><br><span class="line">    mov al, cl; 起始扇区前8位</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    inc dx; 0x1f4 起始扇区中8位端口</span><br><span class="line">    shr ecx, 8 ;右移8位</span><br><span class="line">    mov al, cl; 起始扇区中8位</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    inc dx; 0x1f5 起始扇区高8位端口</span><br><span class="line">    shr ecx, 8 ;右移8位</span><br><span class="line">    mov al, cl; 起始扇区高8位</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    inc dx ;0x1f6</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    and cl, 0b1111 ;将高4位置为0，对应起始扇区的24-27位</span><br><span class="line">    mov al,0b1110_0000 ;第4位为0，表示主盘，第6位为1，表示LBA，5-7位必须为1</span><br><span class="line">    ; 将al和cl合二为一，放在al中</span><br><span class="line">    or al, cl</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    inc dx ;0x1f7</span><br><span class="line">    mov al, 0x20 ;表示读硬盘</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    xor ecx, ecx ;清空ecx</span><br><span class="line">    mov cl, bl ;得到写扇区的数量</span><br><span class="line"></span><br><span class="line">    ; loop指令会检查ecx是否为0 cl在ecx里面</span><br><span class="line">    .read:</span><br><span class="line">        push cx ;保存下，因为函数里面使用了</span><br><span class="line">        call .waits ;等待数据准备完毕</span><br><span class="line">        call .reads ;读取一个扇区</span><br><span class="line">        pop cx ;恢复</span><br><span class="line">        loop .read</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">    .waits:</span><br><span class="line">        mov dx, 0x1f7 ;读0x1f7端口</span><br><span class="line">        .check:</span><br><span class="line">            in al, dx ;将dx端口的值放入al中</span><br><span class="line">            jmp $+2 ;直接跳转到下一行 其实什么都没做，就是为了延迟一下</span><br><span class="line">            jmp $+2</span><br><span class="line">            jmp $+2</span><br><span class="line"></span><br><span class="line">            and al, 0b1000_1000 ;获得al的第3位和第7位</span><br><span class="line">            cmp al, 0b0000_1000 ;测试是否第7位为0，第3位为1 硬盘不繁忙，数据准备完毕</span><br><span class="line">            jnz .check ;数据没准备好</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">    .reads:</span><br><span class="line">        mov dx, 0x1f0 ;用于读写数据</span><br><span class="line">        mov cx, 256 ;一个扇区256字节</span><br><span class="line">        ; loop指定会检查ecx cx在ecx里面</span><br><span class="line">        .readw:</span><br><span class="line">            in ax, dx</span><br><span class="line">            jmp $+2 ;直接跳转到下一行 其实什么都没做，就是为了延迟一下</span><br><span class="line">            jmp $+2</span><br><span class="line">            jmp $+2</span><br><span class="line"></span><br><span class="line">            ; edi表示读取的目标内存</span><br><span class="line">            mov [edi], ax</span><br><span class="line">            ; 因为ax是16bit，2个字节，所以edi+2</span><br><span class="line">            add edi, 2</span><br><span class="line">            loop .readw</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>下面是磁盘的相关端口</p>
<table>
<thead>
<tr>
<th>Primary 通道</th>
<th>Secondary 通道</th>
<th>in 操作</th>
<th>out 操作</th>
</tr>
</thead>
<tbody><tr>
<td>0x1F0</td>
<td>0x170</td>
<td>Data</td>
<td>Data</td>
</tr>
<tr>
<td>0x1F1</td>
<td>0x171</td>
<td>Error</td>
<td>Features</td>
</tr>
<tr>
<td>0x1F2</td>
<td>0x172</td>
<td>Sector count</td>
<td>Sector count</td>
</tr>
<tr>
<td>0x1F3</td>
<td>0x173</td>
<td>LBA low</td>
<td>LBA low</td>
</tr>
<tr>
<td>0x1F4</td>
<td>0x174</td>
<td>LBA mid</td>
<td>LBA mid</td>
</tr>
<tr>
<td>0x1F5</td>
<td>0x175</td>
<td>LBA high</td>
<td>LBA high</td>
</tr>
<tr>
<td>0x1F6</td>
<td>0x176</td>
<td>Device</td>
<td>Device</td>
</tr>
<tr>
<td>0x1F7</td>
<td>0x177</td>
<td>Status</td>
<td>Command</td>
</tr>
</tbody></table>
<ul>
<li>0x1F0：16bit 端口，用于读写数据</li>
<li>0x1F1：检测前一个指令的错误</li>
<li>0x1F2：读写扇区的数量</li>
<li>0x1F3：起始扇区的 0 ~ 7 位</li>
<li>0x1F4：起始扇区的 8 ~ 15 位</li>
<li>0x1F5：起始扇区的 16 ~ 23 位</li>
<li>0x1F6:<ul>
<li>0 ~ 3：起始扇区的 24 ~ 27 位</li>
<li>4: 0 主盘, 1 从片</li>
<li>6: 0 CHS, 1 LBA</li>
<li>5 ~ 7：固定为1</li>
</ul>
</li>
<li>0x1F7: out<ul>
<li>0xEC: 识别硬盘</li>
<li>0x20: 读硬盘</li>
<li>0x30: 写硬盘</li>
</ul>
</li>
<li>0x1F7: in &#x2F; 8bit<ul>
<li>0 ERR</li>
<li>3 DRQ 数据准备完毕</li>
<li>7 BSY 硬盘繁忙</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意上面的out和in指令</p>
<p>读端口用IN指令，写端口用OUT指令</p>
<p>out a，b 将b的值写入到a端口</p>
<p>in   a，b 将b端口的值读到a中</p>
</blockquote>
<p>先来看4个起始扇区的寄存器 ：<code>0x1F3</code>、<code>0x1F4</code>、<code>0x1F5</code>、<code>0x1F6</code>，假如此时的起始扇区<code>ecx=123456789</code> ,即32位bit为<code>00000111010110111100110100010101</code></p>
<ul>
<li><p>0-7位：<code>00010101</code> &#x3D;&gt; <code>0x1F3</code></p>
</li>
<li><p>8-15位：<code>11001101</code> &#x3D;&gt; <code>0x1F4</code></p>
</li>
<li><p>16-23位：<code>01011011</code> &#x3D;&gt; <code>0x1F5</code></p>
</li>
<li><p>24-31位：<code>00000111</code></p>
<ul>
<li>24-27位：<code>0111</code> &#x3D;&gt; <code>0x1F6</code>(0-3)</li>
<li><code>mov al,0b1110_0000</code><ul>
<li><code>0</code> &#x3D;&gt; <code>0x1F6</code>(4) 表示主盘</li>
<li><code>111</code> &#x3D;&gt; <code>ox1F6</code>(5-7) 固定为1</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>再来看<code>0x1F7</code>，值为<code>0x20</code>，表示读磁盘</p>
<p>然后通过<code>mov cl,bl</code>，将扇区数量放在<code>cl</code>中，后面进行循环，汇编中循环的次数和<code>ecx</code>有关。因为是要读磁盘，因此需要先等待磁盘数据处理好，然后才进行读取，<code>.wait</code>便是这个作用，其余的相关解析可以通过代码注释看懂，这里就不赘述了</p>
<blockquote>
<p>jmp $+2</p>
<p>可以通过反汇编看到</p>
<p>0000:jmp $+2<br>0002:xxx</p>
<p>所以这行代码就是跳到下一行，起到等待的作用</p>
</blockquote>
<p>经过编写这个函数，我们就可以从磁盘中得到我们想要的代码啦，前面说过，我们本身就想将<code>loader.asm</code>代码放在磁盘的一个地方，然后再读进来，那怎么放呢，这样，我们先简单写一个<code>loader.asm</code></p>
<h1 id="loader-asm"><a href="#loader-asm" class="headerlink" title="loader.asm"></a><code>loader.asm</code></h1><p>代码如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[org 0x1000]</span><br><span class="line"></span><br><span class="line">; 打印字符串</span><br><span class="line">mov si, loading</span><br><span class="line">call print</span><br><span class="line"></span><br><span class="line">; 阻塞</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">print:</span><br><span class="line">    mov ah, 0x0e</span><br><span class="line">.next:</span><br><span class="line">    mov al, [si]</span><br><span class="line">    cmp al, 0</span><br><span class="line">    jz .done</span><br><span class="line">    int 0x10</span><br><span class="line">    inc si</span><br><span class="line">    jmp .next</span><br><span class="line">.done:</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">loading:</span><br><span class="line">    db &quot;Loading System...&quot;, 10, 13, 0; \n\r</span><br></pre></td></tr></table></figure>

<p>同样的，我们只是打印出一句话即可，那我们怎么将这些代码复制到磁盘中去呢，下面两行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nasm -f bin loader.bin loader.asm</span><br><span class="line">dd if=loader.bin of=master.img bs=512 count=4 seek=2 conv=notrunc</span><br></pre></td></tr></table></figure>

<p>利用dd命令，将bin文件从偏移为2的地方，写入4个到master.img中，这样就可以知道<code>loader.bin</code>在磁盘哪里，就可以读入了</p>
<p><code>boot.asm</code>中代码如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">; 因为loader.bin是从第2个扇区开始写入，写了4个扇区</span><br><span class="line">mov edi, 0x1000;读取的目标内存</span><br><span class="line">mov ecx, 2 ;起始扇区</span><br><span class="line">mov bl, 4 ;扇区数量</span><br><span class="line">call read_disk</span><br></pre></td></tr></table></figure>

<p>经过上面一番折腾，终于从<code>boot</code>跳转到<code>loader</code>中了，后续我们将对<code>loader.asm</code>进行完善，实现<code>loader</code>所需要的功能，下次见啦。。。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实现-简单热身</title>
    <url>/posts/2733103160.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<p>这次对上次的boot.asm进行代码讲解，也可以对汇编的相关理论进行补充</p>
<span id="more"></span>

<h1 id="boot-asm"><a href="#boot-asm" class="headerlink" title="boot.asm"></a><code>boot.asm</code></h1><p>主引导扇区位于硬盘的0柱面0磁头1扇区处，首先BIOS加电后，就会将主引导程序加载进来，然后执行</p>
<p>我们先看下boot.asm中有啥把</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[org 0x7c00]</span><br><span class="line"></span><br><span class="line">; 设置屏幕模式为文本模式，清除屏幕</span><br><span class="line">mov ax, 3</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">; 初始化段寄存器</span><br><span class="line">mov ax, 0</span><br><span class="line">mov ds, ax</span><br><span class="line">mov es, ax</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 0x7c00</span><br><span class="line"></span><br><span class="line">; 0xb8000 文本显示器的内存区域</span><br><span class="line">mov ax, 0xb800</span><br><span class="line">mov ds, ax</span><br><span class="line">mov byte [0], &#x27;H&#x27;</span><br><span class="line"></span><br><span class="line">; 阻塞</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">; 填充 0</span><br><span class="line">times 510 - ($ - $$) db 0</span><br><span class="line"></span><br><span class="line">; 主引导扇区的最后两个字节必须是 0x55 0xaa</span><br><span class="line">; dw 0xaa55</span><br><span class="line">db 0x55, 0xaa</span><br></pre></td></tr></table></figure>

<ul>
<li>0x7c00</li>
</ul>
<p>因为bios在上电之后，会去将boot主引导程序加载到0x7c00，然后利用一个跳转，跳到0x7c00处执行，因此我们需要将boot.asm代码放在0x7c00处，org便是这个功能</p>
<ul>
<li>设置屏幕为文本模式</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mov ax, 3</span><br><span class="line">int 0x10</span><br></pre></td></tr></table></figure>

<p>int 0x10为bios中断服务，给定不同的ax，会进行不同的调用程序，下表给出ax&#x3D;3时候的程序</p>
<table>
<thead>
<tr>
<th>AL</th>
<th>文字&#x2F;图形</th>
<th>分表率</th>
<th>颜色</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>文字</td>
<td>40*25</td>
<td>2</td>
</tr>
<tr>
<td>01</td>
<td>文字</td>
<td>40*25</td>
<td>16</td>
</tr>
<tr>
<td>02</td>
<td>文字</td>
<td>80*25</td>
<td>2</td>
</tr>
<tr>
<td>03</td>
<td>文字</td>
<td>80*25</td>
<td>16</td>
</tr>
<tr>
<td>04</td>
<td>图形</td>
<td>320*320</td>
<td>2</td>
</tr>
<tr>
<td>05</td>
<td>图形</td>
<td>320*320</td>
<td>4</td>
</tr>
<tr>
<td>06</td>
<td>图形</td>
<td>640*200</td>
<td>2</td>
</tr>
</tbody></table>
<ul>
<li>初始化段寄存器</li>
</ul>
<p>因为不能使用<code>mov ds,0</code>这种，因此借助<code>ax</code>进行初始化</p>
<ul>
<li>显示文本</li>
</ul>
<p>由于BIOS加载之后，还是实模式，为了在这个模式下显示文本，我们需要知道要在哪个内存区域进行显示，下面给出实模式下的内存区域</p>
<table>
<thead>
<tr>
<th>起始地址</th>
<th>结束地址</th>
<th>大小</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>0x000</code></td>
<td><code>0x3FF</code></td>
<td>1KB</td>
<td>中断向量表</td>
</tr>
<tr>
<td><code>0x400</code></td>
<td><code>0x4FF</code></td>
<td>256B</td>
<td>BIOS 数据区</td>
</tr>
<tr>
<td><code>0x500</code></td>
<td><code>0x7BFF</code></td>
<td>29.75 KB</td>
<td>可用区域</td>
</tr>
<tr>
<td><code>0x7C00</code></td>
<td><code>0x7DFF</code></td>
<td>512B</td>
<td>MBR 加载区域</td>
</tr>
<tr>
<td><code>0x7E00</code></td>
<td><code>0x9FBFF</code></td>
<td>607.6KB</td>
<td>可用区域</td>
</tr>
<tr>
<td><code>0x9FC00</code></td>
<td><code>0x9FFFF</code></td>
<td>1KB</td>
<td>扩展 BIOS 数据区</td>
</tr>
<tr>
<td><code>0xA0000</code></td>
<td><code>0xAFFFF</code></td>
<td>64KB</td>
<td>用于彩色显示适配器</td>
</tr>
<tr>
<td><code>0xB0000</code></td>
<td><code>0xB7FFF</code></td>
<td>32KB</td>
<td>用于黑白显示适配器</td>
</tr>
<tr>
<td><code>0xB8000</code></td>
<td><code>0xBFFFF</code></td>
<td>32KB</td>
<td>用于文本显示适配器</td>
</tr>
<tr>
<td><code>0xC0000</code></td>
<td><code>0xC7FFF</code></td>
<td>32KB</td>
<td>显示适配器 BIOS</td>
</tr>
<tr>
<td><code>0xC8000</code></td>
<td><code>0xEFFFF</code></td>
<td>160KB</td>
<td>映射内存</td>
</tr>
<tr>
<td><code>0xF0000</code></td>
<td><code>0xFFFEF</code></td>
<td>64KB-16B</td>
<td>系统 BIOS</td>
</tr>
<tr>
<td><code>0xFFFF0</code></td>
<td><code>0xFFFFF</code></td>
<td>16B</td>
<td>系统 BIOS 入口地址</td>
</tr>
</tbody></table>
<p>可以看出在0xb8000处可以显示文本，因此</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mov ax, 0xb800</span><br><span class="line">mov ds, ax</span><br><span class="line">mov byte [0], &#x27;H&#x27;</span><br><span class="line">相当于是 move byte ds:[0], &#x27;H&#x27;</span><br><span class="line">实模式下寻址方式为</span><br><span class="line">( 16 位段基址 &lt;&lt; 4 ) + 16 位偏移地址</span><br><span class="line">ds &lt;&lt; 4 + 0 = 0xb8000</span><br></pre></td></tr></table></figure>

<ul>
<li>0x55aa</li>
</ul>
<p>若一段程序结束的魔数为0x55aa，BIOS才会认为是合格的主引导程序</p>
<blockquote>
<p>注意，在汇编代码中，若定义一个数字 ，左边是高位</p>
<p>比如  dw 0xaa55，则编译之后，aa在高位</p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实现-开发环境配置</title>
    <url>/posts/543605244.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<p>这一次我们开始自己实现一个简单的操作系统，当然自己也是在看别人的视频进行学习，希望自己能从这个实验中学习到操作系统相关的知识</p>
<span id="more"></span>

<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><ul>
<li>VMware</li>
<li>ArchLinux</li>
<li>VSCode</li>
<li>nasm</li>
<li>bochs</li>
<li>qemu</li>
<li>gdb</li>
</ul>
<h1 id="VSCode远程连接"><a href="#VSCode远程连接" class="headerlink" title="VSCode远程连接"></a>VSCode远程连接</h1><p>这个步骤就大家自行百度下把</p>
<h1 id="boot-asm"><a href="#boot-asm" class="headerlink" title="boot.asm"></a>boot.asm</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[org 0x7c00]</span><br><span class="line"></span><br><span class="line">; 设置屏幕模式为文本模式，清除屏幕</span><br><span class="line">mov ax, 3</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">; 初始化段寄存器</span><br><span class="line">mov ax, 0</span><br><span class="line">mov ds, ax</span><br><span class="line">mov es, ax</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 0x7c00</span><br><span class="line"></span><br><span class="line">; 0xb8000 文本显示器的内存区域</span><br><span class="line">mov ax, 0xb800</span><br><span class="line">mov ds, ax</span><br><span class="line">mov byte [0], &#x27;H&#x27;</span><br><span class="line"></span><br><span class="line">; 阻塞</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">; 填充 0</span><br><span class="line">times 510 - ($ - $$) db 0</span><br><span class="line"></span><br><span class="line">; 主引导扇区的最后两个字节必须是 0x55 0xaa</span><br><span class="line">; dw 0xaa55</span><br><span class="line">db 0x55, 0xaa</span><br></pre></td></tr></table></figure>

<ul>
<li>编译</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nasm -f bin boot.asm boot.bin</span><br></pre></td></tr></table></figure>

<ul>
<li>创建硬盘镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bximage -q -hd=16 -func=create -sectsize=512 -imgmode=flat master.img</span><br></pre></td></tr></table></figure>

<ul>
<li>配置bochsrc</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">configuration file generated by Bochs</span></span><br><span class="line">plugin_ctrl: unmapped=true, biosdev=true, speaker=true, extfpuirq=true, parallel=true, serial=true, iodebug=true, pcidev=false, usb_uhci=false</span><br><span class="line">config_interface: textconfig</span><br><span class="line">display_library: x,options=&quot;gui_debug&quot;</span><br><span class="line">memory: host=32, guest=32</span><br><span class="line">romimage: file=&quot;/usr/share/bochs/BIOS-bochs-latest&quot;, address=0x00000000, options=none</span><br><span class="line">vgaromimage: file=&quot;/usr/share/bochs/VGABIOS-lgpl-latest&quot;</span><br><span class="line">boot: disk</span><br><span class="line">floppy_bootsig_check: disabled=0</span><br><span class="line">floppya: type=1_44</span><br><span class="line"><span class="meta"># </span><span class="language-bash">no floppyb</span></span><br><span class="line">ata0: enabled=true, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line">ata0-master: type=disk, path=&quot;../build/master.img&quot;, mode=flat</span><br><span class="line">ata0-slave: type=none</span><br><span class="line">ata1: enabled=true, ioaddr1=0x170, ioaddr2=0x370, irq=15</span><br><span class="line">ata1-master: type=none</span><br><span class="line">ata1-slave: type=none</span><br><span class="line">ata2: enabled=false</span><br><span class="line">ata3: enabled=false</span><br><span class="line">optromimage1: file=none</span><br><span class="line">optromimage2: file=none</span><br><span class="line">optromimage3: file=none</span><br><span class="line">optromimage4: file=none</span><br><span class="line">optramimage1: file=none</span><br><span class="line">optramimage2: file=none</span><br><span class="line">optramimage3: file=none</span><br><span class="line">optramimage4: file=none</span><br><span class="line">pci: enabled=1, chipset=i440fx, slot1=none, slot2=none, slot3=none, slot4=none, slot5=none</span><br><span class="line">vga: extension=vbe, update_freq=5, realtime=1, ddc=builtin</span><br><span class="line">cpu: count=1:1:1, ips=4000000, quantum=16, model=bx_generic, reset_on_triple_fault=1, cpuid_limit_winnt=0, ignore_bad_msrs=1, mwait_is_nop=0</span><br><span class="line">cpuid: level=6, stepping=3, model=3, family=6, vendor_string=&quot;AuthenticAMD&quot;, brand_string=&quot;AMD Athlon(tm) processor&quot;</span><br><span class="line">cpuid: mmx=true, apic=xapic, simd=sse2, sse4a=false, misaligned_sse=false, sep=true</span><br><span class="line">cpuid: movbe=false, adx=false, aes=false, sha=false, xsave=false, xsaveopt=false, avx_f16c=false</span><br><span class="line">cpuid: avx_fma=false, bmi=0, xop=false, fma4=false, tbm=false, x86_64=true, 1g_pages=false</span><br><span class="line">cpuid: pcid=false, fsgsbase=false, smep=false, smap=false, mwait=true</span><br><span class="line">print_timestamps: enabled=0</span><br><span class="line">debugger_log: -</span><br><span class="line">magic_break: enabled=1</span><br><span class="line">port_e9_hack: enabled=0</span><br><span class="line">private_colormap: enabled=0</span><br><span class="line">clock: sync=none, time0=local, rtc_sync=0</span><br><span class="line"><span class="meta"># </span><span class="language-bash">no cmosimage</span></span><br><span class="line">log: -</span><br><span class="line">logprefix: %t%e%d</span><br><span class="line">debug: action=ignore</span><br><span class="line">info: action=report</span><br><span class="line">error: action=report</span><br><span class="line">panic: action=ask</span><br><span class="line">keyboard: type=mf, serial_delay=250, paste_delay=100000, user_shortcut=none</span><br><span class="line">mouse: type=ps2, enabled=false, toggle=ctrl+mbutton</span><br><span class="line">speaker: enabled=true, mode=system</span><br><span class="line">parport1: enabled=true, file=none</span><br><span class="line">parport2: enabled=false</span><br><span class="line">com1: enabled=true, mode=null</span><br><span class="line">com2: enabled=false</span><br><span class="line">com3: enabled=false</span><br><span class="line">com4: enabled=false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>将boot.bin写入到主引导扇区</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=boot.bin of=master.img bs=512 count=1 conv=notrunc</span><br></pre></td></tr></table></figure>

<h1 id="bochs中运行"><a href="#bochs中运行" class="headerlink" title="bochs中运行"></a>bochs中运行</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bochs -q -f bochsrc</span><br></pre></td></tr></table></figure>

<p>若bochs中显示出一个<code>H</code>，则表明配置环境成功，下一节，我们将对刚刚那个<code>boot.asm</code>进行代码讲解</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>集群聊天服务器六</title>
    <url>/posts/2449255119.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<p>对于前面单台服务器而言，几千的客户端压力基本没有什么影响，但当客户端达到上万的时候，就可能会遇到一些问题，因此我准备采用<code>nginx+redis</code>的方式进行负载均衡，主要思路如下：</p>
<span id="more"></span>

<ol>
<li>利用<code>nginx</code>作为中转服务器，开启<code>8000</code>端口</li>
<li>本地<code>ip</code>开启2个端口<code>6000</code>以及<code>6002</code>，相当于可以同时开启2台服务器</li>
<li>客户端连接<code>8000</code>端口，<code>nginx</code>会按照配置的服务器权重将连接分发到不同服务器上</li>
<li>利用<code>redis</code>的订阅-发布命令来作为聊天信息中转站</li>
</ol>
<blockquote>
<p>例如用户1向用户2发送消息，当用户1所在服务器查询到用户2在该服务器上未登录的时候，并不是直接将信息存入离线表中，而是先去数据库查询用户2是否在线，若在线则表明用户2在其他服务器上登录，于是利用<code>redis</code>作为信息中转站，服务器将信息发给<code>redis</code>，<code>redis</code>将信息再发送给用户2</p>
</blockquote>
<h1 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">nginx 负载均衡配置</span></span><br><span class="line">stream&#123;</span><br><span class="line">        # 相当于是有2台服务器，weight=1表示大家都是公平选取，max_fails表示和主服务器进行3次心跳，</span><br><span class="line">        # 如果30s内没有响应，则心跳失败一次，连续3次失败，就说明该次服务器断了</span><br><span class="line">        upstream MyServer&#123;</span><br><span class="line">                server 127.0.0.1:6000 weight=1 max_fails=3 fail_timeout=30s;</span><br><span class="line">                server 127.0.0.1:6002 weight=1 max_fails=3 fail_timeout=30s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        server &#123;</span><br><span class="line">                proxy_connect_timeout 1s;</span><br><span class="line">                # 表示所有客户端都去连接8000端口，然后再去分发到其他服务器上</span><br><span class="line">                listen 8000;</span><br><span class="line">                # 就是一个名字，连到哪个服务器</span><br><span class="line">                proxy_pass MyServer;</span><br><span class="line">                tcp_nodelay on;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><p>首先每个用户登录的时候，都会向<code>redis</code>订阅一个消息，命令为<code>SUBSCRIBE runoobChat</code>，我们将<code>runoobChat</code>设置为用户的<code>userid</code>，到时候当有消息到来的时候，<code>redis</code>就会向<code>userid</code>对应的<code>TcpConnectionPtr</code>发送消息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// id用户登录成功后，向redis订阅channel(id)</span></span><br><span class="line">_redis.<span class="built_in">subscribe</span>(id);</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 向redis指定的通道subscribe订阅消息</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Redis::subscribe</span><span class="params">(<span class="type">int</span> channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// SUBSCRIBE命令本身会造成线程阻塞等待通道里面发生消息，这里只做订阅通道，不接收通道消息</span></span><br><span class="line">    <span class="comment">// 通道消息的接收专门在observer_channel_message函数中的独立线程中进行</span></span><br><span class="line">    <span class="comment">// 只负责发送命令，不阻塞接收redis server响应消息，否则和notifyMsg线程抢占响应资源</span></span><br><span class="line">    <span class="keyword">if</span> (REDIS_ERR == <span class="built_in">redisAppendCommand</span>(<span class="keyword">this</span>-&gt;_subcribe_context, <span class="string">&quot;SUBSCRIBE %d&quot;</span>, channel))</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;subscribe command failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// redisBufferWrite可以循环发送缓冲区，直到缓冲区数据发送完毕（done被置为1）</span></span><br><span class="line">    <span class="type">int</span> done = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!done)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (REDIS_ERR == <span class="built_in">redisBufferWrite</span>(<span class="keyword">this</span>-&gt;_subcribe_context, &amp;done))</span><br><span class="line">        &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;subscribe command failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// redisGetReply</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当<code>redis</code>收到消息后，会自动去调用注册的回调函数向该通道发送消息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 连接redis服务器</span></span><br><span class="line"><span class="keyword">if</span> (_redis.<span class="built_in">connect</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置上报消息的回调,redis发现某个通道有消息，就会自动向该通道发送消息</span></span><br><span class="line">    _redis.<span class="built_in">init_notify_handler</span>(std::<span class="built_in">bind</span>(&amp;ChatService::handleRedisSubscribeMessage, <span class="keyword">this</span>, _1, _2));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 从redis消息队列中获取订阅的消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::handleRedisSubscribeMessage</span><span class="params">(<span class="type">int</span> userid, string msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMutex)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> it = _userConnMap.<span class="built_in">find</span>(userid);</span><br><span class="line">    <span class="keyword">if</span> (it != _userConnMap.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        it-&gt;second-&gt;<span class="built_in">send</span>(msg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储该用户的离线消息</span></span><br><span class="line">    _offlinemodel.<span class="built_in">insert</span>(userid, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在独立线程中接收订阅通道中的消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Redis::observer_channel_message</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    redisReply *reply = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (REDIS_OK == <span class="built_in">redisGetReply</span>(<span class="keyword">this</span>-&gt;_subcribe_context, (<span class="type">void</span> **)&amp;reply))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 订阅收到的消息是一个带三元素的数组 element[1]为通道号（也就是userid），element[2]是接收到的消息,element[0]是一个标志</span></span><br><span class="line">        <span class="keyword">if</span> (reply != <span class="literal">nullptr</span> &amp;&amp; reply-&gt;element[<span class="number">2</span>] != <span class="literal">nullptr</span> &amp;&amp; reply-&gt;element[<span class="number">2</span>]-&gt;str != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 给业务层上报通道上发生的消息</span></span><br><span class="line">            _notify_message_handler(<span class="built_in">atoi</span>(reply-&gt;element[<span class="number">1</span>]-&gt;str) , reply-&gt;element[<span class="number">2</span>]-&gt;str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; observer_channel_message quit &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Redis::init_notify_handler</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>,string)&gt; fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_notify_message_handler = fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<code>redis</code>的订阅消息之后，该线程会一直阻塞，但是发布消息不会引起线程阻塞，所以在这里，对于发布和订阅，我使用了2个不同的线程</p>
</blockquote>
<p>至此基本的实现思路以及对应的主要代码已经实现，后续我会将全部功能进行测试，然后上传至<a href="https://github.com/shilinlun/ChatServer">Github</a>，希望通过这个项目来增进对后台服务器聊天项目的逻辑与业务有一个基本的认识，同时对项目对应的<code>muduo</code>有了基本认识，后续我会继续做一个<code>muduo</code>的基本源码解读与实现，也会挨着写成博客。</p>
]]></content>
      <categories>
        <category>集群聊天服务器</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>集群聊天服务器五</title>
    <url>/posts/2548392652.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<p>本章主要实现客户端的需求</p>
<span id="more"></span>

<p>客户端主要的流程为：<br>客户端分 2 个线程，一个<code>main</code>线程，一个子线程，主线程主要负责接受用户的数据并传输给服务器以及从服务器接受数据，子线程主要是接受其他人聊天的数据。通过一个<code>switch</code>来接受用户的输入：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示首页面菜单 登录、注册、退出</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;========================&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;1. login&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;2. register&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;3. quit&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;========================&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h1 id="login"><a href="#login" class="headerlink" title="login"></a>login</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> pwd[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;userid:&quot;</span>;</span><br><span class="line">cin &gt;&gt; id;</span><br><span class="line">cin.<span class="built_in">get</span>(); <span class="comment">// 读掉缓冲区残留的回车</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;userpassword:&quot;</span>;</span><br><span class="line">cin.<span class="built_in">getline</span>(pwd, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">json js;</span><br><span class="line">js[<span class="string">&quot;msgid&quot;</span>] = LOGIN_MSG;</span><br><span class="line">js[<span class="string">&quot;id&quot;</span>] = id;</span><br><span class="line">js[<span class="string">&quot;password&quot;</span>] = pwd;</span><br><span class="line">string request = js.<span class="built_in">dump</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">send</span>(clientfd, request.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(request.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>服务器通过接受到的<code>request</code>来判断是否登录成功，若登录成功进入主界面</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进入聊天主菜单页面</span></span><br><span class="line">isMainMenuRunning = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">mainMenu</span>(clientfd);</span><br></pre></td></tr></table></figure>
<p>在进入聊天页面之前，客户端会获取当前用户的好友列表，群组列表，以及是否有离线消息，然后当用户登录时候会自动显示，其代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示当前登录成功用户的基本信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showCurrentUserData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;======================login user======================&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;current login user =&gt; id:&quot;</span> &lt;&lt; g_currentUser.<span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; name:&quot;</span> &lt;&lt; g_currentUser.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------friend list---------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (!g_currentUserFriendList.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (User &amp;user : g_currentUserFriendList)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; user.<span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; user.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; user.<span class="built_in">getState</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------group list----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (!g_currentUserGroupList.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (Group &amp;group : g_currentUserGroupList)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; group.<span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; group.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; group.<span class="built_in">getDesc</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">for</span> (GroupUser &amp;user : group.<span class="built_in">getUsers</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; user.<span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; user.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; user.<span class="built_in">getState</span>()</span><br><span class="line">                     &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; user.<span class="built_in">getRole</span>() &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;======================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后进入聊天主页面程序，其中聊天主页面程序使用一个<code>unordered_map</code>来保存用户输入信息和对应的<code>function</code>,代码如下，当用户输入字符串时候，自动调用对应的函数，实现不同的功能，每个功能的实现在此不再详细说明，基本可以按照前面服务器编写的过程来编写对应的客户端程序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册系统支持的客户端命令处理</span></span><br><span class="line">unordered_map&lt;string, function&lt;<span class="type">void</span>(<span class="type">int</span>, string)&gt;&gt; commandHandlerMap = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;help&quot;</span>, help&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;chat&quot;</span>, chat&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;addfriend&quot;</span>, addfriend&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;creategroup&quot;</span>, creategroup&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;addgroup&quot;</span>, addgroup&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;groupchat&quot;</span>, groupchat&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;loginout&quot;</span>, loginout&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="register"><a href="#register" class="headerlink" title="register"></a>register</h1><p>和登录一样，用户按照规定格式进行输入，然后利用<code>json</code>进行解析</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> pwd[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;username:&quot;</span>;</span><br><span class="line">cin.<span class="built_in">getline</span>(name, <span class="number">50</span>); <span class="comment">// 没有用cin&gt;&gt; 因为这样遇到空格就会终止，比如输入zhang san，就只会得到zhang</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;userpassword:&quot;</span>;</span><br><span class="line">cin.<span class="built_in">getline</span>(pwd, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">json js;</span><br><span class="line">js[<span class="string">&quot;msgid&quot;</span>] = REG_MSG;</span><br><span class="line">js[<span class="string">&quot;name&quot;</span>] = name;</span><br><span class="line">js[<span class="string">&quot;password&quot;</span>] = pwd;</span><br><span class="line">string request = js.<span class="built_in">dump</span>();</span><br></pre></td></tr></table></figure>
<h1 id="子线程"><a href="#子线程" class="headerlink" title="子线程"></a>子线程</h1><p>子线程主要用于接受聊天内容，其主要代码为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readTaskHandler</span><span class="params">(<span class="type">int</span> clientfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">recv</span>(clientfd, buffer, <span class="number">1024</span>, <span class="number">0</span>);  <span class="comment">// 阻塞了</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == len || <span class="number">0</span> == len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(clientfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收ChatServer转发的数据，反序列化生成json数据对象</span></span><br><span class="line">        json js = json::<span class="built_in">parse</span>(buffer);</span><br><span class="line">        <span class="type">int</span> msgtype = js[<span class="string">&quot;msgid&quot;</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        <span class="keyword">if</span> (ONE_CHAT_MSG == msgtype)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; js[<span class="string">&quot;time&quot;</span>].<span class="built_in">get</span>&lt;string&gt;() &lt;&lt; <span class="string">&quot; [&quot;</span> &lt;&lt; js[<span class="string">&quot;id&quot;</span>] &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; js[<span class="string">&quot;name&quot;</span>].<span class="built_in">get</span>&lt;string&gt;()</span><br><span class="line">                 &lt;&lt; <span class="string">&quot; said: &quot;</span> &lt;&lt; js[<span class="string">&quot;msg&quot;</span>].<span class="built_in">get</span>&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (GROUP_CHAT_MSG == msgtype)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;群消息[&quot;</span> &lt;&lt; js[<span class="string">&quot;groupid&quot;</span>] &lt;&lt; <span class="string">&quot;]:&quot;</span> &lt;&lt; js[<span class="string">&quot;time&quot;</span>].<span class="built_in">get</span>&lt;string&gt;() &lt;&lt; <span class="string">&quot; [&quot;</span> &lt;&lt; js[<span class="string">&quot;id&quot;</span>] &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; js[<span class="string">&quot;name&quot;</span>].<span class="built_in">get</span>&lt;string&gt;()</span><br><span class="line">                 &lt;&lt; <span class="string">&quot; said: &quot;</span> &lt;&lt; js[<span class="string">&quot;msg&quot;</span>].<span class="built_in">get</span>&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本项目可以利用不同的消息<code>id</code>来识别不同的聊天信息（一对一还是群组聊天），至此基本的客户端和服务端基本完成搭建，可以直接运行，后面主要利用<code>redis</code>和<code>nginx</code>来扩充该项目</p>
]]></content>
      <categories>
        <category>集群聊天服务器</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>集群聊天服务器四</title>
    <url>/posts/2315714697.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<p>本章我们实现群组创建、添加群组、群组聊天等功能，首先我们先看下和群组相关的表结构</p>
<span id="more"></span>

<p><strong>allgroup表</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88f7631a50814de3aebf6ae470267157~tplv-k3u1fbpfcp-zoom-1.image"><br><strong>groupuser表</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6da8ef3eb5d8490e8e1cbccac1812f20~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h1 id="群组创建"><a href="#群组创建" class="headerlink" title="群组创建"></a>群组创建</h1><p>首先代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建群组</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GroupModel::createGroup</span><span class="params">(Group &amp;group)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 组装sql语句</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(sql, <span class="string">&quot;insert into allgroup(groupname,groupdesc) values(&#x27;%s&#x27;,&#x27;%s&#x27;)&quot;</span>, group.<span class="built_in">getName</span>().<span class="built_in">c_str</span>(), group.<span class="built_in">getDesc</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span> (mysql.<span class="built_in">connect</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mysql.<span class="built_in">update</span>(sql))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 主键id是自增的</span></span><br><span class="line">            group.<span class="built_in">setId</span>(<span class="built_in">mysql_insert_id</span>(mysql.<span class="built_in">getConnection</span>()));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供一个<code>Group</code>对象，然后通过对象进行创建群组，根据<code>Group</code>表的设计，<code>Group</code>对象的结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Group</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Group</span>(<span class="type">int</span> id = <span class="number">-1</span>, string name = <span class="string">&quot;&quot;</span>, string desc = <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setId</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123; <span class="keyword">this</span>-&gt;id = id; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123; <span class="keyword">this</span>-&gt;name = name; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDesc</span><span class="params">(string desc)</span> </span>&#123; <span class="keyword">this</span>-&gt;desc = desc; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;id; &#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name; &#125;</span><br><span class="line">    <span class="function">string <span class="title">getDesc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;desc; &#125;</span><br><span class="line">    <span class="function">vector&lt;GroupUser&gt; &amp;<span class="title">getUsers</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;users; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string name;</span><br><span class="line">    string desc;</span><br><span class="line">    <span class="comment">// 存储这个组里面的成员</span></span><br><span class="line">    vector&lt;GroupUser&gt; users;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="加入群组"><a href="#加入群组" class="headerlink" title="加入群组"></a>加入群组</h1><blockquote>
<p>注意加入群组需要设置用户的角色</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GroupModel::addGroup</span><span class="params">(<span class="type">int</span> userid, <span class="type">int</span> groupid, string role)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 组装sql语句</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(sql, <span class="string">&quot;insert into groupuser values(&#x27;%d&#x27;,&#x27;%d&#x27;,&#x27;%s&#x27;)&quot;</span>, groupid, userid, role.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span> (mysql.<span class="built_in">connect</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        mysql.<span class="built_in">update</span>(sql);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>string role</code>就是表明以什么身份加入群组（<code>creator</code> <code>normal</code>）</p>
<h1 id="群组查询"><a href="#群组查询" class="headerlink" title="群组查询"></a>群组查询</h1><p>根据用户<code>id</code>来查询所在群组，同时查询每个群组都有哪些成员。注意一个用户可能存在多个群组内</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询用户所在群组信息,因为一个用户可能存在于多个群组中,这里输出的是，一个用户的哪些群组，同时每个群组有哪些成员</span></span><br><span class="line"><span class="function">vector&lt;Group&gt; <span class="title">GroupModel::queryGroups</span><span class="params">(<span class="type">int</span> userid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.先根据userid在groupuser表中查询出该用户所属的群组信息</span></span><br><span class="line"><span class="comment">    2.再根据群组信息，查询属于该群组的所有userid，并且和user表进行多表查询，查出用户的详细信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(sql, <span class="string">&quot;select a.id,a.groupname,a.groupdesc from allgroup a inner join groupuser b on a.id = b.groupid where b.userid = %d&quot;</span>, userid);</span><br><span class="line">    vector&lt;Group&gt; groupVec;</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span> (mysql.<span class="built_in">connect</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        MYSQL_RES *res = mysql.<span class="built_in">query</span>(sql);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            MYSQL_ROW row;</span><br><span class="line">            <span class="comment">// 查询userid所有的群组信息</span></span><br><span class="line">            <span class="keyword">while</span> ((row = <span class="built_in">mysql_fetch_row</span>(res)) != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Group group;</span><br><span class="line">                <span class="comment">// select a.id,a.groupname,a.groupdesc 第一个是id，第二个是groupname，第三个是groupdesc</span></span><br><span class="line">                group.<span class="built_in">setId</span>(<span class="built_in">atoi</span>(row[<span class="number">0</span>]));</span><br><span class="line">                group.<span class="built_in">setName</span>(row[<span class="number">1</span>]);</span><br><span class="line">                group.<span class="built_in">setDesc</span>(row[<span class="number">2</span>]);</span><br><span class="line">                groupVec.<span class="built_in">emplace_back</span>(group);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询群组的用户信息</span></span><br><span class="line">    <span class="keyword">for</span> (Group &amp;group : groupVec)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(sql, <span class="string">&quot;select a.id,a.name,a.state,b.grouprole from user a inner join groupuser b on b.userid = a.id where b.groupid = %d&quot;</span>, group.<span class="built_in">getId</span>());</span><br><span class="line">        MYSQL_RES *res = mysql.<span class="built_in">query</span>(sql);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            MYSQL_ROW row;</span><br><span class="line">            <span class="keyword">while</span> ((row = <span class="built_in">mysql_fetch_row</span>(res)) != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                GroupUser user;</span><br><span class="line">                user.<span class="built_in">setId</span>(<span class="built_in">atoi</span>(row[<span class="number">0</span>]));</span><br><span class="line">                user.<span class="built_in">setName</span>(row[<span class="number">1</span>]);</span><br><span class="line">                user.<span class="built_in">setState</span>(row[<span class="number">2</span>]);</span><br><span class="line">                user.<span class="built_in">setRole</span>(row[<span class="number">3</span>]);</span><br><span class="line">                group.<span class="built_in">getUsers</span>().<span class="built_in">emplace_back</span>(user);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> groupVec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="群组聊天"><a href="#群组聊天" class="headerlink" title="群组聊天"></a>群组聊天</h1><p>格式为：<code>userid</code>-&gt;<code>groupid</code>，因此需要根据<code>groupid</code>查询群组里面有哪些成员，然后向这些成员（除了自己）发送消息，同时注意群成员是否在线，若不在线，将消息存放到离线消息表中，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 群组聊天业务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::groupChat</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> userid = js[<span class="string">&quot;id&quot;</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="type">int</span> groupid = js[<span class="string">&quot;groupid&quot;</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; useridVec = _groupmodel.<span class="built_in">queryGroupUsers</span>(userid, groupid);</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> id : useridVec)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it = _userConnMap.<span class="built_in">find</span>(id);</span><br><span class="line">        <span class="keyword">if</span> (it != _userConnMap.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 转发消息</span></span><br><span class="line">            it-&gt;second-&gt;<span class="built_in">send</span>(js.<span class="built_in">dump</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 存储离线群消息</span></span><br><span class="line">            _offlinemodel.<span class="built_in">insert</span>(id, js.<span class="built_in">dump</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据指定的groupid查询群组用户id列表，除了userid本省，主要用与群聊服务</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">GroupModel::queryGroupUsers</span><span class="params">(<span class="type">int</span> userid, <span class="type">int</span> groupid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(sql, <span class="string">&quot;select userid from groupuser where groupid = %d and userid = %d&quot;</span>, groupid, userid);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; idVec;</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span> (mysql.<span class="built_in">connect</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        MYSQL_RES *res = mysql.<span class="built_in">query</span>(sql);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            MYSQL_ROW row;</span><br><span class="line">            <span class="keyword">while</span> ((row = <span class="built_in">mysql_fetch_row</span>(res)) != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                idVec.<span class="built_in">emplace_back</span>(<span class="built_in">atoi</span>(row[<span class="number">0</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idVec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此我们就完成了服务器的开发，下一节我们开始开发客户端。</p>
]]></content>
      <categories>
        <category>集群聊天服务器</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>集群聊天服务器三</title>
    <url>/posts/3335875735.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<p>本篇文章主要实现了聊天服务器中一对一聊天和添加好友功能</p>
<span id="more"></span>

<h1 id="一对一聊天"><a href="#一对一聊天" class="headerlink" title="一对一聊天"></a>一对一聊天</h1><p>以下是聊天对应的<code>json</code>字符串格式</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;msgid&quot;</span><span class="punctuation">:</span><span class="number">5</span><span class="punctuation">,</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span><span class="string">&quot;lisi&quot;</span><span class="punctuation">,</span><span class="attr">&quot;to&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span><span class="string">&quot;hello4&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>同样在<code>ChatService</code>中添加如下函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一对一聊天业务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oneChat</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：锁的处理</p>
</blockquote>
<p>在一对一聊天中，我们需要服务器知道哪些用户是在线的，哪些用户是离线的，对于在线用户，我们直接将聊天信息转发，对于离线好友，我们需要将信息先存储在离线信息表中，然后等对方在线后，再进行发送。所以我们采用一个<code>map</code>来保存<code>userid</code>和<code>conn</code>的对应关系</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储在线用户的连接，因为比如用户1向用户2发送请求，这时候需要服务器来做中间转化</span></span><br><span class="line"><span class="comment">// 所以服务器需要知道用户2是否在线</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, TcpConnectionPtr&gt; _userConnMap;</span><br></pre></td></tr></table></figure>
<p>这样在用户登陆的时候，若登陆成功，需要给当前用户的<code>userid</code>添加一个<code>conn</code>的<code>map</code>键值对，同时利用锁进行处理，防止出现意外。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在这里加&#123;&#125;主要就是设置作用域，lock_guard&lt;mutex&gt; lock(_connMutex)中lock_guard会在构造函数加锁，</span></span><br><span class="line"><span class="comment">// 析构函数释放锁，同时由于只需要insert需要锁，所以加一个作用域，这样避免给不必要的地方加锁，浪费资源</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMutex)</span></span>;</span><br><span class="line">    <span class="comment">// 记录用户连接信息</span></span><br><span class="line">    _userConnMap.<span class="built_in">insert</span>(&#123;id, conn&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//登陆成功，然后更新用户登陆信息</span></span><br><span class="line">user.<span class="built_in">setState</span>(<span class="string">&quot;online&quot;</span>);</span><br><span class="line">_usermodel.<span class="built_in">updateState</span>(user);</span><br><span class="line">json response;</span><br><span class="line">response[<span class="string">&quot;msgid&quot;</span>] = LOGIN_MSG_ACK;</span><br><span class="line">response[<span class="string">&quot;error&quot;</span>] = <span class="number">0</span>; <span class="comment">//0表示成功</span></span><br><span class="line">response[<span class="string">&quot;id&quot;</span>] = user.<span class="built_in">getId</span>();</span><br><span class="line">response[<span class="string">&quot;name&quot;</span>] = user.<span class="built_in">getName</span>();</span><br></pre></td></tr></table></figure>
<p>这样采用如下代码实现消息的转发或者消息的存储</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一对一聊天业务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::oneChat</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对方id</span></span><br><span class="line">    <span class="type">int</span> toid = js[<span class="string">&quot;to&quot;</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMutex)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> it = _userConnMap.<span class="built_in">find</span>(toid);</span><br><span class="line">        <span class="keyword">if</span> (it != _userConnMap.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// toid在线，转发消息</span></span><br><span class="line">            it-&gt;second-&gt;<span class="built_in">send</span>(js.<span class="built_in">dump</span>());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不在线，存储离线消息</span></span><br><span class="line">    _offlinemodel.<span class="built_in">insert</span>(toid, js.<span class="built_in">dump</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于离线好友，我们需要在他登陆的时候，首先去查询<code>_offlinemodel</code>这个<code>map</code>中是否有自己对应的离线消息，若有，要先让服务器推送消息给用户，然后从<code>map</code>中删除对应的消息</p>
<blockquote>
<p>注意，我在这里暂时打算让服务器用一个<code>vector&lt;string&gt;</code>存储离线消息</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询该用户是否有离线信息</span></span><br><span class="line">vector&lt;string&gt; vec = _offlinemodel.<span class="built_in">query</span>(id);</span><br><span class="line"><span class="keyword">if</span> (!vec.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    response[<span class="string">&quot;offlinemsg&quot;</span>] = vec;</span><br><span class="line">    <span class="comment">// 再删除离线消息</span></span><br><span class="line">    _offlinemodel.<span class="built_in">remove</span>(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="添加好友"><a href="#添加好友" class="headerlink" title="添加好友"></a>添加好友</h1><p>以下是添加好友的json字符串</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;msgid&quot;</span><span class="punctuation">:</span><span class="number">6</span><span class="punctuation">,</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;friendid&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>同样在<code>ChatService</code>中添加如下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加好友请求 msgid id friendid</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::addFriend</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> userid = js[<span class="string">&quot;id&quot;</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="type">int</span> friendid = js[<span class="string">&quot;friendid&quot;</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储好友信息</span></span><br><span class="line">    _friendmodel.<span class="built_in">insert</span>(userid, friendid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先需要在用户登陆的时候，服务器自动推送给用户其对应的好友，所以需要一个<code>vector&lt;User&gt;</code>来存储该用户对应的好友列表，同时将这个<code>vector</code>和<code>userid</code>在数据库中保存，表结构如下</br></p>
<table>
<thead>
<tr>
<th align="center">字段名称</th>
<th align="center">字段类型</th>
<th align="center">字段说明</th>
<th align="center">约束</th>
</tr>
</thead>
<tbody><tr>
<td align="center">userid</td>
<td align="center">INT</td>
<td align="center">用户id</td>
<td align="center">NOT NULL、联合主键</td>
</tr>
<tr>
<td align="center">friendid</td>
<td align="center">INT</td>
<td align="center">好友id</td>
<td align="center">NOT NULL、联合主键</td>
</tr>
</tbody></table>
<p>在用户登录成功之后，服务器会去查询用户的好友列表，然后推送给用户，其代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询该用户的好友信息 并返回</span></span><br><span class="line">vector&lt;User&gt; uservec = _friendmodel.<span class="built_in">query</span>(id);</span><br><span class="line"><span class="keyword">if</span> (!uservec.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;string&gt; vec2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : uservec)</span><br><span class="line">    &#123;</span><br><span class="line">        json js;</span><br><span class="line">        js[<span class="string">&quot;id&quot;</span>] = i.<span class="built_in">getId</span>();</span><br><span class="line">        js[<span class="string">&quot;name&quot;</span>] = i.<span class="built_in">getName</span>();</span><br><span class="line">        js[<span class="string">&quot;state&quot;</span>] = i.<span class="built_in">getState</span>();</span><br><span class="line">        vec2.<span class="built_in">emplace_back</span>(js.<span class="built_in">dump</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    response[<span class="string">&quot;friends&quot;</span>] = vec2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>_friendmodel.query()</code>使用的是多表联合查询，<code>sql</code>语句为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.id,a.name,a.state <span class="keyword">from</span> <span class="keyword">user</span> a <span class="keyword">inner</span> <span class="keyword">join</span> friend b <span class="keyword">on</span> b.friendid <span class="operator">=</span> a.id <span class="keyword">where</span> b.userid <span class="operator">=</span> <span class="operator">%</span>d</span><br></pre></td></tr></table></figure>
<p>下一章我们实现下群组的创建与群组之间的聊天业务。</p>
]]></content>
      <categories>
        <category>集群聊天服务器</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>集群聊天服务器二</title>
    <url>/posts/2223635098.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<p>本次主要是对<code>Chatserver</code>和<code>Chatservice</code>进行代码实现</p>
<span id="more"></span>

<h1 id="ChatServer"><a href="#ChatServer" class="headerlink" title="ChatServer"></a><code>ChatServer</code></h1><p>首先我们利用<code>muduo</code>库建立一个<code>ChatServer</code>类，<code>muduo</code>库的讲解我会在后面再写一个项目来深入分析</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChatServer</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ChatServer</span>(EventLoop *loop,</span><br><span class="line">               <span class="type">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">               <span class="type">const</span> string &amp;nameArg);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TcpServer _server;</span><br><span class="line">    EventLoop *_loop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调连接相关的事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line">    <span class="comment">// 回调读写事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, Buffer *buffer, Timestamp time)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中主要的代码注释已经写出来了，注意由于<code>muduo</code>库已经帮我们实现了套接字的连接，我们只需要自己定义回调函数，即可让客户端连接时候以及客户端发送请求的时候进行自我回调。</br></p>
<blockquote>
<p>注意为什么要在<code>ChatServer</code>类中实现上述代码的构造函数</br></p>
</blockquote>
<p>我们去<code>muduo</code>中的<code>TcpServer</code>源码可知，<code>TcpServer</code>没有空的构造函数，所以我们必须要用初始化列表对<code>TcpServer</code>进行初始化。下面是<code>TcpServer</code>源码的构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TcpServer(EventLoop* loop, const InetAddress&amp; listenAddr);</span></span><br><span class="line"><span class="built_in">TcpServer</span>(EventLoop* loop,</span><br><span class="line">          <span class="type">const</span> InetAddress&amp; listenAddr,</span><br><span class="line">          <span class="type">const</span> string&amp; nameArg,</span><br><span class="line">          Option option = kNoReusePort);</span><br><span class="line">~<span class="built_in">TcpServer</span>();  <span class="comment">// force out-line dtor, for std::unique_ptr members.</span></span><br></pre></td></tr></table></figure>
<p>以下代码是<code>ChatServer</code>对应的实现细节</br></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ChatServer::<span class="built_in">ChatServer</span>(EventLoop *loop,</span><br><span class="line">                       <span class="type">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                       <span class="type">const</span> string &amp;nameArg)</span><br><span class="line">    : _server(loop, listenAddr, nameArg), _loop(loop)</span><br><span class="line">&#123;</span><br><span class="line">    _server.<span class="built_in">setConnectionCallback</span>(<span class="built_in">bind</span>(&amp;ChatServer::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line"></span><br><span class="line">    _server.<span class="built_in">setMessageCallback</span>(<span class="built_in">bind</span>(&amp;ChatServer::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line"></span><br><span class="line">    _server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatServer::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _server.<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatServer::onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 用户断开连接</span></span><br><span class="line">    <span class="keyword">if</span> (!conn-&gt;<span class="built_in">connected</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatServer::onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, Buffer *buffer, Timestamp time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string buf = buffer-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line">    json js = json::<span class="built_in">parse</span>(buf);</span><br><span class="line">    <span class="comment">// 通过js中的id来获取一个handler，这样把网络模块和业务模块分开</span></span><br><span class="line">    <span class="comment">// 转换成int类型</span></span><br><span class="line">    <span class="keyword">auto</span> handler = ChatService::<span class="built_in">instance</span>()-&gt;<span class="built_in">getHandler</span>(js[<span class="string">&quot;msgid&quot;</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="comment">// handler在执行的时候才知道是login还是reg</span></span><br><span class="line">    <span class="built_in">handler</span>(conn, js, time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在<code>onMessage</code>方法中，我们为了把网络模块和业务模块分开，采用的是回调机制，将<code>msgid</code>和消息对应的处理函数绑定起来，然后当一个消息接受到之后，利用<code>json</code>库对<code>msgid</code>进行解析，从而自动回调对应的处理函数。</p>
<h1 id="ChatService"><a href="#ChatService" class="headerlink" title="ChatService"></a>ChatService</h1><p>该类主要就是针对<code>msgid</code>和对应的<code>handler</code>进行绑定。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChatService</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> ChatService *<span class="title">instance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理登录业务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">login</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp)</span></span>;</span><br><span class="line">    <span class="comment">// 处理注册业务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reg</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息对应的处理器</span></span><br><span class="line">    <span class="function">MsgHandler <span class="title">getHandler</span><span class="params">(<span class="type">int</span> msgid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ChatService</span>();</span><br><span class="line">    <span class="comment">// 存储消息id和业务处理的方法</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, MsgHandler&gt; _msgHandlerMap;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了进行绑定操作，我们在<code>ChatService</code>构造函数直接将<code>msgid</code>和对应<code>handler</code>进行绑定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册消息以及对应的回调操作</span></span><br><span class="line">ChatService::<span class="built_in">ChatService</span>()</span><br><span class="line">&#123;</span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>(&#123;LOGIN_MSG, std::<span class="built_in">bind</span>(&amp;ChatService::login, <span class="keyword">this</span>, _1, _2, _3)&#125;);</span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>(&#123;REG_MSG, std::<span class="built_in">bind</span>(&amp;ChatService::reg, <span class="keyword">this</span>, _1, _2, _3)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>std::bind</code>的语法大家可以自行百度，其实可以理解为一种函数指针，将<code>LOGIN_MSG</code>和<code>ChatService::login</code>绑定起来，当收到<code>LOGIN_MSG</code>，自动去调用<code>ChatService::login</code>方法。然后我们主要是实现登陆和注册两个函数的具体代码。</p>
<h1 id="数据库建立"><a href="#数据库建立" class="headerlink" title="数据库建立"></a>数据库建立</h1><p>为了实现登陆和注册功能，我们需要自行建立对应的数据库，我们这里使用的<code>MySQL</code>数据库。对应的<code>user</code>表如下：</p>
<table>
<thead>
<tr>
<th align="center">字段名称</th>
<th align="center">字段类型</th>
<th align="center">字段说明</th>
<th align="center">约束</th>
</tr>
</thead>
<tbody><tr>
<td align="center">id</td>
<td align="center">INT</td>
<td align="center">用户id</td>
<td align="center">PRIMARY KEY、AUTO_INCREMENT</td>
</tr>
<tr>
<td align="center">name</td>
<td align="center">VARCHAR(50)</td>
<td align="center">用户名</td>
<td align="center">NOT NULL, UNIQUE</td>
</tr>
<tr>
<td align="center">password</td>
<td align="center">VARCHAR(50)</td>
<td align="center">用户密码</td>
<td align="center">NOT NULL</td>
</tr>
<tr>
<td align="center">state</td>
<td align="center">ENUM(‘online’, ‘offline’)</td>
<td align="center">当前登录状态</td>
<td align="center">DEFAULT ‘offline’</td>
</tr>
<tr>
<td align="center">然后对登陆和注册函数进行实现</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理登录业务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::login</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> id = js[<span class="string">&quot;id&quot;</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    string password = js[<span class="string">&quot;password&quot;</span>];</span><br><span class="line">    User user = _usermodel.<span class="built_in">query</span>(id);</span><br><span class="line">    <span class="keyword">if</span> (user.<span class="built_in">getId</span>() == id &amp;&amp; user.<span class="built_in">getPwd</span>() == password)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (user.<span class="built_in">getState</span>() == <span class="string">&quot;online&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 用户已经登陆，不允许重复登陆</span></span><br><span class="line">            json response;</span><br><span class="line">            response[<span class="string">&quot;msgid&quot;</span>] = LOGIN_MSG_ACK;</span><br><span class="line">            response[<span class="string">&quot;error&quot;</span>] = <span class="number">2</span>; <span class="comment">// 2表示已经登陆</span></span><br><span class="line">            response[<span class="string">&quot;errormsg&quot;</span>] = <span class="string">&quot;已经登陆，不允许重复登陆&quot;</span>;</span><br><span class="line">            conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//登陆成功，然后更新用户登陆信息</span></span><br><span class="line">            user.<span class="built_in">setState</span>(<span class="string">&quot;online&quot;</span>);</span><br><span class="line">            _usermodel.<span class="built_in">updateState</span>(user);</span><br><span class="line">            json response;</span><br><span class="line">            response[<span class="string">&quot;msgid&quot;</span>] = LOGIN_MSG_ACK;</span><br><span class="line">            response[<span class="string">&quot;error&quot;</span>] = <span class="number">0</span>; <span class="comment">//0表示成功</span></span><br><span class="line">            response[<span class="string">&quot;id&quot;</span>] = user.<span class="built_in">getId</span>();</span><br><span class="line">            response[<span class="string">&quot;name&quot;</span>] = user.<span class="built_in">getName</span>();</span><br><span class="line">            conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 该用户不存在</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">&quot;msgid&quot;</span>] = LOGIN_MSG_ACK;</span><br><span class="line">        response[<span class="string">&quot;error&quot;</span>] = <span class="number">1</span>; <span class="comment">//1表示不存在</span></span><br><span class="line">        response[<span class="string">&quot;errormsg&quot;</span>] = <span class="string">&quot;用户名或密码不存在&quot;</span>;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理注册业务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::reg</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string name = js[<span class="string">&quot;name&quot;</span>];</span><br><span class="line">    string password = js[<span class="string">&quot;password&quot;</span>];</span><br><span class="line"></span><br><span class="line">    User user;</span><br><span class="line">    user.<span class="built_in">setName</span>(name);</span><br><span class="line">    user.<span class="built_in">setPwd</span>(password);</span><br><span class="line">    <span class="type">bool</span> ans = _usermodel.<span class="built_in">insert</span>(user);</span><br><span class="line">    <span class="keyword">if</span> (ans)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注册成功</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">&quot;msgid&quot;</span>] = REG_MSG_ACK;</span><br><span class="line">        response[<span class="string">&quot;error&quot;</span>] = <span class="number">0</span>; <span class="comment">//0表示成功</span></span><br><span class="line">        response[<span class="string">&quot;id&quot;</span>] = user.<span class="built_in">getId</span>();</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注册失败</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">&quot;msgid&quot;</span>] = REG_MSG_ACK;</span><br><span class="line">        response[<span class="string">&quot;error&quot;</span>] = <span class="number">1</span>; <span class="comment">//1表示失败</span></span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意我们同样在这里使用低耦合思想，把业务和数据库模块分开，注意<code>_usermodel.query(id)</code>这一句，其实<code>query</code>就是其中数据库的操作模块，里面才是具体的数据库语句。</p>
<p>这样建立了<code>ChatServer</code>后，就可以在<code>main</code>函数中直接启动</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">EventLoop loop;</span><br><span class="line"><span class="function">InetAddress <span class="title">addr</span><span class="params">(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6000</span>)</span></span>;</span><br><span class="line"><span class="function">ChatServer <span class="title">server</span><span class="params">(&amp;loop, addr, <span class="string">&quot;ChatServer&quot;</span>)</span></span>;</span><br><span class="line">server.<span class="built_in">start</span>();</span><br><span class="line">loop.<span class="built_in">loop</span>();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>集群聊天服务器</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>集群聊天服务器一</title>
    <url>/posts/3205092403.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<p>本系列主要是利用C++开发一个集群聊天服务器项目，同时代码也会同步更新到<a href="https://github.com/shilinlun/ChatServer">github</a>上面<br>本项目目标为如下几点:</p>
<span id="more"></span>

<ol>
<li>集群聊天服务器设计，软件分层设计思路</li>
<li>用muduo网络库实现高性能的聊天服务器</li>
<li>用cmake构建项目集成编译环境</li>
<li>集群环境负载均衡器介绍以及nginx的tcp负载均衡配置以及应用</li>
<li>基于发布-订阅（观察者模式）的服务器中间件消息队列redis解决集群环境中跨服务器聊天通信</li>
<li>mysql数据库编程以及如何根据项目需求合理设计表结构</li>
</ol>
]]></content>
      <categories>
        <category>集群聊天服务器</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title>redis持久化</title>
    <url>/posts/3707414788.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<p>本次主要是对redis中著名的持久化策略进行代码层面描述，主要包括RDB持久化和AOF持久化</p>
<span id="more"></span>

<p>因为AOF文件的更新频率比RDB高，所以如果服务器开启AOF持久化，redis优先使用AOF文件还原，只有当AOF持久化关闭，才使用RDB文件进行还原</p>
<h1 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h1><p>RDB持久化主要有两个命令实现：<code>SAVE</code>和<code>BGSAVE</code></p>
<h2 id="SAVE、BGSAVE"><a href="#SAVE、BGSAVE" class="headerlink" title="SAVE、BGSAVE"></a><code>SAVE</code>、<code>BGSAVE</code></h2><ul>
<li><code>SAVE</code>会阻塞redis服务器，知道RDB文件创建完毕</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">saveCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BGSAVE 已经在执行中，不能再执行 SAVE</span></span><br><span class="line">    <span class="comment">// 否则将产生竞争条件</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">addReplyError</span>(c,<span class="string">&quot;Background save already in progress&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行 </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">rdbSave</span>(server.rdb_filename) == REDIS_OK) &#123;</span><br><span class="line">        <span class="built_in">addReply</span>(c,shared.ok);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">addReply</span>(c,shared.err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>BGSAVE</code>不会阻塞，他会创建一个子进程，由子进程处理RDB文件保存</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bgsaveCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不能重复执行 BGSAVE</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">addReplyError</span>(c,<span class="string">&quot;Background save already in progress&quot;</span>);</span><br><span class="line">    <span class="comment">// 不能在 BGREWRITEAOF 正在运行时执行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">addReplyError</span>(c,<span class="string">&quot;Can&#x27;t BGSAVE while AOF log rewriting is in progress&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行 BGSAVE</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">rdbSaveBackground</span>(server.rdb_filename) == REDIS_OK) &#123;</span><br><span class="line">        <span class="built_in">addReplyStatus</span>(c,<span class="string">&quot;Background saving started&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">addReply</span>(c,shared.err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rdbSaveBackground</span><span class="params">(<span class="type">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> childpid;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> start;</span><br><span class="line">    <span class="comment">// 如果 BGSAVE 已经在执行，那么出错</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    <span class="comment">// 记录 BGSAVE 执行前的数据库被修改次数</span></span><br><span class="line">    server.dirty_before_bgsave = server.dirty;</span><br><span class="line">    <span class="comment">// 最近一次尝试执行 BGSAVE 的时间</span></span><br><span class="line">    server.lastbgsave_try = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// fork() 开始前的时间，记录 fork() 返回耗时用</span></span><br><span class="line">    start = <span class="built_in">ustime</span>();</span><br><span class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> retval;</span><br><span class="line">        <span class="comment">/* 子进程 */</span></span><br><span class="line">        <span class="comment">// 关闭网络连接 fd</span></span><br><span class="line">        <span class="built_in">closeListeningSockets</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置进程的标题，方便识别</span></span><br><span class="line">        <span class="built_in">redisSetProcTitle</span>(<span class="string">&quot;redis-rdb-bgsave&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行保存操作</span></span><br><span class="line">        retval = <span class="built_in">rdbSave</span>(filename);</span><br><span class="line">        <span class="comment">// 打印 copy-on-write 时使用的内存数</span></span><br><span class="line">        <span class="keyword">if</span> (retval == REDIS_OK) &#123;</span><br><span class="line">            <span class="type">size_t</span> private_dirty = <span class="built_in">zmalloc_get_private_dirty</span>();</span><br><span class="line">            <span class="keyword">if</span> (private_dirty) &#123;</span><br><span class="line">                <span class="built_in">redisLog</span>(REDIS_NOTICE,</span><br><span class="line">                    <span class="string">&quot;RDB: %zu MB of memory used by copy-on-write&quot;</span>,</span><br><span class="line">                    private_dirty/(<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向父进程发送信号</span></span><br><span class="line">        <span class="built_in">exitFromChild</span>((retval == REDIS_OK) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 父进程 */</span></span><br><span class="line">        <span class="comment">// 计算 fork() 执行的时间</span></span><br><span class="line">        server.stat_fork_time = <span class="built_in">ustime</span>()-start;</span><br><span class="line">        <span class="comment">// 如果 fork() 出错，那么报告错误</span></span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            server.lastbgsave_status = REDIS_ERR;</span><br><span class="line">            <span class="built_in">redisLog</span>(REDIS_WARNING,<span class="string">&quot;Can&#x27;t save in background: fork: %s&quot;</span>,</span><br><span class="line">                <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印 BGSAVE 开始的日志</span></span><br><span class="line">        <span class="built_in">redisLog</span>(REDIS_NOTICE,<span class="string">&quot;Background saving started by pid %d&quot;</span>,childpid);</span><br><span class="line">        <span class="comment">// 记录数据库开始 BGSAVE 的时间</span></span><br><span class="line">        server.rdb_save_time_start = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 记录负责执行 BGSAVE 的子进程 ID</span></span><br><span class="line">        server.rdb_child_pid = childpid;</span><br><span class="line">        <span class="comment">// 关闭自动 rehash</span></span><br><span class="line">        <span class="built_in">updateDictResizePolicy</span>();</span><br><span class="line">        <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK; <span class="comment">/* unreached */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个命令内部都是执行<code>rdbSave</code>函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 将数据库保存到磁盘上。</span></span><br><span class="line"><span class="comment"> * 保存成功返回 REDIS_OK ，出错/失败返回 REDIS_ERR 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rdbSave</span><span class="params">(<span class="type">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    dictIterator *di = <span class="literal">NULL</span>;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="type">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line">    <span class="type">char</span> magic[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> now = <span class="built_in">mstime</span>();</span><br><span class="line">    FILE *fp;</span><br><span class="line">    rio rdb;</span><br><span class="line">    <span class="type">uint64_t</span> cksum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建临时文件</span></span><br><span class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-%d.rdb&quot;</span>, (<span class="type">int</span>) <span class="built_in">getpid</span>());</span><br><span class="line">    fp = <span class="built_in">fopen</span>(tmpfile,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">        <span class="built_in">redisLog</span>(REDIS_WARNING, <span class="string">&quot;Failed opening .rdb for saving: %s&quot;</span>,</span><br><span class="line">            <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 I/O</span></span><br><span class="line">    <span class="built_in">rioInitWithFile</span>(&amp;rdb,fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置校验和函数</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_checksum)</span><br><span class="line">        rdb.update_cksum = rioGenericUpdateChecksum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入 RDB 版本号</span></span><br><span class="line">    <span class="built_in">snprintf</span>(magic,<span class="built_in">sizeof</span>(magic),<span class="string">&quot;REDIS%04d&quot;</span>,REDIS_RDB_VERSION);</span><br><span class="line">    <span class="comment">// 写入错误，跳转到werr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">rdbWriteRaw</span>(&amp;rdb,magic,<span class="number">9</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有数据库</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指向数据库</span></span><br><span class="line">        redisDb *db = server.db+j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指向数据库键空间</span></span><br><span class="line">        dict *d = db-&gt;dict;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过空数据库</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dictSize</span>(d) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建键空间迭代器</span></span><br><span class="line">        di = <span class="built_in">dictGetSafeIterator</span>(d);</span><br><span class="line">        <span class="keyword">if</span> (!di) &#123;</span><br><span class="line">            <span class="built_in">fclose</span>(fp);</span><br><span class="line">            <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * 写入 DB 选择器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">rdbSaveType</span>(&amp;rdb,REDIS_RDB_OPCODE_SELECTDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">rdbSaveLen</span>(&amp;rdb,j) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 遍历数据库，并写入每个键值对的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span>((de = <span class="built_in">dictNext</span>(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sds keystr = <span class="built_in">dictGetKey</span>(de);</span><br><span class="line">            robj key, *o = <span class="built_in">dictGetVal</span>(de);</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> expire;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据 keystr ，在栈中创建一个 key 对象</span></span><br><span class="line">            <span class="built_in">initStaticStringObject</span>(key,keystr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取键的过期时间</span></span><br><span class="line">            expire = <span class="built_in">getExpire</span>(db,&amp;key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存键值对数据</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">rdbSaveKeyValuePair</span>(&amp;rdb,&amp;key,o,expire,now) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dictReleaseIterator</span>(di);</span><br><span class="line">    &#125;</span><br><span class="line">    di = <span class="literal">NULL</span>; <span class="comment">/* So that we don&#x27;t release it again on error. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 写入 EOF 代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">rdbSaveType</span>(&amp;rdb,REDIS_RDB_OPCODE_EOF) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * CRC64 校验和。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果校验和功能已关闭，那么 rdb.cksum 将为 0 ，</span></span><br><span class="line"><span class="comment">     * 在这种情况下， RDB 载入时会跳过校验和检查。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cksum = rdb.cksum;</span><br><span class="line">    <span class="built_in">memrev64ifbe</span>(&amp;cksum);</span><br><span class="line">    <span class="built_in">rioWrite</span>(&amp;rdb,&amp;cksum,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 冲洗缓存，确保数据已写入磁盘</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fflush</span>(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fsync</span>(<span class="built_in">fileno</span>(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fclose</span>(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 使用 RENAME ，原子性地对临时文件进行改名，覆盖原来的 RDB 文件。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">rename</span>(tmpfile,filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">redisLog</span>(REDIS_WARNING,<span class="string">&quot;Error moving temp DB file on the final destination: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">unlink</span>(tmpfile);</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入完成，打印日志</span></span><br><span class="line">    <span class="built_in">redisLog</span>(REDIS_NOTICE,<span class="string">&quot;DB saved on disk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清零数据库脏状态</span></span><br><span class="line">    server.dirty = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录最后一次完成 SAVE 的时间</span></span><br><span class="line">    server.lastsave = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录最后一次执行 SAVE 的状态</span></span><br><span class="line">    server.lastbgsave_status = REDIS_OK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="comment">// 删除文件</span></span><br><span class="line">    <span class="built_in">unlink</span>(tmpfile);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">redisLog</span>(REDIS_WARNING,<span class="string">&quot;Write error saving DB on disk: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (di) <span class="built_in">dictReleaseIterator</span>(di);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RDB文件内容"><a href="#RDB文件内容" class="headerlink" title="RDB文件内容"></a>RDB文件内容</h2><p>首先给出一个完整的RDB文件的格式</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220416095614501.png" alt="image-20220416095614501"></p>
<p><strong>后续为描述方便，大写为常量，小写为变量或者数据</strong></p>
<ul>
<li><code>REDIS</code> 这个其实就是RDB文件的标识符</li>
<li><code>db_version</code>长度4字节，记录RDB文件的版本号，redis3.0一般使用0006（第六版）</li>
<li><code>databases</code>表示任意个数据库</li>
<li><code>EOF</code>表示正文内容结束</li>
<li><code>check_sum</code>校验和，8字节，通过前面4部分内容计算得出</li>
</ul>
<p>下面重点说下<code>databases</code>字段，每个<code>database</code>都是包括如下几个部分。</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220416100056609.png" alt="image-20220416100056609"></p>
<ul>
<li><p><code>SELECTDB</code>一字节，表示接下来要读一个数据库号码</p>
</li>
<li><p><code>db_number</code>表示一个数据库号码，长度1、2、5字节，当读入该数字后，redis会调用<code>select</code>命令进行数据库切换</p>
</li>
<li><p><code>key_value_pairs</code>表示数据库中所有的键值对数据，其中又分为不带过期时间的键值对，和带过期时间的键值对</p>
<ul>
<li>不带过期的键值对，由<code>TYPE</code>、<code>key</code>、<code>value</code>组成</li>
</ul>
<p>  <img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220416100445186.png"></p>
<ul>
<li>带过期的键值对，由<code>EXPIRETIME_MS</code>、<code>ms</code>、<code>TYPE</code>、<code>key</code>、<code>value</code>组成</li>
</ul>
<p>  <img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220416100544203.png" alt="image-20220416100544203"></p>
</li>
</ul>
<h1 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h1><p>AOF持久化是通过保存redis服务器在运行期间所执行的<strong>写</strong>命令进行记录数据，AOF持久化分为命令追加、文件写入、文件同步三个步骤，下面分别对这三个步骤进行阐述</p>
<h2 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h2><p>当AOF持久化处于打开的状态，服务器在执行一个写命令之后，会以某种协议的方式将被执行的写命令追加到服务器<code>redisServer</code>中的aof_buf缓冲区末尾</p>
<h2 id="文件写入与同步"><a href="#文件写入与同步" class="headerlink" title="文件写入与同步"></a>文件写入与同步</h2><p>上一次我们说到，redis在运行过程中，是一个事件循环，每次循环执行对应的时间事件和文件事件，因此AOF持久化的写入也在每次事件循环结束后进行，执行函数<code>flushAppendOnlyFile</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">flushAppendOnlyFile</span><span class="params">(<span class="type">int</span> force)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> nwritten;</span><br><span class="line">    <span class="type">int</span> sync_in_progress = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区中没有任何内容，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sdslen</span>(server.aof_buf) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略为每秒 FSYNC </span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC)</span><br><span class="line">        <span class="comment">// 是否有 SYNC 正在后台进行？</span></span><br><span class="line">        sync_in_progress = <span class="built_in">bioPendingJobsOfType</span>(REDIS_BIO_AOF_FSYNC) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每秒 fsync ，并且强制写入为假</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp; !force) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * 当 fsync 策略为每秒钟一次时， fsync 在后台执行。</span></span><br><span class="line"><span class="comment">         * 如果后台仍在执行 FSYNC ，那么我们可以延迟写操作一两秒</span></span><br><span class="line"><span class="comment">         * （如果强制执行 write 的话，服务器主线程将阻塞在 write 上面）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (sync_in_progress) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有 fsync 正在后台进行 。。。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server.aof_flush_postponed_start == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 前面没有推迟过 write 操作，这里将推迟写操作的时间记录下来</span></span><br><span class="line"><span class="comment">                 * 然后就返回，不执行 write 或者 fsync</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                server.aof_flush_postponed_start = server.unixtime;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.unixtime - server.aof_flush_postponed_start &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                 * 如果之前已经因为 fsync 而推迟了 write 操作</span></span><br><span class="line"><span class="comment">                 * 但是推迟的时间不超过 2 秒，那么直接返回</span></span><br><span class="line"><span class="comment">                 * 不执行 write 或者 fsync</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果后台还有 fsync 在执行，并且 write 已经推迟 &gt;= 2 秒</span></span><br><span class="line"><span class="comment">             * 那么执行写操作（write 将被阻塞）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            server.aof_delayed_fsync++;</span><br><span class="line">            <span class="built_in">redisLog</span>(REDIS_NOTICE,<span class="string">&quot;Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 执行到这里，程序会对 AOF 文件进行写入。</span></span><br><span class="line"><span class="comment">     * 清零延迟 write 的时间记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    server.aof_flush_postponed_start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 执行单个 write 操作，如果写入设备是物理的话，那么这个操作应该是原子的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 当然，如果出现像电源中断这样的不可抗现象，那么 AOF 文件也是可能会出现问题的</span></span><br><span class="line"><span class="comment">     * 这时就要用 redis-check-aof 程序来进行修复。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    nwritten = <span class="built_in">write</span>(server.aof_fd,server.aof_buf,<span class="built_in">sdslen</span>(server.aof_buf));</span><br><span class="line">    <span class="keyword">if</span> (nwritten != (<span class="type">signed</span>)<span class="built_in">sdslen</span>(server.aof_buf)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">static</span> <span class="type">time_t</span> last_write_error_log = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> can_log = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将日志的记录频率限制在每行 AOF_WRITE_LOG_ERROR_RATE 秒</span></span><br><span class="line">        <span class="keyword">if</span> ((server.unixtime - last_write_error_log) &gt; AOF_WRITE_LOG_ERROR_RATE) &#123;</span><br><span class="line">            can_log = <span class="number">1</span>;</span><br><span class="line">            last_write_error_log = server.unixtime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果写入出错，那么尝试将该情况写入到日志里面</span></span><br><span class="line">        <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                <span class="built_in">redisLog</span>(REDIS_WARNING,<span class="string">&quot;Error writing to the AOF file: %s&quot;</span>,</span><br><span class="line">                    <span class="built_in">strerror</span>(errno));</span><br><span class="line">                server.aof_last_write_errno = errno;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                <span class="built_in">redisLog</span>(REDIS_WARNING,<span class="string">&quot;Short write while writing to &quot;</span></span><br><span class="line">                                       <span class="string">&quot;the AOF file: (nwritten=%lld, &quot;</span></span><br><span class="line">                                       <span class="string">&quot;expected=%lld)&quot;</span>,</span><br><span class="line">                                       (<span class="type">long</span> <span class="type">long</span>)nwritten,</span><br><span class="line">                                       (<span class="type">long</span> <span class="type">long</span>)<span class="built_in">sdslen</span>(server.aof_buf));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试移除新追加的不完整内容</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ftruncate</span>(server.aof_fd, server.aof_current_size) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                    <span class="built_in">redisLog</span>(REDIS_WARNING, <span class="string">&quot;Could not remove short write &quot;</span></span><br><span class="line">                             <span class="string">&quot;from the append-only file.  Redis may refuse &quot;</span></span><br><span class="line">                             <span class="string">&quot;to load the AOF the next time it starts.  &quot;</span></span><br><span class="line">                             <span class="string">&quot;ftruncate: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* If the ftrunacate() succeeded we can set nwritten to</span></span><br><span class="line"><span class="comment">                 * -1 since there is no longer partial data into the AOF. */</span></span><br><span class="line">                nwritten = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            server.aof_last_write_errno = ENOSPC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理写入 AOF 文件时出现的错误</span></span><br><span class="line">        <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">            <span class="comment">/* We can&#x27;t recover when the fsync policy is ALWAYS since the</span></span><br><span class="line"><span class="comment">             * reply for the client is already in the output buffers, and we</span></span><br><span class="line"><span class="comment">             * have the contract with the user that on acknowledged write data</span></span><br><span class="line"><span class="comment">             * is synched on disk. */</span></span><br><span class="line">            <span class="built_in">redisLog</span>(REDIS_WARNING,<span class="string">&quot;Can&#x27;t recover from AOF write error when the AOF fsync policy is &#x27;always&#x27;. Exiting...&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Recover from failed write leaving data into the buffer. However</span></span><br><span class="line"><span class="comment">             * set an error to stop accepting writes as long as the error</span></span><br><span class="line"><span class="comment">             * condition is not cleared. */</span></span><br><span class="line">            server.aof_last_write_status = REDIS_ERR;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Trim the sds buffer if there was a partial write, and there</span></span><br><span class="line"><span class="comment">             * was no way to undo it with ftruncate(2). */</span></span><br><span class="line">            <span class="keyword">if</span> (nwritten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                server.aof_current_size += nwritten;</span><br><span class="line">                <span class="built_in">sdsrange</span>(server.aof_buf,nwritten,<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">/* We&#x27;ll try again on the next call... */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 写入成功，更新最后写入状态</span></span><br><span class="line">        <span class="keyword">if</span> (server.aof_last_write_status == REDIS_ERR) &#123;</span><br><span class="line">            <span class="built_in">redisLog</span>(REDIS_WARNING,</span><br><span class="line">                <span class="string">&quot;AOF write error looks solved, Redis can write again.&quot;</span>);</span><br><span class="line">            server.aof_last_write_status = REDIS_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新写入后的 AOF 文件大小</span></span><br><span class="line">    server.aof_current_size += nwritten;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 如果 AOF 缓存的大小足够小的话，那么重用这个缓存，</span></span><br><span class="line"><span class="comment">     * 否则的话，释放 AOF 缓存。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">sdslen</span>(server.aof_buf)+<span class="built_in">sdsavail</span>(server.aof_buf)) &lt; <span class="number">4000</span>) &#123;</span><br><span class="line">        <span class="comment">// 清空缓存中的内容，等待重用</span></span><br><span class="line">        <span class="built_in">sdsclear</span>(server.aof_buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 释放缓存</span></span><br><span class="line">        <span class="built_in">sdsfree</span>(server.aof_buf);</span><br><span class="line">        server.aof_buf = <span class="built_in">sdsempty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果 no-appendfsync-on-rewrite 选项为开启状态，</span></span><br><span class="line"><span class="comment">     * 并且有 BGSAVE 或者 BGREWRITEAOF 正在进行的话，</span></span><br><span class="line"><span class="comment">     * 那么不执行 fsync </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_no_fsync_on_rewrite &amp;&amp;</span><br><span class="line">        (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总是执行 fsnyc</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">        <span class="comment">/* aof_fsync is defined as fdatasync() for Linux in order to avoid</span></span><br><span class="line"><span class="comment">         * flushing metadata. */</span></span><br><span class="line">        <span class="built_in">aof_fsync</span>(server.aof_fd); <span class="comment">/* Let&#x27;s try to get this data on the disk */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新最后一次执行 fsnyc 的时间</span></span><br><span class="line">        server.aof_last_fsync = server.unixtime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略为每秒 fsnyc ，并且距离上次 fsync 已经超过 1 秒</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</span><br><span class="line">                server.unixtime &gt; server.aof_last_fsync)) &#123;</span><br><span class="line">        <span class="comment">// 放到后台执行</span></span><br><span class="line">        <span class="keyword">if</span> (!sync_in_progress) <span class="built_in">aof_background_fsync</span>(server.aof_fd);</span><br><span class="line">        <span class="comment">// 更新最后一次执行 fsync 的时间</span></span><br><span class="line">        server.aof_last_fsync = server.unixtime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，我们可以看到执行fsync有几种可能，这些可能性通过appendfsync配置进行决定</p>
<table>
<thead>
<tr>
<th align="left">appendfsync选项的值</th>
<th>flushappendonlyfile函数行为</th>
</tr>
</thead>
<tbody><tr>
<td align="left">always</td>
<td>将aof_buf缓冲区所有内容写入并同步到AOF文件</td>
</tr>
<tr>
<td align="left">everysec</td>
<td>将aof buf缓冲区中的所有内容写入到AOF文件，如果上次同步AOF文件的时间距离现在超过一秒钟，那么再次对AOF 文件进行同步，并且这个同步操作是由一个线程专门负责执行的</td>
</tr>
<tr>
<td align="left">no</td>
<td>将aof_buf缓冲区中的所有内容写入到AOF文件，但并不对AOF文件进行同步,何时同步由操作系统来决定</td>
</tr>
</tbody></table>
<h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>由AOF写入原理可知，每次执行命令，都会向文件中写入命令，那么这就会导致文件较大，而且对于比如这种情况：先添加一个a键，再删除一个a键，这其实最终的效果是和最初一样的，若将两次执行命令都写入，则其实是没有用的，因此redis采用AOF重写的方式，函数为<code>rewriteAppendOnlyFileBackground</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 以下是后台重写 AOF 文件（BGREWRITEAOF）的工作步骤：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) 用户调用 BGREWRITEAOF</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2) Redis 调用这个函数，它执行 fork() ：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    2a) 子进程在临时文件中对 AOF 文件进行重写</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    2b) 父进程将新输入的写命令追加到 server.aof_rewrite_buf 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3) 当步骤 2a 执行完之后，子进程结束</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4) </span></span><br><span class="line"><span class="comment"> *    父进程会捕捉子进程的退出信号，</span></span><br><span class="line"><span class="comment"> *    如果子进程的退出状态是 OK 的话，</span></span><br><span class="line"><span class="comment"> *    那么父进程将新输入命令的缓存追加到临时文件，</span></span><br><span class="line"><span class="comment"> *    然后使用 rename(2) 对临时文件改名，用它代替旧的 AOF 文件，</span></span><br><span class="line"><span class="comment"> *    至此，后台 AOF 重写完成。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> childpid;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经有进程在进行 AOF 重写了</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 fork 开始前的时间，计算 fork 耗时用</span></span><br><span class="line">    start = <span class="built_in">ustime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 子进程 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭网络连接 fd</span></span><br><span class="line">        <span class="built_in">closeListeningSockets</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为进程设置名字，方便记认</span></span><br><span class="line">        <span class="built_in">redisSetProcTitle</span>(<span class="string">&quot;redis-aof-rewrite&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建临时文件，并进行 AOF 重写</span></span><br><span class="line">        <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-rewriteaof-bg-%d.aof&quot;</span>, (<span class="type">int</span>) <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">rewriteAppendOnlyFile</span>(tmpfile) == REDIS_OK) &#123;</span><br><span class="line">            <span class="type">size_t</span> private_dirty = <span class="built_in">zmalloc_get_private_dirty</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (private_dirty) &#123;</span><br><span class="line">                <span class="built_in">redisLog</span>(REDIS_NOTICE,</span><br><span class="line">                    <span class="string">&quot;AOF rewrite: %zu MB of memory used by copy-on-write&quot;</span>,</span><br><span class="line">                    private_dirty/(<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 发送重写成功信号</span></span><br><span class="line">            <span class="built_in">exitFromChild</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发送重写失败信号</span></span><br><span class="line">            <span class="built_in">exitFromChild</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 父进程 */</span></span><br><span class="line">        <span class="comment">// 记录执行 fork 所消耗的时间</span></span><br><span class="line">        server.stat_fork_time = <span class="built_in">ustime</span>()-start;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">redisLog</span>(REDIS_WARNING,</span><br><span class="line">                <span class="string">&quot;Can&#x27;t rewrite append only file in background: fork: %s&quot;</span>,</span><br><span class="line">                <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">redisLog</span>(REDIS_NOTICE,</span><br><span class="line">            <span class="string">&quot;Background append only file rewriting started by pid %d&quot;</span>,childpid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录 AOF 重写的信息</span></span><br><span class="line">        server.aof_rewrite_scheduled = <span class="number">0</span>;</span><br><span class="line">        server.aof_rewrite_time_start = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">        server.aof_child_pid = childpid;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭字典自动 rehash</span></span><br><span class="line">        <span class="built_in">updateDictResizePolicy</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * 将 aof_selected_db 设为 -1 ，</span></span><br><span class="line"><span class="comment">         * 强制让 feedAppendOnlyFile() 下次执行时引发一个 SELECT 命令，</span></span><br><span class="line"><span class="comment">         * 从而确保之后新添加的命令会设置到正确的数据库中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        server.aof_selected_db = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">replicationScriptCacheFlush</span>();</span><br><span class="line">        <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK; <span class="comment">/* unreached */</span></span><br></pre></td></tr></table></figure>

<p>AOF重写的原理，其实是直接读取当前的数据库的值，最后使用一条写语句就可以实现AOF重写</p>
<p>而且AOF重写是放在后台子进程执行，这样可以避免效率太低，但是使用子进程执行重写方式，则在重写过程中，父进程还会执行新的写命令，因此这段事件的命令也要被记录下来，最后再次同步给子进程</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>redis数据库</title>
    <url>/posts/641130346.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<p>这一次主要是接着redis服务器接着进行代码讲解，因为redis服务器中包含大量的数据库，因为redis也对每个数据库设计了结构体</p>
<span id="more"></span>

<h1 id="redis数据库"><a href="#redis数据库" class="headerlink" title="redis数据库"></a>redis数据库</h1><p>在上面<code>redisServer</code>中，有一个数组redisDb *db，这个数组中就是存放的是该服务器所有的数据库，<code>redisDb</code>就是数据库字段，<code>redisServer</code>中的dbnum就是该数组的大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// redis服务器中每一个数据库都是这样一个实例</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisDb</span> &#123;</span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;                </span><br><span class="line">    <span class="comment">// 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳</span></span><br><span class="line">    dict *expires;              </span><br><span class="line">    <span class="comment">// 正处于阻塞状态的键</span></span><br><span class="line">    dict *blocking_keys;        </span><br><span class="line">    <span class="comment">// 可以解除阻塞的键</span></span><br><span class="line">    dict *ready_keys;           </span><br><span class="line">    <span class="comment">// 正在被 WATCH 命令监视的键</span></span><br><span class="line">    dict *watched_keys;         </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">evictionPoolEntry</span> *eviction_pool;    <span class="comment">/* Eviction pool of keys */</span></span><br><span class="line">    <span class="comment">// 数据库号码</span></span><br><span class="line">    <span class="type">int</span> id;                     </span><br><span class="line">    <span class="comment">// 数据库的键的平均 TTL ，统计信息</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> avg_ttl;          </span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220415100146480.png" alt="image-20220415100146480"></p>
<h1 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h1><p>在redisDb中，有一个字段为键的过期时间，因此针对过期的键，redis有一套自己的过期策略，下面进行讲解：</p>
<ul>
<li>定时删除：在设置键过期时间的同时，创建一个定时器</li>
<li>惰性删除：每次要用这个键的时候，先检查是否过期</li>
<li>定期删除：每隔一段时间，对数据库键进行扫描，删除部分过期键</li>
</ul>
<p>redis是使用惰性删除和定期删除配合实现的过期策略</p>
<p>惰性删除代码为<code>db.c/expireIfNeeded</code>，每次执行命令前都执行该函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 检查 key 是否已经过期，如果是的话，将它从数据库中删除。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回 0 表示键没有过期时间，或者键未过期。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回 1 表示键已经因为过期而被删除了。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 惰性删除 所有读写数据库的命令在执行前都会进行检查</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出键的过期时间</span></span><br><span class="line">    <span class="type">mstime_t</span> when = <span class="built_in">getExpire</span>(db,key);</span><br><span class="line">    <span class="type">mstime_t</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果服务器正在进行载入，那么不进行任何过期检查</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are in the context of a Lua script, we claim that time is</span></span><br><span class="line"><span class="comment">     * blocked to when the Lua script started. This way a key can expire</span></span><br><span class="line"><span class="comment">     * only the first time it is accessed and not in the middle of the</span></span><br><span class="line"><span class="comment">     * script execution, making propagation to slaves / AOF consistent.</span></span><br><span class="line"><span class="comment">     * See issue #1525 on Github for more information. */</span></span><br><span class="line">    now = server.lua_caller ? server.lua_time_start : <span class="built_in">mstime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当服务器运行在 replication 模式时</span></span><br><span class="line">    <span class="comment">// 附属节点并不主动删除 key</span></span><br><span class="line">    <span class="comment">// 它只返回一个逻辑上正确的返回值</span></span><br><span class="line">    <span class="comment">// 真正的删除操作要等待主节点发来删除命令时才执行</span></span><br><span class="line">    <span class="comment">// 从而保证数据的同步</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> now &gt; when;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行到这里，表示键带有过期时间，并且服务器为主节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果未过期，返回 0</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt;= when) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete the key */</span></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 AOF 文件和附属节点传播过期信息</span></span><br><span class="line">    <span class="built_in">propagateExpire</span>(db,key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送事件通知</span></span><br><span class="line">    <span class="built_in">notifyKeyspaceEvent</span>(REDIS_NOTIFY_EXPIRED,</span><br><span class="line">        <span class="string">&quot;expired&quot;</span>,key,db-&gt;id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将过期键从数据库中删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dbDelete</span>(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定期删除代码为<code>redis.c/activeExpireCycle</code>，每当redis周期性执行<code>redis.c/serverCron</code>时候，就会调用该函数，它在规定的时间内，遍历各个数据库，随机检查一部分键，若过期则删除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 函数尝试删除数据库中已经过期的键。</span></span><br><span class="line"><span class="comment"> * 当带有过期时间的键比较少时，函数运行得比较保守，</span></span><br><span class="line"><span class="comment"> * 如果带有过期时间的键比较多，那么函数会以更积极的方式来删除过期键，</span></span><br><span class="line"><span class="comment"> * 从而可能地释放被过期键占用的内存。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每次循环中被测试的数据库数目不会超过 REDIS_DBCRON_DBS_PER_CALL 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 timelimit_exit 为真，那么说明还有更多删除工作要做，</span></span><br><span class="line"><span class="comment"> * 那么在 beforeSleep() 函数调用时，程序会再次执行这个函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 过期循环的类型：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果循环的类型为 ACTIVE_EXPIRE_CYCLE_FAST ，</span></span><br><span class="line"><span class="comment"> * 那么函数会以“快速过期”模式执行，</span></span><br><span class="line"><span class="comment"> * 执行的时间不会长过 EXPIRE_FAST_CYCLE_DURATION 毫秒，</span></span><br><span class="line"><span class="comment"> * 并且在 EXPIRE_FAST_CYCLE_DURATION 毫秒之内不会再重新执行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果循环的类型为 ACTIVE_EXPIRE_CYCLE_SLOW ，</span></span><br><span class="line"><span class="comment"> * 那么函数会以“正常过期”模式执行，</span></span><br><span class="line"><span class="comment"> * 函数的执行时限为 REDIS_HS 常量的一个百分比，</span></span><br><span class="line"><span class="comment"> * 这个百分比由 REDIS_EXPIRELOOKUPS_TIME_PERC 定义。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 定期删除 服务器周期性执行redis.c/serverConn时候会执行该函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 函数执行大概流程：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1、函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2、全局变量current_db会记录当前activeExpireCycle函数检查的进度，</span></span><br><span class="line"><span class="comment"> * 并在下一次activeExpireCycle函数调用时，接着上一次的进度进行处理。</span></span><br><span class="line"><span class="comment"> * 比如说，如果当前activeExpirecycle函数在遍历10号数据库时返回了，</span></span><br><span class="line"><span class="comment"> * 那么下次activeExpirecycle函数执行时，将从11号数据库开始查找并删除过期键。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3、随着activeExpireCycle函数的不断执行,服务器中的所有数据库都会被检查一遍，</span></span><br><span class="line"><span class="comment"> * 这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">activeExpireCycle</span><span class="params">(<span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态变量，用来累积函数连续执行时的数据</span></span><br><span class="line">    <span class="comment">// 表明目前检测到哪个数据库了</span></span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> current_db = <span class="number">0</span>; </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> timelimit_exit = <span class="number">0</span>;      </span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> last_fast_cycle = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> j, iteration = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 默认每次处理的数据库数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dbs_per_call = REDIS_DBCRON_DBS_PER_CALL;</span><br><span class="line">    <span class="comment">// 函数开始的时间</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> start = <span class="built_in">ustime</span>(), timelimit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速模式</span></span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST) &#123;</span><br><span class="line">        <span class="comment">// 如果上次函数没有触发 timelimit_exit ，那么不执行处理</span></span><br><span class="line">        <span class="keyword">if</span> (!timelimit_exit) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果距离上次执行未够一定时间，那么不执行处理</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 运行到这里，说明执行快速处理，记录当前时间</span></span><br><span class="line">        last_fast_cycle = start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 一般情况下，函数只处理 REDIS_DBCRON_DBS_PER_CALL 个数据库，</span></span><br><span class="line"><span class="comment">     * 除非：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1)  当前数据库的数量小于 REDIS_DBCRON_DBS_PER_CALL</span></span><br><span class="line"><span class="comment">     * 2)  如果上次处理遇到了时间上限，那么这次需要对所有数据库进行扫描，</span></span><br><span class="line"><span class="comment">     *     这可以避免过多的过期键占用空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dbs_per_call &gt; server.dbnum || timelimit_exit)</span><br><span class="line">        dbs_per_call = server.dbnum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We can use at max ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC percentage of CPU time</span></span><br><span class="line"><span class="comment">     * per iteration. Since this function gets called with a frequency of</span></span><br><span class="line"><span class="comment">     * server.hz times per second, the following is the max amount of</span></span><br><span class="line"><span class="comment">     * microseconds we can spend in this function. */</span></span><br><span class="line">    <span class="comment">// 函数处理的微秒时间上限</span></span><br><span class="line">    <span class="comment">// ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC 默认为 25 ，也即是 25 % 的 CPU 时间</span></span><br><span class="line">    timelimit = <span class="number">1000000</span>*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/<span class="number">100</span>;</span><br><span class="line">    timelimit_exit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (timelimit &lt;= <span class="number">0</span>) timelimit = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是运行在快速模式之下</span></span><br><span class="line">    <span class="comment">// 那么最多只能运行 FAST_DURATION 微秒 </span></span><br><span class="line">    <span class="comment">// 默认值为 1000 （微秒）</span></span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST)</span><br><span class="line">        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; <span class="comment">/* in microseconds. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数据库</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call; j++) &#123;</span><br><span class="line">        <span class="type">int</span> expired;</span><br><span class="line">        <span class="comment">// 指向要处理的数据库</span></span><br><span class="line">        redisDb *db = server.db+(current_db % server.dbnum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为 DB 计数器加一，如果进入 do 循环之后因为超时而跳出</span></span><br><span class="line">        <span class="comment">// 那么下次会直接从下个 DB 开始处理</span></span><br><span class="line">        current_db++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Continue to expire if at the end of the cycle more than 25%</span></span><br><span class="line"><span class="comment">         * of the keys were expired. */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> num, slots;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> now, ttl_sum;</span><br><span class="line">            <span class="type">int</span> ttl_samples;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取数据库中带过期时间的键的数量</span></span><br><span class="line">            <span class="comment">// 如果该数量为 0 ，直接跳过这个数据库</span></span><br><span class="line">            <span class="keyword">if</span> ((num = <span class="built_in">dictSize</span>(db-&gt;expires)) == <span class="number">0</span>) &#123;</span><br><span class="line">                db-&gt;avg_ttl = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取数据库中键值对的数量</span></span><br><span class="line">            slots = <span class="built_in">dictSlots</span>(db-&gt;expires);</span><br><span class="line">            <span class="comment">// 当前时间</span></span><br><span class="line">            now = <span class="built_in">mstime</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个数据库的使用率低于 1% ，扫描起来太费力了（大部分都会 MISS）</span></span><br><span class="line">            <span class="comment">// 跳过，等待字典收缩程序运行</span></span><br><span class="line">            <span class="keyword">if</span> (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">                (num*<span class="number">100</span>/slots &lt; <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The main collection cycle. Sample random keys among keys</span></span><br><span class="line"><span class="comment">             * with an expire set, checking for expired ones. </span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 样本计数器</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 已处理过期键计数器</span></span><br><span class="line">            expired = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 键的总 TTL 计数器</span></span><br><span class="line">            ttl_sum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 总共处理的键计数器</span></span><br><span class="line">            ttl_samples = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每次最多只能检查 LOOKUPS_PER_LOOP 个键</span></span><br><span class="line">            <span class="comment">// 默认每个数据库检查的键数量</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</span><br><span class="line">                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始遍历数据库</span></span><br><span class="line">            <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">                dictEntry *de;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> ttl;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从 expires 中随机取出一个带过期时间的键</span></span><br><span class="line">                <span class="keyword">if</span> ((de = <span class="built_in">dictGetRandomKey</span>(db-&gt;expires)) == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 计算 TTL</span></span><br><span class="line">                ttl = <span class="built_in">dictGetSignedIntegerVal</span>(de)-now;</span><br><span class="line">                <span class="comment">// 如果键已经过期，那么删除它，并将 expired 计数器增一</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">activeExpireCycleTryExpire</span>(db,de,now)) expired++;</span><br><span class="line">                <span class="keyword">if</span> (ttl &lt; <span class="number">0</span>) ttl = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 累积键的 TTL</span></span><br><span class="line">                ttl_sum += ttl;</span><br><span class="line">                <span class="comment">// 累积处理键的个数</span></span><br><span class="line">                ttl_samples++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为这个数据库更新平均 TTL 统计数据</span></span><br><span class="line">            <span class="keyword">if</span> (ttl_samples) &#123;</span><br><span class="line">                <span class="comment">// 计算当前平均值</span></span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> avg_ttl = ttl_sum/ttl_samples;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果这是第一次设置数据库平均 TTL ，那么进行初始化</span></span><br><span class="line">                <span class="keyword">if</span> (db-&gt;avg_ttl == <span class="number">0</span>) db-&gt;avg_ttl = avg_ttl;</span><br><span class="line">                <span class="comment">// 取数据库的上次平均 TTL 和今次平均 TTL 的平均值</span></span><br><span class="line">                db-&gt;avg_ttl = (db-&gt;avg_ttl+avg_ttl)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新遍历次数</span></span><br><span class="line">            iteration++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每遍历 16 次执行一次</span></span><br><span class="line">            <span class="keyword">if</span> ((iteration &amp; <span class="number">0xf</span>) == <span class="number">0</span> &amp;&amp; </span><br><span class="line">                (<span class="built_in">ustime</span>()-start) &gt; timelimit)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果遍历次数正好是 16 的倍数</span></span><br><span class="line">                <span class="comment">// 并且遍历的时间超过了 timelimit</span></span><br><span class="line">                <span class="comment">// 那么断开 timelimit_exit</span></span><br><span class="line">                timelimit_exit = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 已经超时了，返回</span></span><br><span class="line">            <span class="keyword">if</span> (timelimit_exit) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果已删除的过期键占当前总数据库带过期时间的键数量的 25 %</span></span><br><span class="line">            <span class="comment">// 那么不再遍历</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="redis客户端"><a href="#redis客户端" class="headerlink" title="redis客户端"></a>redis客户端</h1><p>因为redis可以和多个客户端进行连接，因此为了区分每个客户端，redis内部为每个连接客户端创建一个结构体<code>redisClient</code>，然后将多个结构体用链表连接在一起</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 套接字描述符</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前正在使用的数据库 使用select可以切换数据库，因为服务器刚开始创建了16个</span></span><br><span class="line">    redisDb *db;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前正在使用的数据库的 id （号码）</span></span><br><span class="line">    <span class="type">int</span> dictid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端的名字</span></span><br><span class="line">    robj *name;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询缓冲区</span></span><br><span class="line">    sds querybuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询缓冲区长度峰值</span></span><br><span class="line">    <span class="type">size_t</span> querybuf_peak;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数数量</span></span><br><span class="line">    <span class="type">int</span> argc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数对象数组</span></span><br><span class="line">    robj **argv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录被客户端执行的命令</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">redisCommand</span> *cmd, *lastcmd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求的类型：内联命令还是多条命令</span></span><br><span class="line">    <span class="type">int</span> reqtype;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余未读取的命令内容数量</span></span><br><span class="line">    <span class="type">int</span> multibulklen;       </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命令内容的长度</span></span><br><span class="line">    <span class="type">long</span> bulklen;           </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回复链表</span></span><br><span class="line">    list *reply;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回复链表中对象的总大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> reply_bytes; /</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已发送字节，处理 short write 用</span></span><br><span class="line">    <span class="type">int</span> sentlen;            </span><br><span class="line">    <span class="comment">// 创建客户端的时间</span></span><br><span class="line">    <span class="type">time_t</span> ctime;           </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端最后一次和服务器互动的时间</span></span><br><span class="line">    <span class="type">time_t</span> lastinteraction; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端的输出缓冲区超过软性限制的时间</span></span><br><span class="line">    <span class="type">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端状态标志</span></span><br><span class="line">    <span class="type">int</span> flags;             </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 server.requirepass 不为 NULL 时</span></span><br><span class="line">    <span class="comment">// 代表认证的状态</span></span><br><span class="line">    <span class="comment">// 0 代表未认证， 1 代表已认证</span></span><br><span class="line">    <span class="type">int</span> authenticated;      </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制状态</span></span><br><span class="line">    <span class="type">int</span> replstate;          </span><br><span class="line">    <span class="comment">// 用于保存主服务器传来的 RDB 文件的文件描述符</span></span><br><span class="line">    <span class="type">int</span> repldbfd;           </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取主服务器传来的 RDB 文件的偏移量</span></span><br><span class="line">    <span class="type">off_t</span> repldboff;       </span><br><span class="line">    <span class="comment">// 主服务器传来的 RDB 文件的大小</span></span><br><span class="line">    <span class="type">off_t</span> repldbsize;       </span><br><span class="line">    </span><br><span class="line">    sds replpreamble;       </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主服务器的复制偏移量</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> reploff;      </span><br><span class="line">    <span class="comment">// 从服务器最后一次发送 REPLCONF ACK 时的偏移量</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_ack_off; </span><br><span class="line">    <span class="comment">// 从服务器最后一次发送 REPLCONF ACK 的时间</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_ack_time;</span><br><span class="line">    <span class="comment">// 主服务器的 master run ID</span></span><br><span class="line">    <span class="comment">// 保存在客户端，用于执行部分重同步</span></span><br><span class="line">    <span class="type">char</span> replrunid[REDIS_RUN_ID_SIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 从服务器的监听端口号</span></span><br><span class="line">    <span class="type">int</span> slave_listening_port; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务状态</span></span><br><span class="line">    multiState mstate;      </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞类型</span></span><br><span class="line">    <span class="type">int</span> btype;              </span><br><span class="line">    <span class="comment">// 阻塞状态</span></span><br><span class="line">    blockingState bpop;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后被写入的全局复制偏移量</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> woff;         </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被监视的键</span></span><br><span class="line">    list *watched_keys;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个字典记录了客户端所有订阅的频道</span></span><br><span class="line">    <span class="comment">// 键为频道名字，值为 NULL</span></span><br><span class="line">    <span class="comment">// 也即是，一个频道的集合</span></span><br><span class="line">    dict *pubsub_channels;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表，包含多个 pubsubPattern 结构</span></span><br><span class="line">    <span class="comment">// 记录了所有订阅频道的客户端的信息</span></span><br><span class="line">    <span class="comment">// 新 pubsubPattern 结构总是被添加到表尾</span></span><br><span class="line">    list *pubsub_patterns;  </span><br><span class="line">    sds peerid;             </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回复偏移量</span></span><br><span class="line">    <span class="type">int</span> bufpos;</span><br><span class="line">    <span class="comment">// 回复缓冲区</span></span><br><span class="line">    <span class="type">char</span> buf[REDIS_REPLY_CHUNK_BYTES];</span><br><span class="line"></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>自己的网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>欢迎加群聊天 452380935</p>
</blockquote>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>redis服务器</title>
    <url>/posts/641130346.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<p>这一次主要讲下redis中服务器这个结构体相关代码，主要从是代码层面进行讲解</p>
<span id="more"></span>

<h1 id="redis服务器"><a href="#redis服务器" class="headerlink" title="redis服务器"></a>redis服务器</h1><p>redis服务器结构体主要代码在<code>redis.h/redisServer</code>，下面给出该结构体源码，可以看到源码中对该结构体定义很长，这一节我们一点点分析，当然有些地方可能我也理解不到位hhh</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// redis服务器实例</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">redisServer</span> &#123;</span><br><span class="line">    <span class="type">char</span> *configfile;   <span class="comment">/* 配置文件的绝对路径 */</span></span><br><span class="line">    <span class="type">int</span> hz;      <span class="comment">/* serverCron() 每秒调用的次数 */</span></span><br><span class="line">    redisDb *db; <span class="comment">/* 数据库数组，里面存放的是该服务器所有的数据库 */</span></span><br><span class="line">    dict *commands;             <span class="comment">/* 命令表（受到 rename 配置选项的作用） */</span></span><br><span class="line">    dict *orig_commands;        <span class="comment">/* 命令表（无 rename 配置选项的作用） */</span></span><br><span class="line">    aeEventLoop *el;  <span class="comment">/* 事件状态 */</span></span><br><span class="line">    <span class="type">unsigned</span> lruclock:REDIS_LRU_BITS; <span class="comment">/* 最近一次使用时钟 */</span></span><br><span class="line">    <span class="type">int</span> shutdown_asap;          <span class="comment">/* 关闭服务器的标识 */</span></span><br><span class="line">    <span class="type">int</span> activerehashing;        <span class="comment">/* 在执行 serverCron() 时进行渐进式 rehash */</span></span><br><span class="line">    <span class="type">char</span> *requirepass;          <span class="comment">/* 是否设置了密码 */</span></span><br><span class="line">    <span class="type">char</span> *pidfile;              <span class="comment">/* PID 文件路径 */</span></span><br><span class="line">    <span class="type">int</span> arch_bits;              <span class="comment">/* 架构类型32or64 */</span></span><br><span class="line">    <span class="type">int</span> cronloops;              <span class="comment">/* serverCron() 函数的运行次数计数器 */</span></span><br><span class="line">    <span class="type">char</span> runid[REDIS_RUN_ID_SIZE+<span class="number">1</span>];  <span class="comment">/* 本服务器的 RUN ID ID在每秒都会变化 */</span></span><br><span class="line">    <span class="type">int</span> sentinel_mode;          <span class="comment">/* 服务器是否运行在 SENTINEL 模式 */</span></span><br><span class="line">    <span class="type">int</span> port;                   <span class="comment">/* TCP 监听端口 */</span></span><br><span class="line">    <span class="type">int</span> tcp_backlog;            <span class="comment">/* TCP连接中已完成队列(完成三次握手之后)的长度 */</span></span><br><span class="line">    <span class="type">char</span> *bindaddr[REDIS_BINDADDR_MAX]; <span class="comment">/* 绑定地址 */</span></span><br><span class="line">    <span class="type">int</span> bindaddr_count;         <span class="comment">/* bindaddr地址数量 */</span></span><br><span class="line">    <span class="type">char</span> *unixsocket;           <span class="comment">/* UNIX socket 路径 */</span></span><br><span class="line">    <span class="type">mode_t</span> unixsocketperm;      <span class="comment">/* UNIX socket permission */</span></span><br><span class="line">    <span class="type">int</span> ipfd[REDIS_BINDADDR_MAX]; <span class="comment">/* TCP套接字描述符 */</span></span><br><span class="line">    <span class="type">int</span> ipfd_count;             <span class="comment">/* ipfd中使用的套接字数量 */</span></span><br><span class="line">    <span class="type">int</span> sofd;                   <span class="comment">/* Unix套接字描述符 */</span></span><br><span class="line">    <span class="type">int</span> cfd[REDIS_BINDADDR_MAX];<span class="comment">/* 集群总线监听套接字 */</span></span><br><span class="line">    <span class="type">int</span> cfd_count;              <span class="comment">/* cfd使用到的套接字数量 */</span></span><br><span class="line">    list *clients;              <span class="comment">/* 链表，保存了所有客户端状态结构 */</span></span><br><span class="line">    list *clients_to_close;     <span class="comment">/* 链表，保存了所有待关闭的客户端 */</span></span><br><span class="line">    list *slaves, *monitors;    <span class="comment">/* 链表，保存了所有从服务器，以及所有监视器 */</span></span><br><span class="line">    redisClient *current_client; <span class="comment">/* C服务器的当前客户端，仅用于崩溃报告 */</span></span><br><span class="line">    <span class="type">int</span> clients_paused;         <span class="comment">/* 客服端是否被paused */</span></span><br><span class="line">    <span class="type">mstime_t</span> clients_pause_end_time; <span class="comment">/* 执行undo clients_paused的时间 */</span></span><br><span class="line">    <span class="type">char</span> neterr[ANET_ERR_LEN];   <span class="comment">/* anet.c网络错误缓冲区 */</span></span><br><span class="line">    dict *migrate_cached_sockets;<span class="comment">/* MIGRATE缓冲套接字 */</span></span><br><span class="line">    <span class="type">int</span> loading;                <span class="comment">/* 服务器是否正在被载入 */</span></span><br><span class="line">    <span class="type">off_t</span> loading_total_bytes; <span class="comment">/* 正在载入的数据的大小 */</span></span><br><span class="line">    <span class="type">off_t</span> loading_loaded_bytes; <span class="comment">/* 已载入数据的大小 */</span></span><br><span class="line">    <span class="type">time_t</span> loading_start_time; <span class="comment">/* 开始进行载入的时间 */</span></span><br><span class="line">    <span class="type">off_t</span> loading_process_events_interval_bytes;</span><br><span class="line">    <span class="comment">// 常用命令的快捷连接</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">redisCommand</span> *delCommand, *multiCommand, *lpushCommand, *lpopCommand,</span><br><span class="line">                        *rpopCommand;</span><br><span class="line">    <span class="type">time_t</span> stat_starttime;          <span class="comment">/* 服务器启动时间 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> stat_numcommands;     <span class="comment">/* 已处理命令的数量 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> stat_numconnections;  <span class="comment">/* 服务器接到的连接请求数量 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> stat_expiredkeys;     <span class="comment">/* 已过期的键数量 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> stat_evictedkeys;     <span class="comment">/* 因为回收内存而被释放的过期键的数量 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> stat_keyspace_hits;   <span class="comment">/* 成功查找键的次数 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> stat_keyspace_misses; <span class="comment">/* 查找键失败的次数 */</span></span><br><span class="line">    <span class="type">size_t</span> stat_peak_memory;        <span class="comment">/* 已使用内存峰值 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> stat_fork_time;       <span class="comment">/* 最后一次执行 fork() 时消耗的时间 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> stat_rejected_conn;   <span class="comment">/* 服务器因为客户端数量过多而拒绝客户端连接的次数 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> stat_sync_full;       <span class="comment">/* 执行 full sync 的次数 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> stat_sync_partial_ok; <span class="comment">/* PSYNC 成功执行的次数 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> stat_sync_partial_err;<span class="comment">/* PSYNC 执行失败的次数 */</span></span><br><span class="line">    list *slowlog;                  <span class="comment">/* 保存了所有慢查询日志的链表 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> slowlog_entry_id;     <span class="comment">/* SLOWLOG当前条目ID */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> slowlog_log_slower_than; <span class="comment">/* 服务器配置 slowlog-log-slower-than 选项的值(SLOWLOG时间限制) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> slowlog_max_len;     <span class="comment">/* 服务器配置 slowlog-max-len 选项的值(SLOWLOG记录的最大项目数) */</span></span><br><span class="line">    <span class="type">size_t</span> resident_set_size;       <span class="comment">/* serverCron()中rss采样次数. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ops_sec_last_sample_time; <span class="comment">/* 最后一次进行抽样的时间 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ops_sec_last_sample_ops;  <span class="comment">/* 最后一次抽样时，服务器已执行命令的数量 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ops_sec_samples[REDIS_OPS_SEC_SAMPLES]; <span class="comment">/* 抽样结果 */</span></span><br><span class="line">    <span class="type">int</span> ops_sec_idx; <span class="comment">/* 数组索引，用于保存抽样结果，并在需要时回绕到 0 */</span></span><br><span class="line">    <span class="type">int</span> verbosity;                  <span class="comment">/* 日志等级 Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice */</span></span><br><span class="line">    <span class="type">int</span> maxidletime;                <span class="comment">/* 客户端超时最大时间 */</span></span><br><span class="line">    <span class="type">int</span> tcpkeepalive;               <span class="comment">/* 是否开启SO_KEEPALIVE选项 */</span></span><br><span class="line">    <span class="type">int</span> active_expire_enabled;      <span class="comment">/* 测试时候可以禁用 */</span></span><br><span class="line">    <span class="type">size_t</span> client_max_querybuf_len; <span class="comment">/* 客户端查询缓冲区长度限制 */</span></span><br><span class="line">    <span class="type">int</span> dbnum;                      <span class="comment">/* 服务器初始化应该创建多少个服务器 config中databases 16可以设定该选项 */</span></span><br><span class="line">    <span class="type">int</span> daemonize;                  <span class="comment">/* 如果作为守护进程运行，则为True */</span></span><br><span class="line">    <span class="comment">// 客户端输出缓冲区大小限制</span></span><br><span class="line">    <span class="comment">// 数组的元素有 REDIS_CLIENT_LIMIT_NUM_CLASSES 个</span></span><br><span class="line">    <span class="comment">// 每个代表一类客户端：普通、从服务器、pubsub，诸如此类</span></span><br><span class="line">    clientBufferLimitsConfig client_obuf_limits[REDIS_CLIENT_LIMIT_NUM_CLASSES];</span><br><span class="line">    <span class="type">int</span> aof_state;                  <span class="comment">/* AOF 状态（开启/关闭/可写） */</span></span><br><span class="line">    <span class="type">int</span> aof_fsync;                  <span class="comment">/* 所使用的 fsync 策略（每个写入/每秒/从不） */</span></span><br><span class="line">    <span class="type">char</span> *aof_filename;             <span class="comment">/* AOF文件名字 */</span></span><br><span class="line">    <span class="type">int</span> aof_no_fsync_on_rewrite;    <span class="comment">/* 如果重写是在prog中，请不要fsync */</span></span><br><span class="line">    <span class="type">int</span> aof_rewrite_perc;           <span class="comment">/* Rewrite AOF if % growth is &gt; M and... */</span></span><br><span class="line">    <span class="type">off_t</span> aof_rewrite_base_size;    <span class="comment">/* 最后一次执行 BGREWRITEAOF 时， AOF 文件的大小 */</span></span><br><span class="line">    <span class="type">off_t</span> aof_current_size;         <span class="comment">/* AOF 文件的当前字节大小 */</span></span><br><span class="line">    <span class="type">int</span> aof_rewrite_scheduled;      <span class="comment">/* BGSAVE终止后重写 */</span></span><br><span class="line">    <span class="type">pid_t</span> aof_child_pid;            <span class="comment">/* 负责进行 AOF 重写的子进程 ID */</span></span><br><span class="line">    list *aof_rewrite_buf_blocks;   <span class="comment">/* AOF 重写缓存链表，链接着多个缓存块 */</span></span><br><span class="line">    sds aof_buf;      <span class="comment">/* AOF 缓冲区 */</span></span><br><span class="line">    <span class="type">int</span> aof_fd;       <span class="comment">/* 当前所选AOF文件的文件描述符 */</span></span><br><span class="line">    <span class="type">int</span> aof_selected_db; <span class="comment">/* 当前在AOF中选择的数据库 */</span></span><br><span class="line">    <span class="type">time_t</span> aof_flush_postponed_start; <span class="comment">/*推迟AOF flush的UNIX时间 */</span></span><br><span class="line">    <span class="type">time_t</span> aof_last_fsync;            <span class="comment">/* 最后一直执行 fsync 的时间 */</span></span><br><span class="line">    <span class="type">time_t</span> aof_rewrite_time_last;   <span class="comment">/* 最后一次AOF重写运行所用的时间 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> aof_rewrite_time_start;  <span class="comment">/* 当前AOF重写开始时间 */</span></span><br><span class="line">    <span class="type">int</span> aof_lastbgrewrite_status;   <span class="comment">/* 最后一次执行 BGREWRITEAOF 的结果REDIS_OK或REDIS_ERR */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> aof_delayed_fsync;  <span class="comment">/* 记录 AOF 的 write 操作被推迟了多少次 */</span></span><br><span class="line">    <span class="type">int</span> aof_rewrite_incremental_fsync;<span class="comment">/* 指示是否需要每写入一定量的数据，就主动执行一次 fsync() */</span></span><br><span class="line">    <span class="type">int</span> aof_last_write_status;      <span class="comment">/* REDIS_OK or REDIS_ERR */</span></span><br><span class="line">    <span class="type">int</span> aof_last_write_errno;       <span class="comment">/* 如果aof_last_write_status是ERR，则有效 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dirty;                <span class="comment">/* 自从上次 SAVE 执行以来，数据库被修改的次数 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dirty_before_bgsave;  <span class="comment">/* BGSAVE 执行前的数据库被修改次数 */</span></span><br><span class="line">    <span class="type">pid_t</span> rdb_child_pid;            <span class="comment">/* 负责执行 BGSAVE 的子进程的 ID，没在执行 BGSAVE 时，设为 -1 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">saveparam</span> *saveparams;   <span class="comment">/* 为RDB保存点数组 */</span></span><br><span class="line">    <span class="type">int</span> saveparamslen;              <span class="comment">/* saveparams长度 */</span></span><br><span class="line">    <span class="type">char</span> *rdb_filename;             <span class="comment">/* RDB文件的名称 */</span></span><br><span class="line">    <span class="type">int</span> rdb_compression;            <span class="comment">/* 是否在RDB中使用压缩 */</span></span><br><span class="line">    <span class="type">int</span> rdb_checksum;               <span class="comment">/* 是否使用RDB校验和 */</span></span><br><span class="line">    <span class="type">time_t</span> lastsave;                <span class="comment">/* 最后一次完成 SAVE 的时间 */</span></span><br><span class="line">    <span class="type">time_t</span> lastbgsave_try;          <span class="comment">/* 最后一次尝试执行 BGSAVE 的时间 */</span></span><br><span class="line">    <span class="type">time_t</span> rdb_save_time_last;      <span class="comment">/* 最近一次 BGSAVE 执行耗费的时间 */</span></span><br><span class="line">    <span class="type">time_t</span> rdb_save_time_start;     <span class="comment">/* 数据库最近一次开始执行 BGSAVE 的时间 */</span></span><br><span class="line">    <span class="type">int</span> lastbgsave_status;          <span class="comment">/* 最后一次执行 SAVE 的状态REDIS_OK or REDIS_ERR */</span></span><br><span class="line">    <span class="type">int</span> stop_writes_on_bgsave_err;  <span class="comment">/* 如果不能BGSAVE，不允许写入 */</span></span><br><span class="line">    <span class="comment">/* Propagation of commands in AOF / replication */</span></span><br><span class="line">    redisOpArray also_propagate;    <span class="comment">/* Additional command to propagate. */</span></span><br><span class="line">    <span class="type">char</span> *logfile;                  <span class="comment">/* 日志文件的路径 */</span></span><br><span class="line">    <span class="type">int</span> syslog_enabled;             <span class="comment">/* 是否启用了syslog */</span></span><br><span class="line">    <span class="type">char</span> *syslog_ident;             <span class="comment">/* 指定syslog的标示符，如果上面的syslog-enabled no，则这个选项无效 */</span></span><br><span class="line">    <span class="type">int</span> syslog_facility;            <span class="comment">/* 指定syslog facility,必须是USER或者LOCAL0到LOCAL7 */</span></span><br><span class="line">    <span class="type">int</span> slaveseldb;                 <span class="comment">/* Last SELECTed DB in replication output */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> master_repl_offset;   <span class="comment">/* 全局复制偏移量（一个累计值） */</span></span><br><span class="line">    <span class="type">int</span> repl_ping_slave_period;     <span class="comment">/* Master每N秒ping一次slave */</span></span><br><span class="line">    <span class="comment">// backlog 本身</span></span><br><span class="line">    <span class="type">char</span> *repl_backlog;             <span class="comment">/* Replication backlog for partial syncs */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_backlog_size;    <span class="comment">/* Backlog循环缓冲区大小 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_backlog_histlen; <span class="comment">/* backlog 中数据的长度 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_backlog_idx;     <span class="comment">/* backlog 的当前索引 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_backlog_off;     <span class="comment">/* backlog 中可以被还原的第一个字节的偏移量 */</span></span><br><span class="line">    <span class="type">time_t</span> repl_backlog_time_limit; <span class="comment">/* backlog 的过期时间 */</span></span><br><span class="line">    <span class="type">time_t</span> repl_no_slaves_since;    <span class="comment">/* 距离上一次有从服务器的时间 */</span></span><br><span class="line">    <span class="type">int</span> repl_min_slaves_to_write;   <span class="comment">/* 是否开启最小数量从服务器写入功能 */</span></span><br><span class="line">    <span class="type">int</span> repl_min_slaves_max_lag;    <span class="comment">/* 定义最小数量从服务器的最大延迟值 */</span></span><br><span class="line">    <span class="type">int</span> repl_good_slaves_count;     <span class="comment">/* 延迟良好的从服务器的数量 lag &lt;= max_lag. */</span></span><br><span class="line">    <span class="type">char</span> *masterauth;               <span class="comment">/* 主服务器的验证密码 */</span></span><br><span class="line">    <span class="type">char</span> *masterhost;               <span class="comment">/* 主服务器的地址 */</span></span><br><span class="line">    <span class="type">int</span> masterport;                 <span class="comment">/* 主服务器的端口 */</span></span><br><span class="line">    <span class="type">int</span> repl_timeout;               <span class="comment">/* 主机空闲N秒后超时 */</span></span><br><span class="line">    redisClient *master;     <span class="comment">/* 主服务器所对应的客户端 */</span></span><br><span class="line">    redisClient *cached_master; <span class="comment">/* 被缓存的主服务器，PSYNC 时使用 */</span></span><br><span class="line">    <span class="type">int</span> repl_syncio_timeout; <span class="comment">/* Timeout for synchronous I/O calls */</span></span><br><span class="line">    <span class="type">int</span> repl_state;          <span class="comment">/* 复制的状态（服务器是从服务器时使用） */</span></span><br><span class="line">    <span class="type">off_t</span> repl_transfer_size; <span class="comment">/* 在同步期间从主机读取的RDB的大小 */</span></span><br><span class="line">    <span class="type">off_t</span> repl_transfer_read; <span class="comment">/* 在同步期间从主设备读取的RDB字节数 */</span></span><br><span class="line">    <span class="comment">// 最近一次执行 fsync 时的偏移量</span></span><br><span class="line">    <span class="comment">// 用于 sync_file_range 函数</span></span><br><span class="line">    <span class="type">off_t</span> repl_transfer_last_fsync_off; <span class="comment">/* 上次fsync-ed时偏移 */</span></span><br><span class="line">    <span class="type">int</span> repl_transfer_s;     <span class="comment">/* 主服务器的套接字 */</span></span><br><span class="line">    <span class="type">int</span> repl_transfer_fd;    <span class="comment">/* 保存 RDB 文件的临时文件的描述符 */</span></span><br><span class="line">    <span class="type">char</span> *repl_transfer_tmpfile; <span class="comment">/* 保存 RDB 文件的临时文件名字 */</span></span><br><span class="line">    <span class="type">time_t</span> repl_transfer_lastio; <span class="comment">/* 最近一次读入 RDB 内容的时间 */</span></span><br><span class="line">    <span class="type">int</span> repl_serve_stale_data; <span class="comment">/* Serve stale data when link is down? */</span></span><br><span class="line">    <span class="type">int</span> repl_slave_ro;          <span class="comment">/* 从服务器是否只读 */</span></span><br><span class="line">    <span class="type">time_t</span> repl_down_since; <span class="comment">/* 连接断开的时长 */</span></span><br><span class="line">    <span class="type">int</span> repl_disable_tcp_nodelay;   <span class="comment">/* 是否要在 SYNC 之后关闭 NODELAY */</span></span><br><span class="line">    <span class="type">int</span> slave_priority;             <span class="comment">/* 从服务器优先级 */</span></span><br><span class="line">    <span class="type">char</span> repl_master_runid[REDIS_RUN_ID_SIZE+<span class="number">1</span>];  <span class="comment">/*本服务器（从服务器）当前主服务器的 RUN ID */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_master_initial_offset;         <span class="comment">/* Master PSYNC offset. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ---------下面一些属性有些很难用到，对此我也没仔细看 */</span></span><br><span class="line">    <span class="comment">/* Replication script cache. */</span></span><br><span class="line">    <span class="comment">// 复制脚本缓存</span></span><br><span class="line">    <span class="comment">// 字典</span></span><br><span class="line">    dict *repl_scriptcache_dict;        <span class="comment">/* SHA1 all slaves are aware of. */</span></span><br><span class="line">    <span class="comment">// FIFO 队列</span></span><br><span class="line">    list *repl_scriptcache_fifo;        <span class="comment">/* First in, first out LRU eviction. */</span></span><br><span class="line">    <span class="comment">// 缓存的大小</span></span><br><span class="line">    <span class="type">int</span> repl_scriptcache_size;          <span class="comment">/* Max number of elements. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Synchronous replication. */</span></span><br><span class="line">    list *clients_waiting_acks;         <span class="comment">/* Clients waiting in WAIT command. */</span></span><br><span class="line">    <span class="type">int</span> get_ack_from_slaves;            <span class="comment">/* If true we send REPLCONF GETACK. */</span></span><br><span class="line">    <span class="type">int</span> maxclients;                 <span class="comment">/* 最大并发客户端数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> maxmemory;   <span class="comment">/* 要使用的最大内存字节数 */</span></span><br><span class="line">    <span class="type">int</span> maxmemory_policy;           <span class="comment">/* Policy for key eviction */</span></span><br><span class="line">    <span class="type">int</span> maxmemory_samples;          <span class="comment">/* Pricision of random sampling */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bpop_blocked_clients; <span class="comment">/* 列表阻止的客户端数量 */</span></span><br><span class="line">    list *unblocked_clients; <span class="comment">/* 在下一个循环之前解锁的客户端列表 */</span></span><br><span class="line">    list *ready_keys;        <span class="comment">/* List of readyList structures for BLPOP &amp; co */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Sort parameters - qsort_r() is only available under BSD so we</span></span><br><span class="line"><span class="comment">     * have to take this state global, in order to pass it to sortCompare() */</span></span><br><span class="line">    <span class="type">int</span> sort_desc;</span><br><span class="line">    <span class="type">int</span> sort_alpha;</span><br><span class="line">    <span class="type">int</span> sort_bypattern;</span><br><span class="line">    <span class="type">int</span> sort_store;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Zip structure config, see redis.conf for more information  */</span></span><br><span class="line">    <span class="type">size_t</span> hash_max_ziplist_entries;</span><br><span class="line">    <span class="type">size_t</span> hash_max_ziplist_value;</span><br><span class="line">    <span class="type">size_t</span> list_max_ziplist_entries;</span><br><span class="line">    <span class="type">size_t</span> list_max_ziplist_value;</span><br><span class="line">    <span class="type">size_t</span> set_max_intset_entries;</span><br><span class="line">    <span class="type">size_t</span> zset_max_ziplist_entries;</span><br><span class="line">    <span class="type">size_t</span> zset_max_ziplist_value;</span><br><span class="line">    <span class="type">size_t</span> hll_sparse_max_bytes;</span><br><span class="line">    <span class="type">time_t</span> unixtime;        <span class="comment">/* Unix time sampled every cron cycle. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mstime;       <span class="comment">/* Like &#x27;unixtime&#x27; but with milliseconds resolution. */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pubsub */</span></span><br><span class="line">    <span class="comment">// 字典，键为频道，值为链表</span></span><br><span class="line">    <span class="comment">// 链表中保存了所有订阅某个频道的客户端</span></span><br><span class="line">    <span class="comment">// 新客户端总是被添加到链表的表尾</span></span><br><span class="line">    dict *pubsub_channels;  <span class="comment">/* Map channels to list of subscribed clients */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个链表记录了客户端订阅的所有模式的名字</span></span><br><span class="line">    list *pubsub_patterns;  <span class="comment">/* A list of pubsub_patterns */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> notify_keyspace_events; <span class="comment">/* Events to propagate via Pub/Sub. This is an</span></span><br><span class="line"><span class="comment">                                   xor of REDIS_NOTIFY... flags. */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Cluster */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cluster_enabled;      <span class="comment">/* 群集是否已启用 */</span></span><br><span class="line">    <span class="type">mstime_t</span> cluster_node_timeout; <span class="comment">/* 集群节点超时时间. */</span></span><br><span class="line">    <span class="type">char</span> *cluster_configfile; <span class="comment">/* 集群自动生成的配置文件名 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">clusterState</span> *cluster;  <span class="comment">/* 集群的状态*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cluster_migration_barrier; <span class="comment">/* Cluster replicas migration barrier. */</span></span><br><span class="line">    <span class="comment">/* Scripting */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lua 环境</span></span><br><span class="line">    lua_State *lua; <span class="comment">/* The Lua interpreter. We use just one for all clients */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制执行 Lua 脚本中的 Redis 命令的伪客户端</span></span><br><span class="line">    redisClient *lua_client;   <span class="comment">/* The &quot;fake client&quot; to query Redis from Lua */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前正在执行 EVAL 命令的客户端，如果没有就是 NULL</span></span><br><span class="line">    redisClient *lua_caller;   <span class="comment">/* The client running EVAL right now, or NULL */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个字典，值为 Lua 脚本，键为脚本的 SHA1 校验和</span></span><br><span class="line">    dict *lua_scripts;         <span class="comment">/* A dictionary of SHA1 -&gt; Lua scripts */</span></span><br><span class="line">    <span class="comment">// Lua 脚本的执行时限</span></span><br><span class="line">    <span class="type">mstime_t</span> lua_time_limit;  <span class="comment">/* Script timeout in milliseconds */</span></span><br><span class="line">    <span class="comment">// 脚本开始执行的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> lua_time_start;  <span class="comment">/* Start time of script, milliseconds time */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 脚本是否执行过写命令</span></span><br><span class="line">    <span class="type">int</span> lua_write_dirty;  <span class="comment">/* True if a write command was called during the</span></span><br><span class="line"><span class="comment">                             execution of the current script. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 脚本是否执行过带有随机性质的命令</span></span><br><span class="line">    <span class="type">int</span> lua_random_dirty; <span class="comment">/* True if a random command was called during the</span></span><br><span class="line"><span class="comment">                             execution of the current script. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 脚本是否超时</span></span><br><span class="line">    <span class="type">int</span> lua_timedout;     <span class="comment">/* True if we reached the time limit for script</span></span><br><span class="line"><span class="comment">                             execution. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否要杀死脚本</span></span><br><span class="line">    <span class="type">int</span> lua_kill;         <span class="comment">/* Kill the script if true. */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assert &amp; bug reporting */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *assert_failed;</span><br><span class="line">    <span class="type">char</span> *assert_file;</span><br><span class="line">    <span class="type">int</span> assert_line;</span><br><span class="line">    <span class="type">int</span> bug_report_start; <span class="comment">/* True if bug report header was already logged. */</span></span><br><span class="line">    <span class="type">int</span> watchdog_period;  <span class="comment">/* Software watchdog period in ms. 0 = off */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面重点讲下redis服务器启动的流程，主要包括以下几个步骤，不懂的同学可以看下<code>redis.c/main</code>函数，就可以大致了解其过程</p>
<ul>
<li>检查服务器是否以<code>Sentinel</code>模式启动</li>
<li>初始化全局服务器配置<code>initServerConfig()</code></li>
<li>如果是<code>Sentinel</code>模式，则初始化相关配置<code>initSentinelConfig</code>、<code>initSentinel</code></li>
<li>加载配置文件<code>loadServerConfig()</code></li>
<li>将服务器进程设置为守护进程<code>daemonize</code></li>
<li>初始化服务器<code>initServer</code></li>
<li>如果服务器进程为守护进程，则创建PID文件<code>createPidFile</code></li>
<li>为服务器进程设置名字<code>redisSetProcTitle</code></li>
<li>打印logo<code>redisAsciiArt</code></li>
<li>加载数据库<code>loadDataFromDisk</code>：<ul>
<li>AOF 持久化已打开，则使用<code>loadAppendOnlyFile()</code>，</li>
<li>否则使用加载RDB文件<code>rdbLoad()</code></li>
</ul>
</li>
<li>运行事件处理器，一直到服务器关闭为止<code>aeMain</code></li>
</ul>
<p>下面对上面几个函数依次进行讲解</p>
<h2 id="Sentinel模式"><a href="#Sentinel模式" class="headerlink" title="Sentinel模式"></a>Sentinel模式</h2><p><code>Sentinel</code>模式就是哨兵模式，下面给出该模式的一个例子</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649582071973.png" alt="1649582071973"></p>
<p>其中<code>server1</code>是主服务器，其余<code>server2,3,4</code>为从服务器。在生产环境中，不免会有意外原因导致redis服务器挂掉，如果此时挂掉的是一个master节点，主节点宕机，主从复制将不能继续进行，写数据将会阻塞，而哨兵的存在主要是为了切换掉宕机的master，然后从master下面的slave节点中选举一个作为新的master，并且把旧的master的slave全部转移到新的master上面，继续原有的主从复制。 哨兵本身是一个独立的进程，本身也是有单点问题的，所以哨兵也有自身的集群，用来保证哨兵本身的容错机制。 </p>
<p>可以将redis中sentinel想成一个特殊的redis服务器，但是他不会像redis普通服务器那样去加载rdb或者aof文件，在<code>initSentinel</code>函数中，会创建一个sentinel结构体 <code>sentinelState</code>，代码如下 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Sentinel 的状态结构 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sentinelState</span> &#123;</span><br><span class="line">    <span class="comment">// 当前纪元</span></span><br><span class="line">    <span class="type">uint64_t</span> current_epoch;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存了所有被这个 sentinel 监视的主服务器</span></span><br><span class="line">    <span class="comment">// 字典的键是主服务器的名字</span></span><br><span class="line">    <span class="comment">// 字典的值则是一个指向 sentinelRedisInstance 结构的指针</span></span><br><span class="line">    dict *masters;      </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否进入了 TILT 模式？</span></span><br><span class="line">    <span class="type">int</span> tilt;          </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前正在执行的脚本的数量</span></span><br><span class="line">    <span class="type">int</span> running_scripts;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入 TILT 模式的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> tilt_start_time;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一次执行时间处理器的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> previous_time;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个 FIFO 队列，包含了所有需要执行的用户脚本</span></span><br><span class="line">    list *scripts_queue;    </span><br><span class="line"></span><br><span class="line">&#125; sentinel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 Sentinel 模式初始化服务器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initSentinel</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空 Redis 服务器的命令表（该表用于普通模式）</span></span><br><span class="line">    <span class="built_in">dictEmpty</span>(server.commands,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 将 SENTINEL 模式所用的命令添加进命令表</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">sizeof</span>(sentinelcmds)/<span class="built_in">sizeof</span>(sentinelcmds[<span class="number">0</span>]); j++) &#123;</span><br><span class="line">        <span class="type">int</span> retval;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">redisCommand</span> *cmd = sentinelcmds+j;</span><br><span class="line"></span><br><span class="line">        retval = <span class="built_in">dictAdd</span>(server.commands, <span class="built_in">sdsnew</span>(cmd-&gt;name), cmd);</span><br><span class="line">        <span class="built_in">redisAssert</span>(retval == DICT_OK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化 Sentinel 的状态 */</span></span><br><span class="line">    <span class="comment">// 初始化纪元</span></span><br><span class="line">    sentinel.current_epoch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化保存主服务器信息的字典</span></span><br><span class="line">    sentinel.masters = <span class="built_in">dictCreate</span>(&amp;instancesDictType,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 TILT 模式的相关选项</span></span><br><span class="line">    sentinel.tilt = <span class="number">0</span>;</span><br><span class="line">    sentinel.tilt_start_time = <span class="number">0</span>;</span><br><span class="line">    sentinel.previous_time = <span class="built_in">mstime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化脚本相关选项</span></span><br><span class="line">    sentinel.running_scripts = <span class="number">0</span>;</span><br><span class="line">    sentinel.scripts_queue = <span class="built_in">listCreate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有一个master字典，这里面记录了记录了所有被 Sentinel 监视的主服务器的相关信息， 其中：</p>
<ul>
<li>字典的键是被监视主服务器的名字。</li>
<li>而字典的值则是被监视主服务器对应的 <code>sentinel.c/sentinelRedisInstance</code> 结构。</li>
</ul>
<p> 每个 <code>sentinelRedisInstance</code> 结构代表一个被 Sentinel 监视的 Redis 服务器实例（instance）， 这个实例可以是主服务器、从服务器、或者另外一个 Sentinel 。下面给出这个结构体的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sentinel 会为每个被监视的 Redis 实例创建相应的 sentinelRedisInstance 实例</span></span><br><span class="line"><span class="comment">// （被监视的实例可以是主服务器、从服务器、或者其他 Sentinel ）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">sentinelRedisInstance</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标识值，记录了实例的类型，以及该实例的当前状态</span></span><br><span class="line">    <span class="comment">// 当为SRI_MASTER为主服务器，当为SRI_SLAVE为从服务器，当为SRI_SENTINEL为sentinel服务器</span></span><br><span class="line">    <span class="type">int</span> flags;      </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例的名字</span></span><br><span class="line">    <span class="comment">// 主服务器的名字由用户在配置文件中设置</span></span><br><span class="line">    <span class="comment">// 从服务器以及 Sentinel 的名字由 Sentinel 自动设置</span></span><br><span class="line">    <span class="comment">// 格式为 ip:port ，例如 &quot;127.0.0.1:26379&quot;</span></span><br><span class="line">    <span class="type">char</span> *name;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例的运行 ID</span></span><br><span class="line">    <span class="type">char</span> *runid;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="type">uint64_t</span> config_epoch;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例的地址</span></span><br><span class="line">    sentinelAddr *addr; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于发送命令的异步连接</span></span><br><span class="line">    redisAsyncContext *cc; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于执行 SUBSCRIBE 命令、接收频道信息的异步连接</span></span><br><span class="line">    <span class="comment">// 仅在实例为主服务器时使用</span></span><br><span class="line">    redisAsyncContext *pc; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已发送但尚未回复的命令数量</span></span><br><span class="line">    <span class="type">int</span> pending_commands;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// cc 连接的创建时间</span></span><br><span class="line">    <span class="type">mstime_t</span> cc_conn_time; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// pc 连接的创建时间</span></span><br><span class="line">    <span class="type">mstime_t</span> pc_conn_time; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一次从这个实例接收信息的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> pc_last_activity; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例最后一次返回正确的 PING 命令回复的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> last_avail_time; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例最后一次发送 PING 命令的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> last_ping_time;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例最后一次返回 PING 命令的时间，无论内容正确与否</span></span><br><span class="line">    <span class="type">mstime_t</span> last_pong_time;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一次向频道发送问候信息的时间</span></span><br><span class="line">    <span class="comment">// 只在当前实例为 sentinel 时使用</span></span><br><span class="line">    <span class="type">mstime_t</span> last_pub_time;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一次接收到这个 sentinel 发来的问候信息的时间</span></span><br><span class="line">    <span class="comment">// 只在当前实例为 sentinel 时使用</span></span><br><span class="line">    <span class="type">mstime_t</span> last_hello_time; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一次回复 SENTINEL is-master-down-by-addr 命令的时间</span></span><br><span class="line">    <span class="comment">// 只在当前实例为 sentinel 时使用</span></span><br><span class="line">    <span class="type">mstime_t</span> last_master_down_reply_time; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例被判断为 SDOWN 状态的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> s_down_since_time; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例被判断为 ODOWN 状态的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> o_down_since_time; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// SENTINEL down-after-milliseconds 选项所设定的值</span></span><br><span class="line">    <span class="comment">// 实例无响应多少毫秒之后才会被判断为主观下线（subjectively down）</span></span><br><span class="line">    <span class="type">mstime_t</span> down_after_period; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从实例获取 INFO 命令的回复的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> info_refresh;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例的角色</span></span><br><span class="line">    <span class="type">int</span> role_reported;</span><br><span class="line">    <span class="comment">// 角色的更新时间</span></span><br><span class="line">    <span class="type">mstime_t</span> role_reported_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一次从服务器的主服务器地址变更的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> slave_conf_change_time; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主服务器实例特有的属性 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他同样监控这个主服务器的所有 sentinel</span></span><br><span class="line">    dict *sentinels;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这个实例代表的是一个主服务器</span></span><br><span class="line">    <span class="comment">// 那么这个字典保存着主服务器属下的从服务器</span></span><br><span class="line">    <span class="comment">// 字典的键是从服务器的名字，字典的值是从服务器对应的 sentinelRedisInstance 结构</span></span><br><span class="line">    dict *slaves;       </span><br><span class="line"></span><br><span class="line">    <span class="comment">// SENTINEL monitor &lt;master-name&gt; &lt;IP&gt; &lt;port&gt; &lt;quorum&gt; 选项中的 quorum 参数</span></span><br><span class="line">    <span class="comment">// 判断这个实例为客观下线（objectively down）所需的支持投票数量</span></span><br><span class="line">    <span class="type">int</span> quorum;         </span><br><span class="line"></span><br><span class="line">    <span class="comment">// SENTINEL parallel-syncs &lt;master-name&gt; &lt;number&gt; 选项的值</span></span><br><span class="line">    <span class="comment">// 在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量</span></span><br><span class="line">    <span class="type">int</span> parallel_syncs; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接主服务器和从服务器所需的密码</span></span><br><span class="line">    <span class="type">char</span> *auth_pass;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从服务器实例特有的属性*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主从服务器连接断开的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> master_link_down_time; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从服务器优先级</span></span><br><span class="line">    <span class="type">int</span> slave_priority; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行故障转移操作时，从服务器发送 SLAVEOF &lt;new-master&gt; 命令的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> slave_reconf_sent_time; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主服务器的实例（在本实例为从服务器时使用）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sentinelRedisInstance</span> *master; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// INFO 命令的回复中记录的主服务器 IP</span></span><br><span class="line">    <span class="type">char</span> *slave_master_host;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// INFO 命令的回复中记录的主服务器端口号</span></span><br><span class="line">    <span class="type">int</span> slave_master_port;      </span><br><span class="line"></span><br><span class="line">    <span class="comment">// INFO 命令的回复中记录的主从服务器连接状态</span></span><br><span class="line">    <span class="type">int</span> slave_master_link_status; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从服务器的复制偏移量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> slave_repl_offset; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 故障转移相关属性*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这是一个主服务器实例，那么 leader 将是负责进行故障转移的 Sentinel 的运行 ID 。</span></span><br><span class="line">    <span class="comment">// 如果这是一个 Sentinel 实例，那么 leader 就是被选举出来的领头 Sentinel 。</span></span><br><span class="line">    <span class="comment">// 这个域只在 Sentinel 实例的 flags 属性的 SRI_MASTER_DOWN 标志处于打开状态时才有效。</span></span><br><span class="line">    <span class="type">char</span> *leader;       </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 领头的纪元</span></span><br><span class="line">    <span class="type">uint64_t</span> leader_epoch; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前执行中的故障转移的纪元</span></span><br><span class="line">    <span class="type">uint64_t</span> failover_epoch; </span><br><span class="line">    <span class="comment">// 故障转移操作的当前状态</span></span><br><span class="line">    <span class="type">int</span> failover_state; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态改变的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> failover_state_change_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一次进行故障迁移的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> failover_start_time;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// SENTINEL failover-timeout &lt;master-name&gt; &lt;ms&gt; 选项的值</span></span><br><span class="line">    <span class="comment">// 刷新故障迁移状态的最大时限</span></span><br><span class="line">    <span class="type">mstime_t</span> failover_timeout;      </span><br><span class="line"></span><br><span class="line">    <span class="type">mstime_t</span> failover_delay_logged; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向被提升为新主服务器的从服务器的指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sentinelRedisInstance</span> *promoted_slave; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个文件路径，保存着 WARNING 级别的事件发生时执行的，</span></span><br><span class="line">    <span class="comment">// 用于通知管理员的脚本的地址</span></span><br><span class="line">    <span class="type">char</span> *notification_script;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个文件路径，保存着故障转移执行之前、之后、或者被中止时，</span></span><br><span class="line">    <span class="comment">// 需要执行的脚本的地址</span></span><br><span class="line">    <span class="type">char</span> *client_reconfig_script;</span><br><span class="line"></span><br><span class="line">&#125; sentinelRedisInstance;</span><br></pre></td></tr></table></figure>

<p>假如此时启动sentinel时候，配置文件如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">####################</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">master1 configure <span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">####################</span></span></span><br><span class="line">sentinel monitor master1 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds master1 30000</span><br><span class="line">sentinel parallel-syncs master1 1</span><br><span class="line">sentinel failover-timeout master1 900000</span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">####################</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">master2 configure <span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">####################</span></span></span><br><span class="line">sentinel monitor master2 127.0.0.1 12345 5</span><br><span class="line">sentinel down-after-milliseconds master2 50000</span><br><span class="line">sentinel parallel-syncs master2 5</span><br><span class="line">sentinel failover-timeout master2 450000</span><br></pre></td></tr></table></figure>

<p> 则会为2个服务器创建如下结构体</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649583290234.png" alt="1649583290234"></p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649583299940.png" alt="1649583299940"></p>
<p>sentinel结构体中maste字典内容如下</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649583349732.png" alt="1649583349732"></p>
<p>当一个redis服务器以sentinel模式启动，则它会自动去替换一些普通模式服务器的代码，比如普通redis服务器使用<code>redis.h/REDIS_SERVERPORT</code>作为端口，但是sentinel模式下会以<code>sentinel.c/REDIS_SENTINEL_PORT</code>作为端口，同时普通redis服务器的支持的命令在<code>redis.c/redisCommandTable</code>中，但是sentinel模式下支持的命令在<code>sentinel.c/sentinelcmds</code>，其中代码较少，下面给出代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务器在 sentinel 模式下可执行的命令</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">redisCommand</span> sentinelcmds[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;ping&quot;</span>,pingCommand,<span class="number">1</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;sentinel&quot;</span>,sentinelCommand,<span class="number">-2</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;subscribe&quot;</span>,subscribeCommand,<span class="number">-2</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;unsubscribe&quot;</span>,unsubscribeCommand,<span class="number">-1</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;psubscribe&quot;</span>,psubscribeCommand,<span class="number">-2</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;punsubscribe&quot;</span>,punsubscribeCommand,<span class="number">-1</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;publish&quot;</span>,sentinelPublishCommand,<span class="number">3</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;info&quot;</span>,sentinelInfoCommand,<span class="number">-1</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;shutdown&quot;</span>,shutdownCommand,<span class="number">-1</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sentinel主要就是为了应用于主服务器下线导致集群不可用情况，因此最重要的就是如何检测和如何防范，下面通过主观下线和客观下线两种方式进行说明</p>
<ul>
<li>主观下线</li>
</ul>
<p>默认情况下，每个sentinel会每秒钟向其他所有主服务器、从服务器、sentinels发送ping消息，返回结果分为有效返回（+PONG、-LOADING、-MASTERDOWN）三者之一或无效返回（上述三种其他回复或者指定时间内没有回复），若出现无效返回情况，则会将<code>sentinelRedisInstance</code>属性中的flag字段打开<code>SRI_S_DOWN</code>标志</p>
<ul>
<li>客观下线</li>
</ul>
<p>当一个sentinel对一台服务器设置为主观下线后，还需要判断是否客观下线，它会向其他监视该服务器的sentinels进行询问，当接收到足够数量（设置的quorum参数）的sentinels说该服务器也下线，则表明该服务器客观下线。客观下线会打开<code>SRI_O_DOWN</code>标志</p>
<p>当一个主服务器被判定为客观下线后，监视这个下线服务器的全部sentinels会进行协商，选举出一个lead sentinel，这个lead sentinel会对下线服务器进行故障转移，包括三个步骤</p>
<p>1、在已下线主服务器的从服务器中选一个主服务器，然后向其发送<code>SLAVEOF no one</code>命令，设置为主服务器</p>
<p>2、让已下线主服务器下面的从服务器用刚刚选举的主服务器作为主服务器</p>
<p>3、将已下线的主服务器认刚刚选举的主服务器作为自己的主服务器，当这个下线服务器再次上线时，就会真的设置为自己的主服务器</p>
<h2 id="初始化全局服务器配置"><a href="#初始化全局服务器配置" class="headerlink" title="初始化全局服务器配置"></a>初始化全局服务器配置</h2><p><code>redis.c/initServerConfig()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initServerConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器的运行 ID</span></span><br><span class="line">    <span class="built_in">getRandomHexChars</span>(server.runid,REDIS_RUN_ID_SIZE);</span><br><span class="line">    <span class="comment">// 设置默认配置文件路径</span></span><br><span class="line">    server.configfile = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 设置默认服务器频率</span></span><br><span class="line">    server.hz = REDIS_DEFAULT_HZ;</span><br><span class="line">    <span class="comment">// 为运行 ID 加上结尾字符</span></span><br><span class="line">    server.runid[REDIS_RUN_ID_SIZE] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="comment">// 设置服务器的运行架构</span></span><br><span class="line">    server.arch_bits = (<span class="built_in">sizeof</span>(<span class="type">long</span>) == <span class="number">8</span>) ? <span class="number">64</span> : <span class="number">32</span>;</span><br><span class="line">    <span class="comment">// 设置默认服务器端口号</span></span><br><span class="line">    server.port = REDIS_SERVERPORT;</span><br><span class="line">    server.tcp_backlog = REDIS_TCP_BACKLOG;</span><br><span class="line">    server.bindaddr_count = <span class="number">0</span>;</span><br><span class="line">    server.unixsocket = <span class="literal">NULL</span>;</span><br><span class="line">    server.unixsocketperm = REDIS_DEFAULT_UNIX_SOCKET_PERM;</span><br><span class="line">    server.ipfd_count = <span class="number">0</span>;</span><br><span class="line">    server.sofd = <span class="number">-1</span>;</span><br><span class="line">    server.dbnum = REDIS_DEFAULT_DBNUM;</span><br><span class="line">    server.verbosity = REDIS_DEFAULT_VERBOSITY;</span><br><span class="line">    server.maxidletime = REDIS_MAXIDLETIME;</span><br><span class="line">    server.tcpkeepalive = REDIS_DEFAULT_TCP_KEEPALIVE;</span><br><span class="line">    server.active_expire_enabled = <span class="number">1</span>;</span><br><span class="line">    server.client_max_querybuf_len = REDIS_MAX_QUERYBUF_LEN;</span><br><span class="line">    server.saveparams = <span class="literal">NULL</span>;</span><br><span class="line">    server.loading = <span class="number">0</span>;</span><br><span class="line">    server.logfile = <span class="built_in">zstrdup</span>(REDIS_DEFAULT_LOGFILE);</span><br><span class="line">    server.syslog_enabled = REDIS_DEFAULT_SYSLOG_ENABLED;</span><br><span class="line">    server.syslog_ident = <span class="built_in">zstrdup</span>(REDIS_DEFAULT_SYSLOG_IDENT);</span><br><span class="line">    server.syslog_facility = LOG_LOCAL0;</span><br><span class="line">    server.daemonize = REDIS_DEFAULT_DAEMONIZE;</span><br><span class="line">    server.aof_state = REDIS_AOF_OFF;</span><br><span class="line">    server.aof_fsync = REDIS_DEFAULT_AOF_FSYNC;</span><br><span class="line">    server.aof_no_fsync_on_rewrite = REDIS_DEFAULT_AOF_NO_FSYNC_ON_REWRITE;</span><br><span class="line">    server.aof_rewrite_perc = REDIS_AOF_REWRITE_PERC;</span><br><span class="line">    server.aof_rewrite_min_size = REDIS_AOF_REWRITE_MIN_SIZE;</span><br><span class="line">    server.aof_rewrite_base_size = <span class="number">0</span>;</span><br><span class="line">    server.aof_rewrite_scheduled = <span class="number">0</span>;</span><br><span class="line">    server.aof_last_fsync = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    server.aof_rewrite_time_last = <span class="number">-1</span>;</span><br><span class="line">    server.aof_rewrite_time_start = <span class="number">-1</span>;</span><br><span class="line">    server.aof_lastbgrewrite_status = REDIS_OK;</span><br><span class="line">    server.aof_delayed_fsync = <span class="number">0</span>;</span><br><span class="line">    server.aof_fd = <span class="number">-1</span>;</span><br><span class="line">    server.aof_selected_db = <span class="number">-1</span>; <span class="comment">/* 保证不选中任意数据库 */</span></span><br><span class="line">    server.aof_flush_postponed_start = <span class="number">0</span>;</span><br><span class="line">    server.aof_rewrite_incremental_fsync = REDIS_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC;</span><br><span class="line">    server.pidfile = <span class="built_in">zstrdup</span>(REDIS_DEFAULT_PID_FILE);</span><br><span class="line">    server.rdb_filename = <span class="built_in">zstrdup</span>(REDIS_DEFAULT_RDB_FILENAME);</span><br><span class="line">    server.aof_filename = <span class="built_in">zstrdup</span>(REDIS_DEFAULT_AOF_FILENAME);</span><br><span class="line">    server.requirepass = <span class="literal">NULL</span>;</span><br><span class="line">    server.rdb_compression = REDIS_DEFAULT_RDB_COMPRESSION;</span><br><span class="line">    server.rdb_checksum = REDIS_DEFAULT_RDB_CHECKSUM;</span><br><span class="line">    server.stop_writes_on_bgsave_err = REDIS_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR;</span><br><span class="line">    server.activerehashing = REDIS_DEFAULT_ACTIVE_REHASHING;</span><br><span class="line">    server.notify_keyspace_events = <span class="number">0</span>;</span><br><span class="line">    server.maxclients = REDIS_MAX_CLIENTS;</span><br><span class="line">    server.bpop_blocked_clients = <span class="number">0</span>;</span><br><span class="line">    server.maxmemory = REDIS_DEFAULT_MAXMEMORY;</span><br><span class="line">    server.maxmemory_policy = REDIS_DEFAULT_MAXMEMORY_POLICY;</span><br><span class="line">    server.maxmemory_samples = REDIS_DEFAULT_MAXMEMORY_SAMPLES;</span><br><span class="line">    server.hash_max_ziplist_entries = REDIS_HASH_MAX_ZIPLIST_ENTRIES;</span><br><span class="line">    server.hash_max_ziplist_value = REDIS_HASH_MAX_ZIPLIST_VALUE;</span><br><span class="line">    server.list_max_ziplist_entries = REDIS_LIST_MAX_ZIPLIST_ENTRIES;</span><br><span class="line">    server.list_max_ziplist_value = REDIS_LIST_MAX_ZIPLIST_VALUE;</span><br><span class="line">    server.set_max_intset_entries = REDIS_SET_MAX_INTSET_ENTRIES;</span><br><span class="line">    server.zset_max_ziplist_entries = REDIS_ZSET_MAX_ZIPLIST_ENTRIES;</span><br><span class="line">    server.zset_max_ziplist_value = REDIS_ZSET_MAX_ZIPLIST_VALUE;</span><br><span class="line">    server.hll_sparse_max_bytes = REDIS_DEFAULT_HLL_SPARSE_MAX_BYTES;</span><br><span class="line">    server.shutdown_asap = <span class="number">0</span>;</span><br><span class="line">    server.repl_ping_slave_period = REDIS_REPL_PING_SLAVE_PERIOD;</span><br><span class="line">    server.repl_timeout = REDIS_REPL_TIMEOUT;</span><br><span class="line">    server.repl_min_slaves_to_write = REDIS_DEFAULT_MIN_SLAVES_TO_WRITE;</span><br><span class="line">    server.repl_min_slaves_max_lag = REDIS_DEFAULT_MIN_SLAVES_MAX_LAG;</span><br><span class="line">    server.cluster_enabled = <span class="number">0</span>;</span><br><span class="line">    server.cluster_node_timeout = REDIS_CLUSTER_DEFAULT_NODE_TIMEOUT;</span><br><span class="line">    server.cluster_migration_barrier = REDIS_CLUSTER_DEFAULT_MIGRATION_BARRIER;</span><br><span class="line">    server.cluster_configfile = <span class="built_in">zstrdup</span>(REDIS_DEFAULT_CLUSTER_CONFIG_FILE);</span><br><span class="line">    server.lua_caller = <span class="literal">NULL</span>;</span><br><span class="line">    server.lua_time_limit = REDIS_LUA_TIME_LIMIT;</span><br><span class="line">    server.lua_client = <span class="literal">NULL</span>;</span><br><span class="line">    server.lua_timedout = <span class="number">0</span>;</span><br><span class="line">    server.migrate_cached_sockets = <span class="built_in">dictCreate</span>(&amp;migrateCacheDictType,<span class="literal">NULL</span>);</span><br><span class="line">    server.loading_process_events_interval_bytes = (<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 LRU 时间</span></span><br><span class="line">    server.lruclock = <span class="built_in">getLRUClock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化并设置保存条件</span></span><br><span class="line">    <span class="built_in">resetServerSaveParams</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">appendServerSaveParams</span>(<span class="number">60</span>*<span class="number">60</span>,<span class="number">1</span>);  <span class="comment">/* save after 1 hour and 1 change */</span></span><br><span class="line">    <span class="built_in">appendServerSaveParams</span>(<span class="number">300</span>,<span class="number">100</span>);  <span class="comment">/* save after 5 minutes and 100 changes */</span></span><br><span class="line">    <span class="built_in">appendServerSaveParams</span>(<span class="number">60</span>,<span class="number">10000</span>); <span class="comment">/* save after 1 minute and 10000 changes */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化和复制相关的状态</span></span><br><span class="line">    server.masterauth = <span class="literal">NULL</span>;</span><br><span class="line">    server.masterhost = <span class="literal">NULL</span>;</span><br><span class="line">    server.masterport = <span class="number">6379</span>;</span><br><span class="line">    server.master = <span class="literal">NULL</span>;</span><br><span class="line">    server.cached_master = <span class="literal">NULL</span>;</span><br><span class="line">    server.repl_master_initial_offset = <span class="number">-1</span>;</span><br><span class="line">    server.repl_state = REDIS_REPL_NONE;</span><br><span class="line">    server.repl_syncio_timeout = REDIS_REPL_SYNCIO_TIMEOUT;</span><br><span class="line">    server.repl_serve_stale_data = REDIS_DEFAULT_SLAVE_SERVE_STALE_DATA;</span><br><span class="line">    server.repl_slave_ro = REDIS_DEFAULT_SLAVE_READ_ONLY;</span><br><span class="line">    server.repl_down_since = <span class="number">0</span>; <span class="comment">/* Never connected, repl is down since EVER. */</span></span><br><span class="line">    server.repl_disable_tcp_nodelay = REDIS_DEFAULT_REPL_DISABLE_TCP_NODELAY;</span><br><span class="line">    server.slave_priority = REDIS_DEFAULT_SLAVE_PRIORITY;</span><br><span class="line">    server.master_repl_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 PSYNC 命令所使用的 backlog</span></span><br><span class="line">    server.repl_backlog = <span class="literal">NULL</span>;</span><br><span class="line">    server.repl_backlog_size = REDIS_DEFAULT_REPL_BACKLOG_SIZE;</span><br><span class="line">    server.repl_backlog_histlen = <span class="number">0</span>;</span><br><span class="line">    server.repl_backlog_idx = <span class="number">0</span>;</span><br><span class="line">    server.repl_backlog_off = <span class="number">0</span>;</span><br><span class="line">    server.repl_backlog_time_limit = REDIS_DEFAULT_REPL_BACKLOG_TIME_LIMIT;</span><br><span class="line">    server.repl_no_slaves_since = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置客户端的输出缓冲区限制</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; REDIS_CLIENT_LIMIT_NUM_CLASSES; j++)</span><br><span class="line">        server.client_obuf_limits[j] = clientBufferLimitsDefaults[j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化浮点常量</span></span><br><span class="line">    R_Zero = <span class="number">0.0</span>;</span><br><span class="line">    R_PosInf = <span class="number">1.0</span>/R_Zero;</span><br><span class="line">    R_NegInf = <span class="number">-1.0</span>/R_Zero;</span><br><span class="line">    R_Nan = R_Zero/R_Zero;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化命令表</span></span><br><span class="line">    <span class="comment">// 在这里初始化是因为接下来读取 .conf 文件时可能会用到这些命令</span></span><br><span class="line">    server.commands = <span class="built_in">dictCreate</span>(&amp;commandTableDictType,<span class="literal">NULL</span>);</span><br><span class="line">    server.orig_commands = <span class="built_in">dictCreate</span>(&amp;commandTableDictType,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">populateCommandTable</span>();</span><br><span class="line">    server.delCommand = <span class="built_in">lookupCommandByCString</span>(<span class="string">&quot;del&quot;</span>);</span><br><span class="line">    server.multiCommand = <span class="built_in">lookupCommandByCString</span>(<span class="string">&quot;multi&quot;</span>);</span><br><span class="line">    server.lpushCommand = <span class="built_in">lookupCommandByCString</span>(<span class="string">&quot;lpush&quot;</span>);</span><br><span class="line">    server.lpopCommand = <span class="built_in">lookupCommandByCString</span>(<span class="string">&quot;lpop&quot;</span>);</span><br><span class="line">    server.rpopCommand = <span class="built_in">lookupCommandByCString</span>(<span class="string">&quot;rpop&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化慢查询日志</span></span><br><span class="line">    server.slowlog_log_slower_than = REDIS_SLOWLOG_LOG_SLOWER_THAN;</span><br><span class="line">    server.slowlog_max_len = REDIS_SLOWLOG_MAX_LEN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化调试项</span></span><br><span class="line">    server.assert_failed = <span class="string">&quot;&lt;no assertion failed&gt;&quot;</span>;</span><br><span class="line">    server.assert_file = <span class="string">&quot;&lt;no file&gt;&quot;</span>;</span><br><span class="line">    server.assert_line = <span class="number">0</span>;</span><br><span class="line">    server.bug_report_start = <span class="number">0</span>;</span><br><span class="line">    server.watchdog_period = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 主要包括以下几个方面</p>
<ul>
<li>网络监听相关，如绑定地址，TCP端口等 </li>
<li>虚拟内存相关，如swap文件、page大小等 </li>
<li>保存机制，多长时间内有多少次更新才进行保存 </li>
<li>复制相关，如是否是slave，master地址、端口 </li>
<li>Hash相关设置 </li>
<li>初始化命令表</li>
</ul>
<h2 id="加载配置文件"><a href="#加载配置文件" class="headerlink" title="加载配置文件"></a>加载配置文件</h2><p>上面加载的可以想象成是一个默认配置文件，若 初始化时候，指定了配置文件，则会将其中一些字段进行修改<code>config.c/loadServerConfig</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loadServerConfig</span><span class="params">(<span class="type">char</span> *filename, <span class="type">char</span> *options)</span> </span>&#123;</span><br><span class="line">    sds config = <span class="built_in">sdsempty</span>();</span><br><span class="line">    <span class="type">char</span> buf[REDIS_CONFIGLINE_MAX+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 载入文件内容</span></span><br><span class="line">    <span class="keyword">if</span> (filename) &#123;</span><br><span class="line">        FILE *fp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (filename[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; filename[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            fp = stdin;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((fp = <span class="built_in">fopen</span>(filename,<span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">redisLog</span>(REDIS_WARNING,</span><br><span class="line">                    <span class="string">&quot;Fatal error, can&#x27;t open config file &#x27;%s&#x27;&quot;</span>, filename);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">fgets</span>(buf,REDIS_CONFIGLINE_MAX+<span class="number">1</span>,fp) != <span class="literal">NULL</span>)</span><br><span class="line">            config = <span class="built_in">sdscat</span>(config,buf);</span><br><span class="line">        <span class="keyword">if</span> (fp != stdin) <span class="built_in">fclose</span>(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 追加 options 字符串到内容的末尾</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">        config = <span class="built_in">sdscat</span>(config,<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        config = <span class="built_in">sdscat</span>(config,options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据字符串内容，设置服务器配置</span></span><br><span class="line">    <span class="built_in">loadServerConfigFromString</span>(config);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sdsfree</span>(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置为守护进程"><a href="#设置为守护进程" class="headerlink" title="设置为守护进程"></a>设置为守护进程</h2><p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">daemonize</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() != <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* 父进程退出 */</span></span><br><span class="line">    <span class="built_in">setsid</span>(); <span class="comment">/* 创建新会话 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将输出定位到/dev/null */</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR, <span class="number">0</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">dup2</span>(fd, STDIN_FILENO);</span><br><span class="line">        <span class="built_in">dup2</span>(fd, STDOUT_FILENO);</span><br><span class="line">        <span class="built_in">dup2</span>(fd, STDERR_FILENO);</span><br><span class="line">        <span class="keyword">if</span> (fd &gt; STDERR_FILENO) <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始化服务器initServer"><a href="#初始化服务器initServer" class="headerlink" title="初始化服务器initServer"></a>初始化服务器<code>initServer</code></h2><p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置信号处理函数</span></span><br><span class="line">    <span class="comment">// 因为是守护进程，所以没有控制终端，屏蔽SIGHUP</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGHUP, SIG_IGN); </span><br><span class="line">    <span class="comment">// SIGPIPE是写管道发现读进程终止时产生的信号，redis是服务器，会遇到各种client，所以需要忽略</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGPIPE, SIG_IGN);</span><br><span class="line">    <span class="built_in">setupSignalHandlers</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 syslog</span></span><br><span class="line">    <span class="keyword">if</span> (server.syslog_enabled) &#123;</span><br><span class="line">        <span class="built_in">openlog</span>(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,</span><br><span class="line">            server.syslog_facility);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化并创建数据结构</span></span><br><span class="line">    server.current_client = <span class="literal">NULL</span>;</span><br><span class="line">    server.clients = <span class="built_in">listCreate</span>();</span><br><span class="line">    server.clients_to_close = <span class="built_in">listCreate</span>();</span><br><span class="line">    server.slaves = <span class="built_in">listCreate</span>();</span><br><span class="line">    server.monitors = <span class="built_in">listCreate</span>();</span><br><span class="line">    server.slaveseldb = <span class="number">-1</span>; </span><br><span class="line">    server.unblocked_clients = <span class="built_in">listCreate</span>();</span><br><span class="line">    server.ready_keys = <span class="built_in">listCreate</span>();</span><br><span class="line">    server.clients_waiting_acks = <span class="built_in">listCreate</span>();</span><br><span class="line">    server.get_ack_from_slaves = <span class="number">0</span>;</span><br><span class="line">    server.clients_paused = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建共享对象</span></span><br><span class="line">    <span class="built_in">createSharedObjects</span>();</span><br><span class="line">    <span class="built_in">adjustOpenFilesLimit</span>();</span><br><span class="line">    server.el = <span class="built_in">aeCreateEventLoop</span>(server.maxclients+REDIS_EVENTLOOP_FDSET_INCR);</span><br><span class="line">    server.db = <span class="built_in">zmalloc</span>(<span class="built_in">sizeof</span>(redisDb)*server.dbnum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开 TCP 监听端口，用于等待客户端的命令请求</span></span><br><span class="line">    <span class="keyword">if</span> (server.port != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">listenToPort</span>(server.port,server.ipfd,&amp;server.ipfd_count) == REDIS_ERR)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开 UNIX 本地端口</span></span><br><span class="line">    <span class="keyword">if</span> (server.unixsocket != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">unlink</span>(server.unixsocket); <span class="comment">/* don&#x27;t care if this fails */</span></span><br><span class="line">        server.sofd = <span class="built_in">anetUnixServer</span>(server.neterr,server.unixsocket,</span><br><span class="line">            server.unixsocketperm, server.tcp_backlog);</span><br><span class="line">        <span class="keyword">if</span> (server.sofd == ANET_ERR) &#123;</span><br><span class="line">            <span class="built_in">redisLog</span>(REDIS_WARNING, <span class="string">&quot;Opening socket: %s&quot;</span>, server.neterr);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">anetNonBlock</span>(<span class="literal">NULL</span>,server.sofd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Abort if there are no listening sockets at all. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.ipfd_count == <span class="number">0</span> &amp;&amp; server.sofd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">redisLog</span>(REDIS_WARNING, <span class="string">&quot;Configured to not listen anywhere, exiting.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并初始化数据库结构</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">        server.db[j].dict = <span class="built_in">dictCreate</span>(&amp;dbDictType,<span class="literal">NULL</span>);</span><br><span class="line">        server.db[j].expires = <span class="built_in">dictCreate</span>(&amp;keyptrDictType,<span class="literal">NULL</span>);</span><br><span class="line">        server.db[j].blocking_keys = <span class="built_in">dictCreate</span>(&amp;keylistDictType,<span class="literal">NULL</span>);</span><br><span class="line">        server.db[j].ready_keys = <span class="built_in">dictCreate</span>(&amp;setDictType,<span class="literal">NULL</span>);</span><br><span class="line">        server.db[j].watched_keys = <span class="built_in">dictCreate</span>(&amp;keylistDictType,<span class="literal">NULL</span>);</span><br><span class="line">        server.db[j].eviction_pool = <span class="built_in">evictionPoolAlloc</span>();</span><br><span class="line">        server.db[j].id = j;</span><br><span class="line">        server.db[j].avg_ttl = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 PUBSUB 相关结构</span></span><br><span class="line">    server.pubsub_channels = <span class="built_in">dictCreate</span>(&amp;keylistDictType,<span class="literal">NULL</span>);</span><br><span class="line">    server.pubsub_patterns = <span class="built_in">listCreate</span>();</span><br><span class="line">    <span class="built_in">listSetFreeMethod</span>(server.pubsub_patterns,freePubsubPattern);</span><br><span class="line">    <span class="built_in">listSetMatchMethod</span>(server.pubsub_patterns,listMatchPubsubPattern);</span><br><span class="line"></span><br><span class="line">    server.cronloops = <span class="number">0</span>;</span><br><span class="line">    server.rdb_child_pid = <span class="number">-1</span>;</span><br><span class="line">    server.aof_child_pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">aofRewriteBufferReset</span>();</span><br><span class="line">    server.aof_buf = <span class="built_in">sdsempty</span>();</span><br><span class="line">    server.lastsave = <span class="built_in">time</span>(<span class="literal">NULL</span>); <span class="comment">/* At startup we consider the DB saved. */</span></span><br><span class="line">    server.lastbgsave_try = <span class="number">0</span>;    <span class="comment">/* At startup we never tried to BGSAVE. */</span></span><br><span class="line">    server.rdb_save_time_last = <span class="number">-1</span>;</span><br><span class="line">    server.rdb_save_time_start = <span class="number">-1</span>;</span><br><span class="line">    server.dirty = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">resetServerStats</span>();</span><br><span class="line">    <span class="comment">/* A few stats we don&#x27;t want to reset: server startup time, and peak mem. */</span></span><br><span class="line">    server.stat_starttime = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    server.stat_peak_memory = <span class="number">0</span>;</span><br><span class="line">    server.resident_set_size = <span class="number">0</span>;</span><br><span class="line">    server.lastbgsave_status = REDIS_OK;</span><br><span class="line">    server.aof_last_write_status = REDIS_OK;</span><br><span class="line">    server.aof_last_write_errno = <span class="number">0</span>;</span><br><span class="line">    server.repl_good_slaves_count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">updateCachedTime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create the serverCron() time event, that&#x27;s our main way to process</span></span><br><span class="line"><span class="comment">     * background operations. */</span></span><br><span class="line">    <span class="comment">// 为 serverCron() 创建时间事件</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">aeCreateTimeEvent</span>(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">        <span class="built_in">redisPanic</span>(<span class="string">&quot;Can&#x27;t create the serverCron time event.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create an event handler for accepting new connections in TCP and Unix</span></span><br><span class="line"><span class="comment">     * domain sockets. */</span></span><br><span class="line">    <span class="comment">// 为 TCP 连接关联连接应答（accept）处理器</span></span><br><span class="line">    <span class="comment">// 用于接受并应答客户端的 connect() 调用</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">aeCreateFileEvent</span>(server.el, server.ipfd[j], AE_READABLE,</span><br><span class="line">            acceptTcpHandler,<span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">redisPanic</span>(</span><br><span class="line">                    <span class="string">&quot;Unrecoverable error creating server.ipfd file event.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为本地套接字关联应答处理器</span></span><br><span class="line">    <span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">aeCreateFileEvent</span>(server.el,server.sofd,AE_READABLE,</span><br><span class="line">        acceptUnixHandler,<span class="literal">NULL</span>) == AE_ERR) <span class="built_in">redisPanic</span>(<span class="string">&quot;Unrecoverable error creating server.sofd file event.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Open the AOF file if needed. */</span></span><br><span class="line">    <span class="comment">// 如果 AOF 持久化功能已经打开，那么打开或创建一个 AOF 文件</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == REDIS_AOF_ON) &#123;</span><br><span class="line">        server.aof_fd = <span class="built_in">open</span>(server.aof_filename,</span><br><span class="line">                               O_WRONLY|O_APPEND|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span> (server.aof_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">redisLog</span>(REDIS_WARNING, <span class="string">&quot;Can&#x27;t open the append-only file: %s&quot;</span>,</span><br><span class="line">                <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于 32 位实例来说，默认将最大可用内存限制在 3 GB</span></span><br><span class="line">    <span class="keyword">if</span> (server.arch_bits == <span class="number">32</span> &amp;&amp; server.maxmemory == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">redisLog</span>(REDIS_WARNING,<span class="string">&quot;Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with &#x27;noeviction&#x27; policy now.&quot;</span>);</span><br><span class="line">        server.maxmemory = <span class="number">3072LL</span>*(<span class="number">1024</span>*<span class="number">1024</span>); <span class="comment">/* 3 GB */</span></span><br><span class="line">        server.maxmemory_policy = REDIS_MAXMEMORY_NO_EVICTION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果服务器以 cluster 模式打开，那么初始化 cluster</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) <span class="built_in">clusterInit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化复制功能有关的脚本缓存</span></span><br><span class="line">    <span class="built_in">replicationScriptCacheInit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化脚本系统</span></span><br><span class="line">    <span class="built_in">scriptingInit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化慢查询功能</span></span><br><span class="line">    <span class="built_in">slowlogInit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 BIO 系统</span></span><br><span class="line">    <span class="built_in">bioInit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面大多数注释已经对代码进行讲解，下面对<code>slowlogInit</code>进行单独讲解</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化服务器慢查询功能。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个函数只应该在服务器启动时执行一次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slowlogInit</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存日志的链表，FIFO 顺序</span></span><br><span class="line">    server.slowlog = <span class="built_in">listCreate</span>();</span><br><span class="line">    <span class="comment">// 日志数量计数器</span></span><br><span class="line">    server.slowlog_entry_id = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 日志链表的释构函数</span></span><br><span class="line">    <span class="built_in">listSetFreeMethod</span>(server.slowlog,slowlogFreeEntry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 慢查询日志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">slowlogEntry</span> &#123;</span><br><span class="line">    <span class="comment">// 命令与命令参数</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="comment">// 命令与命令参数的数量</span></span><br><span class="line">    <span class="type">int</span> argc;</span><br><span class="line">    <span class="comment">// 唯一标识符</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> id;      </span><br><span class="line">    <span class="comment">// 执行命令消耗的时间，以微秒为单位</span></span><br><span class="line">    <span class="comment">// 注释里说的 nanoseconds 是错误的</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> duration; </span><br><span class="line">    <span class="comment">// 命令执行时的时间，格式为 UNIX 时间戳</span></span><br><span class="line">    <span class="type">time_t</span> time;       </span><br><span class="line">&#125; slowlogEntry;</span><br></pre></td></tr></table></figure>

<p>其中还有一个函数<code>bioInit</code>，redis的BIO系统在redis3.0版本主要做两件事情：AOF持久化和关闭文件，可以将BIO系统想象成下面：创建一个队列，然后创建一些线程，来了一个任务就往队列里面添加任务，线程去任务队列里面取任务出来执行</p>
<p>因为在redis3.0中只需要做两件事情，所以任务的结构体代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 表示后台任务的数据结构</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个结构只由 API 使用，不会被暴露给外部。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bio_job</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务创建时的时间</span></span><br><span class="line">    <span class="type">time_t</span> time; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 任务的参数。参数多于三个时，可以传递数组或者结构 arg1一般是文件描述符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span> *arg1, *arg2, *arg3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>任务初始化</li>
</ul>
<p>首先是相关静态变量的初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_BIO_NUM_OPS       2 <span class="comment">// 2个任务</span></span></span><br><span class="line"><span class="comment">// 工作线程，斥互和条件变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_t</span> bio_threads[REDIS_BIO_NUM_OPS];</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> bio_mutex[REDIS_BIO_NUM_OPS];</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span> bio_condvar[REDIS_BIO_NUM_OPS];</span><br><span class="line"><span class="comment">// 存放工作的队列</span></span><br><span class="line"><span class="type">static</span> list *bio_jobs[REDIS_BIO_NUM_OPS];</span><br><span class="line"><span class="comment">// 初始化变量</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; REDIS_BIO_NUM_OPS; j++) &#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;bio_mutex[j],<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;bio_condvar[j],<span class="literal">NULL</span>);</span><br><span class="line">    bio_jobs[j] = <span class="built_in">listCreate</span>();</span><br><span class="line">    bio_pending[j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; REDIS_BIO_NUM_OPS; j++) &#123;</span><br><span class="line">    <span class="type">void</span> *arg = (<span class="type">void</span>*)(<span class="type">unsigned</span> <span class="type">long</span>) j;</span><br><span class="line">    <span class="comment">// 这里的函数参数是arg = j，也就是每个线程传入一个编号j，0代表关闭文件，1代表aof初始化</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;thread,&amp;attr,bioProcessBackgroundJobs,arg) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">redisLog</span>(REDIS_WARNING,<span class="string">&quot;Fatal: Can&#x27;t initialize Background Jobs.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bio_threads[j] = thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bioProcessBackgroundJobs函数就是后台执行任务的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">bioProcessBackgroundJobs</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (type == REDIS_BIO_CLOSE_FILE) &#123;</span><br><span class="line">        <span class="built_in">close</span>((<span class="type">long</span>)job-&gt;arg1);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == REDIS_BIO_AOF_FSYNC) &#123;</span><br><span class="line">        <span class="built_in">aof_fsync</span>((<span class="type">long</span>)job-&gt;arg1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">redisPanic</span>(<span class="string">&quot;Wrong job type in bioProcessBackgroundJobs().&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件处理器循环aeMain"><a href="#事件处理器循环aeMain" class="headerlink" title="事件处理器循环aeMain"></a>事件处理器循环<code>aeMain</code></h2><p>这个循环主要就是做两件事情，<code>beforeSleep</code>和<code>aeProcessEvents</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 运行事件处理器，一直到服务器关闭为止</span></span><br><span class="line"><span class="built_in">aeSetBeforeSleepProc</span>(server.el,beforeSleep);</span><br><span class="line"><span class="built_in">aeMain</span>(server.el);</span><br><span class="line"><span class="comment">// 服务器关闭，停止事件循环</span></span><br><span class="line"><span class="built_in">aeDeleteEventLoop</span>(server.el);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置处理事件前需要被执行的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aeSetBeforeSleepProc</span><span class="params">(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;beforesleep = beforesleep;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 事件处理器的主循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        <span class="comment">// 如果有需要在事件处理前执行的函数，那么运行它</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;<span class="built_in">beforesleep</span>(eventLoop);</span><br><span class="line">        <span class="comment">// 开始处理事件 其实就是一个事件调度函数，包括处理时间事件和文件事件</span></span><br><span class="line">        <span class="built_in">aeProcessEvents</span>(eventLoop, AE_ALL_EVENTS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除事件处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aeDeleteEventLoop</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">aeApiFree</span>(eventLoop);</span><br><span class="line">    <span class="built_in">zfree</span>(eventLoop-&gt;events);</span><br><span class="line">    <span class="built_in">zfree</span>(eventLoop-&gt;fired);</span><br><span class="line">    <span class="built_in">zfree</span>(eventLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面单独对这两个函数进行讲解</p>
<ul>
<li><code>beforeSleep</code></li>
</ul>
<p>首先先看代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每次处理事件之前执行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">beforeSleep</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">REDIS_NOTUSED</span>(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一次快速的主动过期检查</span></span><br><span class="line">    <span class="keyword">if</span> (server.active_expire_enabled &amp;&amp; server.masterhost == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">activeExpireCycle</span>(ACTIVE_EXPIRE_CYCLE_FAST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果在之前的事件循环迭代中至少有一个客户端阻塞，则向所有slave发送ACK请求 */</span></span><br><span class="line">    <span class="keyword">if</span> (server.get_ack_from_slaves) &#123;</span><br><span class="line">        robj *argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        argv[<span class="number">0</span>] = <span class="built_in">createStringObject</span>(<span class="string">&quot;REPLCONF&quot;</span>,<span class="number">8</span>);</span><br><span class="line">        argv[<span class="number">1</span>] = <span class="built_in">createStringObject</span>(<span class="string">&quot;GETACK&quot;</span>,<span class="number">6</span>);</span><br><span class="line">        argv[<span class="number">2</span>] = <span class="built_in">createStringObject</span>(<span class="string">&quot;*&quot;</span>,<span class="number">1</span>); <span class="comment">/* Not used argument. */</span></span><br><span class="line">        <span class="built_in">replicationFeedSlaves</span>(server.slaves, server.slaveseldb, argv, <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">decrRefCount</span>(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">decrRefCount</span>(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">decrRefCount</span>(argv[<span class="number">2</span>]);</span><br><span class="line">        server.get_ack_from_slaves = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解除阻塞等待同步复制的所有客户端 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listLength</span>(server.clients_waiting_acks))</span><br><span class="line">        <span class="built_in">processClientsWaitingReplicas</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 尝试为刚刚解除阻塞的客户端处理挂起的命令 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listLength</span>(server.unblocked_clients))</span><br><span class="line">        <span class="built_in">processUnblockedClients</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 AOF 缓冲区的内容写入到 AOF 文件</span></span><br><span class="line">    <span class="comment">// void flushAppendOnlyFile(int force) force参数表明是否强制刷新，当为0时候，若后台有fsync在执行，则延迟</span></span><br><span class="line">    <span class="built_in">flushAppendOnlyFile</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在进入下个事件循环前，执行一些集群收尾工作</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) <span class="built_in">clusterBeforeSleep</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>aeProcessEvents</code></li>
</ul>
<p>redis中的事件主要分为两种事件：文件事件（和其他客户端连接产生的事件）和时间事件（定时时间产生的事件）</p>
<p>redis处理时间事件的函数会在服务器运行期间，每隔一段事件运行，处理时间事件，每个事件以链表形式挂在一起，每次处理时候，都是遍历该链表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Process time events</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 处理所有已到达的时间事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">processTimeEvents</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> processed = <span class="number">0</span>;</span><br><span class="line">    aeTimeEvent *te;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> maxId;</span><br><span class="line">    <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the system clock is moved to the future, and then set back to the</span></span><br><span class="line"><span class="comment">     * right value, time events may be delayed in a random way. Often this</span></span><br><span class="line"><span class="comment">     * means that scheduled operations will not be performed soon enough.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Here we try to detect system clock skews, and force all the time</span></span><br><span class="line"><span class="comment">     * events to be processed ASAP when this happens: the idea is that</span></span><br><span class="line"><span class="comment">     * processing events earlier is less dangerous than delaying them</span></span><br><span class="line"><span class="comment">     * indefinitely, and practice suggests it is. */</span></span><br><span class="line">    <span class="comment">// 通过重置事件的运行时间，</span></span><br><span class="line">    <span class="comment">// 防止因时间穿插（skew）而造成的事件处理混乱</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt; eventLoop-&gt;lastTime) &#123;</span><br><span class="line">        te = eventLoop-&gt;timeEventHead;</span><br><span class="line">        <span class="keyword">while</span>(te) &#123;</span><br><span class="line">            te-&gt;when_sec = <span class="number">0</span>;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新最后一次处理时间事件的时间</span></span><br><span class="line">    eventLoop-&gt;lastTime = now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="comment">// 执行那些已经到达的事件</span></span><br><span class="line">    te = eventLoop-&gt;timeEventHead;</span><br><span class="line">    maxId = eventLoop-&gt;timeEventNextId<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(te) &#123;</span><br><span class="line">        <span class="type">long</span> now_sec, now_ms;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过无效事件</span></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id &gt; maxId) &#123;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        <span class="built_in">aeGetTime</span>(&amp;now_sec, &amp;now_ms);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前时间等于或等于事件的执行时间，那么说明事件已到达，执行这个事件</span></span><br><span class="line">        <span class="keyword">if</span> (now_sec &gt; te-&gt;when_sec ||</span><br><span class="line">            (now_sec == te-&gt;when_sec &amp;&amp; now_ms &gt;= te-&gt;when_ms))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">            id = te-&gt;id;</span><br><span class="line">            <span class="comment">// 执行事件处理器，并获取返回值</span></span><br><span class="line">            retval = te-&gt;<span class="built_in">timeProc</span>(eventLoop, id, te-&gt;clientData);</span><br><span class="line">            processed++;</span><br><span class="line">            <span class="comment">/* After an event is processed our time event list may</span></span><br><span class="line"><span class="comment">             * no longer be the same, so we restart from head.</span></span><br><span class="line"><span class="comment">             * Still we make sure to don&#x27;t process events registered</span></span><br><span class="line"><span class="comment">             * by event handlers itself in order to don&#x27;t loop forever.</span></span><br><span class="line"><span class="comment">             * To do so we saved the max ID we want to handle.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * FUTURE OPTIMIZATIONS:</span></span><br><span class="line"><span class="comment">             * Note that this is NOT great algorithmically. Redis uses</span></span><br><span class="line"><span class="comment">             * a single time event so it&#x27;s not a problem but the right</span></span><br><span class="line"><span class="comment">             * way to do this is to add the new elements on head, and</span></span><br><span class="line"><span class="comment">             * to flag deleted elements in a special way for later</span></span><br><span class="line"><span class="comment">             * deletion (putting references to the nodes to delete into</span></span><br><span class="line"><span class="comment">             * another linked list). */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录是否有需要循环执行这个事件时间</span></span><br><span class="line">            <span class="keyword">if</span> (retval != AE_NOMORE) &#123;</span><br><span class="line">                <span class="comment">// 是的， retval 毫秒之后继续执行这个时间事件</span></span><br><span class="line">                <span class="built_in">aeAddMillisecondsToNow</span>(retval,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不，将这个事件删除</span></span><br><span class="line">                <span class="built_in">aeDeleteTimeEvent</span>(eventLoop, id);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为执行事件之后，事件列表可能已经被改变了</span></span><br><span class="line">            <span class="comment">// 因此需要将 te 放回表头，继续开始执行事件</span></span><br><span class="line">            te = eventLoop-&gt;timeEventHead;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码就是redis的事件调度函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 事件调度函数</span></span><br><span class="line"><span class="comment"> * 处理所有已到达的时间事件，以及所有已就绪的文件事件。</span></span><br><span class="line"><span class="comment"> * 如果不传入特殊 flags 的话，那么函数睡眠直到文件事件就绪，</span></span><br><span class="line"><span class="comment"> * 或者下个时间事件到达（如果有的话）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 flags 为 0 ，那么函数不作动作，直接返回。</span></span><br><span class="line"><span class="comment"> * 如果 flags 包含 AE_ALL_EVENTS ，所有类型的事件都会被处理。</span></span><br><span class="line"><span class="comment"> * 如果 flags 包含 AE_FILE_EVENTS ，那么处理文件事件。</span></span><br><span class="line"><span class="comment"> * 如果 flags 包含 AE_TIME_EVENTS ，那么处理时间事件。</span></span><br><span class="line"><span class="comment"> * 如果 flags 包含 AE_DONT_WAIT ， 那么函数在处理完所有不许阻塞的事件之后，即刻返回。</span></span><br><span class="line"><span class="comment"> * 函数的返回值为已处理事件的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nothing to do? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note that we want call select() even if there are no</span></span><br><span class="line"><span class="comment">     * file events to process as long as we want to process time</span></span><br><span class="line"><span class="comment">     * events, in order to sleep until the next time event is ready</span></span><br><span class="line"><span class="comment">     * to fire. */</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> tv, *tvp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最近的时间事件</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</span><br><span class="line">            shortest = <span class="built_in">aeSearchNearestTimer</span>(eventLoop);</span><br><span class="line">        <span class="keyword">if</span> (shortest) &#123;</span><br><span class="line">            <span class="comment">// 如果时间事件存在的话</span></span><br><span class="line">            <span class="comment">// 那么根据最近可执行时间事件和现在时间的时间差来决定文件事件的阻塞时间</span></span><br><span class="line">            <span class="type">long</span> now_sec, now_ms;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算距今最近的时间事件还要多久才能达到</span></span><br><span class="line">            <span class="comment">// 并将该时间距保存在 tv 结构中</span></span><br><span class="line">            <span class="built_in">aeGetTime</span>(&amp;now_sec, &amp;now_ms);</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line">            tvp-&gt;tv_sec = shortest-&gt;when_sec - now_sec;</span><br><span class="line">            <span class="keyword">if</span> (shortest-&gt;when_ms &lt; now_ms) &#123;</span><br><span class="line">                tvp-&gt;tv_usec = ((shortest-&gt;when_ms+<span class="number">1000</span>) - now_ms)*<span class="number">1000</span>;</span><br><span class="line">                tvp-&gt;tv_sec --;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tvp-&gt;tv_usec = (shortest-&gt;when_ms - now_ms)*<span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 时间差小于 0 ，说明事件已经可以执行了，将秒和毫秒设为 0 （不阻塞）</span></span><br><span class="line">            <span class="keyword">if</span> (tvp-&gt;tv_sec &lt; <span class="number">0</span>) tvp-&gt;tv_sec = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (tvp-&gt;tv_usec &lt; <span class="number">0</span>) tvp-&gt;tv_usec = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 执行到这一步，说明没有时间事件</span></span><br><span class="line">            <span class="comment">// 那么根据 AE_DONT_WAIT 是否设置来决定是否阻塞，以及阻塞的时间长度</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If we have to check for events but need to return</span></span><br><span class="line"><span class="comment">             * ASAP because of AE_DONT_WAIT we need to set the timeout</span></span><br><span class="line"><span class="comment">             * to zero */</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">                <span class="comment">// 设置文件事件不阻塞</span></span><br><span class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">                tvp = &amp;tv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Otherwise we can block */</span></span><br><span class="line">                <span class="comment">// 文件事件可以阻塞直到有事件到达为止</span></span><br><span class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理文件事件，阻塞时间由 tvp 决定</span></span><br><span class="line">        numevents = <span class="built_in">aeApiPoll</span>(eventLoop, tvp);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="comment">// 从已就绪数组中获取事件</span></span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="type">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="type">int</span> rfired = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* note the fe-&gt;mask &amp; mask &amp; ... code: maybe an already processed</span></span><br><span class="line"><span class="comment">             * event removed an element that fired and we still didn&#x27;t</span></span><br><span class="line"><span class="comment">             * processed, so we check if the event is still valid. */</span></span><br><span class="line">            <span class="comment">// 读事件</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                <span class="comment">// rfired 确保读/写事件只能执行其中一个</span></span><br><span class="line">                rfired = <span class="number">1</span>;</span><br><span class="line">                fe-&gt;<span class="built_in">rfileProc</span>(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写事件</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rfired || fe-&gt;wfileProc != fe-&gt;rfileProc)</span><br><span class="line">                    fe-&gt;<span class="built_in">wfileProc</span>(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行时间事件</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        processed += <span class="built_in">processTimeEvents</span>(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取可执行事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">struct</span> timeval *tvp)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="type">int</span> retval, numevents = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 等待时间</span></span><br><span class="line">    retval = <span class="built_in">epoll_wait</span>(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,</span><br><span class="line">            tvp ? (tvp-&gt;tv_sec*<span class="number">1000</span> + tvp-&gt;tv_usec/<span class="number">1000</span>) : <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有至少一个事件就绪？</span></span><br><span class="line">    <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="comment">// 为已就绪事件设置相应的模式</span></span><br><span class="line">        <span class="comment">// 并加入到 eventLoop 的 fired 数组中</span></span><br><span class="line">        numevents = retval;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="type">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">epoll_event</span> *e = state-&gt;events+j;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE;</span><br><span class="line">            </span><br><span class="line">            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;</span><br><span class="line">            eventLoop-&gt;fired[j].mask = mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回已就绪事件个数</span></span><br><span class="line">    <span class="keyword">return</span> numevents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面代码可知，因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件了。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>redis数据结构附录</title>
    <url>/posts/968120137.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本次对上一次的数据结构知识进行补充，主要有redis数据结构的相关应用场景和内存相关知识</p>
<span id="more"></span>

<h1 id="引用计数-内存"><a href="#引用计数-内存" class="headerlink" title="引用计数-内存"></a>引用计数-内存</h1><p>redis中的对象回收机制是采用引用计数的方式，首先我们可以通过redis对象结构体代码可知</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Redis 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisObject</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">	...</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649488845659.png" alt="1649488845659"></p>
<p>上面表格是和引用计数字段相关的api</p>
<h1 id="引用计数-共享"><a href="#引用计数-共享" class="headerlink" title="引用计数-共享"></a>引用计数-共享</h1><p>我们知道引用计数可以实现对象内存什么时候销毁，那么引用计数也可以用来对象共享</p>
<p>比如此时有一个对象A，值为10，新建了一个对象B，值和类型都与A一样，则可以让他们指向同一个地址，然后引用计数+1</p>
<p>注意：redis初始化时候，会自动创建10000个字符串对象，包括0-9999这10000个整数，当服务器要用到这些数字的字符串对象时候，redis就不需要重新创建。（可以修改<code>redis.h/REDIS_SHARED_INTEGERS</code>进行修改）</p>
<blockquote>
<p>redis&gt; set A 100<br>OK</p>
<p>redis&gt; OBJECT REFCOUNT A<br>(integer) 2</p>
</blockquote>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>redis由于有多种数据结构，每种数据结构都有着不同的api和对应的时间复杂度，因此在实际工作或者项目开发中，应该面对不同场景选择不同的redis数据结构，因为自己在字节工作，会常常使用redis，下面根据自己平时的一些总结进行阐述，这个部分会持续更新</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>redis数据结构</title>
    <url>/posts/2882215823.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>从本次开始，对Redis设计与实现进行阅读及相关读书笔记的记录。Redis版本为3.0</p>
<span id="more"></span>

<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="简单动态字符串SDS"><a href="#简单动态字符串SDS" class="headerlink" title="简单动态字符串SDS"></a>简单动态字符串SDS</h2><p><code>sds</code>数据结构位于<code>sds.h/sdshdr</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存字符串对象的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sdshdr</span> &#123;</span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度</span></span><br><span class="line">    <span class="type">int</span> free;</span><br><span class="line">    <span class="comment">// 数据空间</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相对于C语言的字符串，SDS的优点在于</p>
<ul>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少修改字符串所带来的内存重新分配（注意，释放空间时候，不会真的释放，而是设置free的值）</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表的相关代码在<code>adlist.h</code>中</p>
<p>链表节点<code>listNode</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">listNode</span> &#123;</span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">listNode</span> *prev;</span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">listNode</span> *next;</span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>由多个<code>listNode</code>组成的双端链表</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331111939637.png" alt="image-20220331111939637"></p>
<p>链表结构<code>list</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">list</span> &#123;</span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="built_in">void</span> (*free)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="built_in">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure>

<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331112050968.png" alt="image-20220331112050968"></p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p><code>redis</code>中的字典使用哈希表实现，其代码在<code>dict.h</code>中</p>
<p>哈希表结构<code>dictht</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 哈希表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每个字典都使用两个哈希表，从而实现渐进式 rehash 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dictht</span> &#123;</span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;    </span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1 比如7号，当计算索引时候， 7&amp;sizemask就可以得到</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p>其中<code>dictEntry</code>为一个键值对</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 哈希表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dictEntry</span> &#123;    </span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表 表明是一个链地址法解决哈希冲突</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dictEntry</span> *next;</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p>下面为了形象表示一个哈希表，给出一个例子</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331112501821.png" alt="image-20220331112501821"></p>
<p>下面给出一个多个<code>dictEntry</code>连接的哈希表</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331113154852.png" alt="image-20220331113154852"></p>
<p>最终<code>Redis</code>中的字典数据结构如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字典</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dict</span> &#123;</span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="type">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="comment">// 目前正在运行的安全迭代器的数量</span></span><br><span class="line">    <span class="type">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字典类型特定函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dictType</span> &#123;</span><br><span class="line">    <span class="comment">// 计算哈希值的函数 redis默认的函数算法为murmurhash2</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="built_in">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="built_in">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);  </span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="built_in">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>

<h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>redis中的跳跃表结构代码为<code>redis.h/zskiplistNode</code>和<code>redis.h/zskiplist</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> &#123;</span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 分值 注意redis跳跃表按照节点从小到大排列</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> *backward;</span><br><span class="line">    <span class="comment">// 层 数组大小按照幂次定律（越大的数出现概率越小）1-32随机数字</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">zskiplistLevel</span> &#123;</span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> *forward;</span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zskiplist</span> &#123;</span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> *header, *tail;</span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p>下面给出一个简单的跳跃表例子</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331153438053.png" alt="image-20220331153438053"></p>
<p>前进指针用于遍历跳跃表，下面的虚线为遍历过程</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331154118201.png" alt="image-20220331154118201"></p>
<h2 id="整数集合-intset"><a href="#整数集合-intset" class="headerlink" title="整数集合 intset"></a>整数集合 <code>intset</code></h2><p>当一个集合里面只有整数值元素时候，且元素数量不超过<code>REDIS_SET_MAX_INTSET_ENTRIES</code>时候，集合底层采用整数集合</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_SET_MAX_INTSET_ENTRIES 512 <span class="comment">/*集合中元素个数小于该值，set底层使用intset*/</span></span></span><br></pre></td></tr></table></figure>

<p>redis中整数集合代码位于<code>intset.h/intset</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">intset</span> &#123;   </span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 保存元素的数组 按照从小到大的顺序，且不重复</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p><code>contents</code>数组虽然是<code>int8_t</code>，但是里面存放的数据的真实类型由<code>encoding</code>字段决定</p>
<ul>
<li>升级操作</li>
</ul>
<p>假如往下面的整数集合中append类型为int32的65535，则会发生升级，升级的过程主要包括将每个元素所占空间进行扩充，然后设置encoding，升级完后为</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331171012782.png" alt="image-20220331171012782"></p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331171213794.png" alt="image-20220331171213794"></p>
<ul>
<li>降级操作</li>
</ul>
<p>注意整数集合无法进行降级，升级之后，会一直持续该编码</p>
<h2 id="压缩列表-ziplist"><a href="#压缩列表-ziplist" class="headerlink" title="压缩列表 ziplist"></a>压缩列表 <code>ziplist</code></h2><p>压缩列表其实就是一块连续内存，一个压缩列表包括多个节点（entry），每个entry保存一个字节数组或者整数值。在redis源码中， 压缩列表没有数据结构代码定义，压缩列表是一种通过内存特殊编码方式实现的数据结构。他是通过定义一些基地址，然后使用偏移量来定义ziplist，其中大量使用了宏函数定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ziplist 属性宏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 定位到 ziplist 的 bytes 属性，该属性记录了整个 ziplist 所占用的内存字节数</span></span><br><span class="line"><span class="comment">// 用于取出 bytes 属性的现有值，或者为 bytes 属性赋予新值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</span></span><br><span class="line"><span class="comment">// 定位到 ziplist 的 offset 属性，该属性记录了到达表尾节点的偏移量</span></span><br><span class="line"><span class="comment">// 用于取出 offset 属性的现有值，或者为 offset 属性赋予新值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span></span><br><span class="line"><span class="comment">// 定位到 ziplist 的 length 属性，该属性记录了 ziplist 包含的节点数量</span></span><br><span class="line"><span class="comment">// 用于取出 length 属性的现有值，或者为 length 属性赋予新值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</span></span><br><span class="line"><span class="comment">// 返回 ziplist 表头的大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span></span><br><span class="line"><span class="comment">// 返回指向 ziplist 第一个节点（的起始位置）的指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)</span></span><br><span class="line"><span class="comment">// 返回指向 ziplist 最后一个节点（的起始位置）的指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))</span></span><br><span class="line"><span class="comment">// 返回指向 ziplist 末端 ZIP_END （的起始位置）的指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649401630127.png" alt="1649401630127"></p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649401787641.png" alt="1649401787641"></p>
<p>其中，redis对entry使用了数据结构描述，如下代码<code>ziplist.c/zlentry</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存 ziplist 节点信息的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zlentry</span> &#123;</span><br><span class="line">    <span class="comment">// prevrawlen ：前置节点的长度</span></span><br><span class="line">    <span class="comment">// prevrawlensize ：编码 prevrawlen 所需的字节大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlensize, prevrawlen;</span><br><span class="line">    <span class="comment">// len ：当前节点值的长度</span></span><br><span class="line">    <span class="comment">// lensize ：编码 len 所需的字节大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lensize, len;</span><br><span class="line">    <span class="comment">// 当前节点 header 的大小</span></span><br><span class="line">    <span class="comment">// 等于 prevrawlensize + lensize</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headersize;</span><br><span class="line">    <span class="comment">// 当前节点值所使用的编码类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encoding;</span><br><span class="line">    <span class="comment">// 指向当前节点的指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure>

<ul>
<li>ziplist的创建</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new empty ziplist. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 创建并返回一个新的 ziplist </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ZIPLIST_HEADER_SIZE 是 ziplist 表头的大小</span></span><br><span class="line">    <span class="comment">// 1 字节是表末端 ZIP_END 的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bytes = ZIPLIST_HEADER_SIZE+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 为表头和表末端分配空间</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl = <span class="built_in">zmalloc</span>(bytes);</span><br><span class="line">    <span class="comment">// 初始化表属性</span></span><br><span class="line">    <span class="built_in">ZIPLIST_BYTES</span>(zl) = <span class="built_in">intrev32ifbe</span>(bytes);</span><br><span class="line">    <span class="built_in">ZIPLIST_TAIL_OFFSET</span>(zl) = <span class="built_in">intrev32ifbe</span>(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    <span class="built_in">ZIPLIST_LENGTH</span>(zl) = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置表末端</span></span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于压缩列表主要就是为了节约内存，因此对于不同的数据，其编码方式不一样，前面我们已经知道，entry中主要放字节数组和整数，下表给出两种数据不同长度时候的编码</p>
<div>            <!--块级封装-->
    <center>    <!--将图片和文字居中-->
    <img src="
https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649402330810.png"
         alt="无法显示图片时显示的文字"
         style="zoom:这里写图片的缩放百分比"/>
    <br>        <!--换行-->
    字节数组编码    <!--标题-->
    </center>
</div>

<div>            <!--块级封装-->
    <center>    <!--将图片和文字居中-->
    <img src="
https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649402910210.png"
         alt="无法显示图片时显示的文字"
         style="zoom:这里写图片的缩放百分比"/>
    <br>        <!--换行-->
    整数编码    <!--标题-->
    </center>
</div>

<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>本次首先对Redis的相关数据结构进行介绍。Redis对象主要分为5种：REDIS_STRING、REDIS_LIST、REDIS_HASH、REDIS_SET、REDIS_ZSET。下面首先给出Redis中对对象的代码表示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_STRING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_LIST 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_SET 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ZSET 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_HASH 4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_LRU_BITS 24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_LRU_CLOCK_MAX ((1<span class="string">&lt;&lt;REDIS_LRU_BITS)-1) /* Max value of obj-&gt;</span>lru */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_LRU_CLOCK_RESOLUTION 1000 <span class="comment">/* LRU clock resolution in ms */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisObject</span> &#123;</span><br><span class="line">    <span class="comment">// 类型   类型说明符      位域名：位域长度   标识type占4个二进制位 因为有可能不需要一个完整的字节</span></span><br><span class="line">    <span class="comment">// 1个字节8位</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 对象最后一次被访问的时间</span></span><br><span class="line">    <span class="type">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="comment">// 指向实际值的指针</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>首先看到有2个字段，为类型和编码，类型就是redis的5种类型，编码就是这个类型底层是用什么编码方式实现</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331110406889.png" alt="image-20220331110406889"></p>
<p>但实际上，Redis的内部并不只是这5种对象，对于上面5种对象，都有几种底层实现方式，下面给出各数据结构底层实现的对应方式</p>
<h2 id="REDIS-STRING"><a href="#REDIS-STRING" class="headerlink" title="REDIS_STRING"></a>REDIS_STRING</h2><p>​    REDIS_STRING表示redis中的字符串类型，其底层由以下三种实现方式</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331101805672.png" alt="image-20220331101805672"></p>
<h3 id="REDIS-ENCODING-INT"><a href="#REDIS-ENCODING-INT" class="headerlink" title="REDIS_ENCODING_INT"></a>REDIS_ENCODING_INT</h3><p>如果一个字符串对象保存的是整数值，且这个整数值可以用long类型表示，则字符串对象会奖整数值保存在字符串对象的ptr属性中，此时会将ptr的void*转换为long</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set number &quot;1&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding number</span><br><span class="line">&quot;int&quot;</span><br></pre></td></tr></table></figure>

<h3 id="REDIS-ENCODING-RAW"><a href="#REDIS-ENCODING-RAW" class="headerlink" title="REDIS_ENCODING_RAW"></a>REDIS_ENCODING_RAW</h3><p>​    如果字符串保存的是一个字符串值，且长度大于32字节，redis的字符串对象就会采用简单动态字符串（SDS）实现</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set longstr &quot;Hello, my name is Shi Linkun, is a programmer who loves code, I hope that each blog can let myself consolidate their knowledge, but also let everyone get a little knowledge, thank you&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding longstr</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure>

<p>这里先不对SDS进行详细简介，后续单独对其进行描述</p>
<h3 id="REDIS-ENCODING-EMBSTR"><a href="#REDIS-ENCODING-EMBSTR" class="headerlink" title="REDIS_ENCODING_EMBSTR"></a>REDIS_ENCODING_EMBSTR</h3><p>如果字符串对象保存的是一个字符串，且长度小于等于32字节，则使用embstr编码实现</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set story &quot;hello my name is shilinkun&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding story</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>

<p>注意redis3.0版本中实际间隔为39字节</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ENCODING_EMBSTR_SIZE_LIMIT 39</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= REDIS_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">createEmbeddedStringObject</span>(ptr,len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">createRawStringObject</span>(ptr,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么是39字节，这里参考这个<a href="https://www.zhihu.com/question/25624589">知乎</a>的解释</p>
<p>embstr是一块连续的内存区域，由redisObject和sdshdr组成。其中redisObject占16个字节，当buf内的字符串长度是39时，sdshdr的大小为8+39+1&#x3D;48，那一个字节是’\0’。加起来刚好64。是不是发现了什么？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从2.4版本开始，redis开始使用jemalloc内存分配器。这个比glibc的malloc要好不少，还省内存。在这里可以简单理解，jemalloc会分配8，16，32，64等字节的内存。embstr最小为16+8+8+1&#x3D;33，所以最小分配64字节。当字符数小于39时，都会分配64字节。</p>
</blockquote>
<h3 id="三个编码的转换"><a href="#三个编码的转换" class="headerlink" title="三个编码的转换"></a>三个编码的转换</h3><ul>
<li><p>int-&gt;raw</p>
<p>  向一个保存整数数值的字符串对象使用APPEND命令，就会使得int转变为raw</p>
</li>
<li><p>embstr-&gt;raw</p>
<p>  对embstr类型的字符串，执行任何的修改命令，都会变为raw</p>
</li>
</ul>
<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><p>字符串命令的实现在t_string.c中</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331110234918.png" alt="image-20220331110234918"></p>
<h2 id="REDIS-LIST"><a href="#REDIS-LIST" class="headerlink" title="REDIS_LIST"></a>REDIS_LIST</h2><p>列表对象底层主要由2种编码方式：REDIS_ENCODING_ZIPLIST、REDIS_ENCODING_LINKEDLIST</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331110752306.png" alt="image-20220331110752306"></p>
<h3 id="REDIS-ENCODING-ZIPLIST"><a href="#REDIS-ENCODING-ZIPLIST" class="headerlink" title="REDIS_ENCODING_ZIPLIST"></a>REDIS_ENCODING_ZIPLIST</h3><p>ziplist是指使用压缩列表实现</p>
<h3 id="REDIS-ENCODING-LINKLIST"><a href="#REDIS-ENCODING-LINKLIST" class="headerlink" title="REDIS_ENCODING_LINKLIST"></a>REDIS_ENCODING_LINKLIST</h3><p>linklist是使用双端链表实现</p>
<h3 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h3><p><code>redis.h</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_LIST_MAX_ZIPLIST_ENTRIES 512 <span class="comment">/*list中元素个数小于该值，list底层使用ziplist*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_LIST_MAX_ZIPLIST_VALUE 64 <span class="comment">/*list中所有的字符串长度小于该值，list底层使用ziplist*/</span></span></span><br></pre></td></tr></table></figure>

<p>上述两个宏定义分别与redis的配置文件中<code>list-max-ziplist-entries</code>和<code>list-max-ziplist-value</code>对应</p>
<h2 id="REDIS-HASH"><a href="#REDIS-HASH" class="headerlink" title="REDIS_HASH"></a>REDIS_HASH</h2><p>哈希对象主要有2种编码方式，<code>REDIS_ENCODING_ZIPLIST</code>和<code>REDIS_ENCODING_HT</code></p>
<h3 id="REDIS-ENCODING-ZIPLIST-1"><a href="#REDIS-ENCODING-ZIPLIST-1" class="headerlink" title="REDIS_ENCODING_ZIPLIST"></a>REDIS_ENCODING_ZIPLIST</h3><p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649403963758.png" alt="1649403963758"></p>
<p>ziplist作为底层实现，先放入键，后放入值</p>
<h3 id="REDIS-ENCODING-HT"><a href="#REDIS-ENCODING-HT" class="headerlink" title="REDIS_ENCODING_HT"></a>REDIS_ENCODING_HT</h3><p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649404264852.png" alt="1649404264852"></p>
<h3 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_HASH_MAX_ZIPLIST_ENTRIES 512 <span class="comment">//哈希对象保存的键值对数量小于512个，使用ziplist;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_HASH_MAX_ZIPLIST_VALUE 64 <span class="comment">//哈希对象保存的所有键值对的键和值的字符串长度都小于64字节,使用ziplist;</span></span></span><br></pre></td></tr></table></figure>

<p>上述两个宏定义分别与redis的配置文件中<code>hash-max-ziplist-entries</code>和<code>hash-max-ziplist-value</code>对应</p>
<h2 id="REDIS-SET"><a href="#REDIS-SET" class="headerlink" title="REDIS_SET"></a>REDIS_SET</h2><p>集合的底层编码方式也是两种：<code>REDIS_ENCODING_INTSET</code>和<code>REDIS_ENCODING_HT</code></p>
<h3 id="REDIS-ENCODING-INTSET"><a href="#REDIS-ENCODING-INTSET" class="headerlink" title="REDIS_ENCODING_INTSET"></a>REDIS_ENCODING_INTSET</h3><p>使用该编码方式作为集合的底层实现时候，一般是整数集合，比如</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649404584469.png" alt="1649404584469"></p>
<h3 id="REDIS-ENCODING-HT-1"><a href="#REDIS-ENCODING-HT-1" class="headerlink" title="REDIS_ENCODING_HT"></a>REDIS_ENCODING_HT</h3><p>使用哈希表作为集合的底层实现方式时，所有的值作为键，但对应的值为null</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649404635934.png" alt="1649404635934"></p>
<h3 id="编码转换-2"><a href="#编码转换-2" class="headerlink" title="编码转换"></a>编码转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_SET_MAX_INTSET_ENTRIES 512 <span class="comment">/*集合中元素个数小于该值，且全为整数，set底层使用intset*/</span></span></span><br></pre></td></tr></table></figure>

<p>对应的redis配置文件选项为<code>set-max-intset-entries</code></p>
<h2 id="REDIS-ZSET"><a href="#REDIS-ZSET" class="headerlink" title="REDIS_ZSET"></a>REDIS_ZSET</h2><p>有序集合底层实现为：<code>REDIS_ENCODING_ZIPLIST</code>和<code>REDIS_ENCODING_SKIPLIST</code></p>
<h3 id="REDIS-ENCODING-ZIPLIST-2"><a href="#REDIS-ENCODING-ZIPLIST-2" class="headerlink" title="REDIS_ENCODING_ZIPLIST"></a>REDIS_ENCODING_ZIPLIST</h3><p>当使用压缩列表作为有序集合的底层实现时候，压缩列表的entry有2个值，一个是值，一个是得分，同时按照得分由小到大进行排列</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649404859400.png" alt="1649404859400"></p>
<h3 id="REDIS-ENCODING-SKIPLIST"><a href="#REDIS-ENCODING-SKIPLIST" class="headerlink" title="REDIS_ENCODING_SKIPLIST"></a>REDIS_ENCODING_SKIPLIST</h3><p>当使用跳跃表进行底层实现时候，一个有序集合同时包括：</p>
<ul>
<li>一个跳跃表</li>
<li>一个字典</li>
</ul>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649404927877.png" alt="1649404927877"></p>
<blockquote>
<p>为什么有序集合需要同时使用跳跃表和字典来实现?</p>
<p>在理论上，有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现，但无论单独使用字典还是跳跃表，在性能上对比起同时使用字典和跳跃表都会有所降低。举个例子，如果我们只使用字典来实现有序集合，那么虽然以O(1)复杂度查找成员的分值这一特性会被保留，但是，因为字典以无序的方式来保存集合元素，所以每次在执行范围型操作——比如ZRANK、ZRANGE等命令时，程序都需要对字典保存的所有元素进行排序，完成这种排序需要至少O(NlogN)时间复杂度，以及额外的O(N)内存空间（因为要创建一个数组来保存排序后的元素)。</p>
<p>另一方面，如果我们只使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O(1)上升为O(logN)。因为以上原因，为了让有序集合的查找和范围型操作都尽可能快地执行，Redis 选择了同时使用字典和跳跃表两种数据结构来实现有序集合。</p>
</blockquote>
<h3 id="编码转换-3"><a href="#编码转换-3" class="headerlink" title="编码转换"></a>编码转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ZSET_MAX_ZIPLIST_ENTRIES 128 <span class="comment">/*有序集合中元素个数小于该值，zset底层使用ziplist*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ZSET_MAX_ZIPLIST_VALUE 64 <span class="comment">/*有序集合中元素长度小于该值，zset底层使用ziplist*/</span></span></span><br></pre></td></tr></table></figure>

<p>上述两个宏定义分别与redis的配置文件中<code>zset-max-ziplist-entries</code>和<code>zset-max-ziplist-value</code>对应</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一次把redis的数据结构和对应的对象实现方式大致说了一遍，最重要的还是什么时候使用什么数据结构，并且各种数据结构一些命令的时间复杂度等，这些其实还没有进行阐述，后面会单独开一章进行讲解，因为在实际项目中，我们要针对不同场景对数据结构进行选取</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo源码分析之回调模块</title>
    <url>/posts/3047269001.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<p>这次我们主要来说说<code>muduo</code>库中大量使用的回调机制。<code>muduo</code>主要使用的是利用<code>Callback</code>的方式来实现回调，首先我们在自己的<code>EchoServer</code>构造函数中有这样几行代码</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">EchoServer</span>(EventLoop *loop,</span><br><span class="line">        <span class="type">const</span> InetAddress &amp;addr, </span><br><span class="line">        <span class="type">const</span> std::string &amp;name)</span><br><span class="line">    : <span class="built_in">server_</span>(loop, addr, name)</span><br><span class="line">    , <span class="built_in">loop_</span>(loop)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注册回调函数</span></span><br><span class="line">    server_.<span class="built_in">setConnectionCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;EchoServer::onConnection, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    server_.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;EchoServer::onMessage, <span class="keyword">this</span>,</span><br><span class="line">            std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置合适的loop线程数量 loopthread</span></span><br><span class="line">    server_.<span class="built_in">setThreadNum</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了<code>setConnectionCallback</code>和<code>setMessageCallback</code>，我们去看下<code>TcpServer</code>对<code>setConnectionCallback</code>怎么实现的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setConnectionCallback</span><span class="params">(<span class="type">const</span> ConnectionCallback &amp;cb)</span> </span>&#123; connectionCallback_ = cb; &#125;</span><br></pre></td></tr></table></figure>
<p>这样当有新的连接建立时候，就会执行我们设置的<code>EchoServer::onConnection</code>，这样我们就给<code>TcpServer</code>设置了一个回调函数，同时当<code>TcpServer</code>中的<code>Acceptor</code>接受到一个新的连接，<code>TcpServer</code>就会去用这个<code>connfd</code>和对应的<code>peerAddr</code>建立一个新的<code>TcpConnection</code>，同时<code>TcpServer</code>会给这个<code>TcpConnection</code>设置一个回调，而这个回调就是我们给<code>TcpServer</code>设置的回调</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 根据连接成功的sockfd,创建TcpConnection</span></span><br><span class="line">   <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(</span></span></span><br><span class="line"><span class="params"><span class="function">                           ioLoop,</span></span></span><br><span class="line"><span class="params"><span class="function">                           connName,</span></span></span><br><span class="line"><span class="params"><span class="function">                           sockfd,   <span class="comment">// Socket Channel</span></span></span></span><br><span class="line"><span class="params"><span class="function">                           localAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                           peerAddr))</span></span>;</span><br><span class="line">   connections_[connName] = conn;</span><br><span class="line"><span class="comment">// 下面的回调时用户设置给TcpServer，TcpServer又设置给TcpConnection，TcpConnetion又设置给Channel，Channel又设置给Poller，Poller通知channel调用这个回调</span></span><br><span class="line">   conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">   conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">   conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br></pre></td></tr></table></figure>

<p>当已经建立的连接有新消息来的时候，<code>conn-&gt;setMessageCallback(messageCallback_);</code>这一行代码表示我们给这个<code>conn</code>设置了一个有消息来的时候回调，我们去看下<code>TcpConnection</code>中对<code>setMessageCallback</code>是怎么处理的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setConnectionCallback</span><span class="params">(<span class="type">const</span> ConnectionCallback&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123; connectionCallback_ = cb; &#125;</span><br></pre></td></tr></table></figure>
<p>所以有消息来的时候，就会执行我们所设置的回调函数<code>onMessage</code>。到这里我么就基本知道新连接的建立和旧连接的消息到来应该做什么，下一章我们说一下消息之间发送的<code>Buffer</code>类。</p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo源码分析之TcpServer模块</title>
    <url>/posts/335272509.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<p>这次我们开始<code>muduo</code>源代码的实际编写，首先我们知道<code>muduo</code>是<code>LT</code>模式，<code>Reactor</code>模式，下图为<code>Reactor</code>模式的流程图[来源1]</p>
<span id="more"></span>

<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220220154310731.png" alt="image-20220220154310731"></p>
<p>然后我们来看下<code>muduo</code>的整体架构[来源1]</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20210422204939773.png" alt="muduo"></p>
<p>首先<code>muduo</code>有一个主反应堆<code>mainReactor</code>以及几个子反应堆<code>subReactor</code>，其中子反应堆的个数由用户使用<code>setThreadNum</code>函数设置，<code>mainReactor</code>中主要有一个<code>Acceptor</code>，当用户建立新的连接的时候，<code>Acceptor</code>会将<code>connfd</code>和对应的事件打包为一个<code>channel</code>然后采用轮询的算法，指定将该<code>channel</code>给所选择的<code>subReactor</code>，以后该<code>subReactor</code>就负责该<code>channel</code>的所有工作。</p>
<h1 id="TcpServer类"><a href="#TcpServer类" class="headerlink" title="TcpServer类"></a>TcpServer类</h1><p>我们按照从上到下的思路进行讲解，以下内容我们按照一个简单的<code>EchoServer</code>的实现思路来讲解，我们知道当我们自己实现一个<code>Server</code>的时候，会在构造函数中实例化一个<code>TcpServer</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">EchoServer</span>(EventLoop *loop,</span><br><span class="line">           <span class="type">const</span> InetAddress &amp;addr, </span><br><span class="line">           <span class="type">const</span> std::string &amp;name)</span><br><span class="line">    : <span class="built_in">server_</span>(loop, addr, name)</span><br><span class="line">        , <span class="built_in">loop_</span>(loop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注册回调函数</span></span><br><span class="line">        server_.<span class="built_in">setConnectionCallback</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onConnection, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        server_.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onMessage, <span class="keyword">this</span>,</span><br><span class="line">                      std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置合适的loop线程数量 loopthread 不包括baseloop</span></span><br><span class="line">        server_.<span class="built_in">setThreadNum</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>于是我们去看下<code>TcpServer</code>的构造函数是在干什么</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TcpServer::<span class="built_in">TcpServer</span>(EventLoop *loop,</span><br><span class="line">                <span class="type">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                <span class="type">const</span> std::string &amp;nameArg,</span><br><span class="line">                Option option)</span><br><span class="line">                : <span class="built_in">loop_</span>(<span class="built_in">CheckLoopNotNull</span>(loop))</span><br><span class="line">                , <span class="built_in">ipPort_</span>(listenAddr.<span class="built_in">toIpPort</span>())</span><br><span class="line">                , <span class="built_in">name_</span>(nameArg)</span><br><span class="line">                , <span class="built_in">acceptor_</span>(<span class="keyword">new</span> <span class="built_in">Acceptor</span>(loop, listenAddr, option == kReusePort))</span><br><span class="line">                , <span class="built_in">threadPool_</span>(<span class="keyword">new</span> <span class="built_in">EventLoopThreadPool</span>(loop, name_))</span><br><span class="line">                , <span class="built_in">connectionCallback_</span>()</span><br><span class="line">                , <span class="built_in">messageCallback_</span>()</span><br><span class="line">                , <span class="built_in">nextConnId_</span>(<span class="number">1</span>)</span><br><span class="line">                , <span class="built_in">started_</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当有新用户连接时候，会执行该回调函数</span></span><br><span class="line">    acceptor_-&gt;<span class="built_in">setNewConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::newConnection, <span class="keyword">this</span>, </span><br><span class="line">        std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只需要关注<code>acceptor_(new Acceptor(loop, listenAddr, option == kReusePort))</code>和<code>threadPool_(new EventLoopThreadPool(loop, name_))</code><br>首先很明确的一点，构造了一个<code>Acceptor</code>，我们首先要知道<code>Acceptor</code>主要就是连接新用户并打包为一个<code>Channel</code>，所以我们就应该知道<code>Acceptor</code>按道理应该实现<code>socket</code>，<code>bind</code>，<code>listen</code>，<code>accept</code>这四个函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Acceptor::<span class="built_in">Acceptor</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr, <span class="type">bool</span> reuseport)</span><br><span class="line">    : <span class="built_in">loop_</span>(loop), <span class="built_in">acceptSocket_</span>(<span class="built_in">createNonblocking</span>()) <span class="comment">// socket</span></span><br><span class="line">      ,</span><br><span class="line">      <span class="built_in">acceptChannel_</span>(loop, acceptSocket_.<span class="built_in">fd</span>()), <span class="built_in">listenning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    acceptSocket_.<span class="built_in">setReuseAddr</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">setReusePort</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">bindAddress</span>(listenAddr); <span class="comment">// 绑定套接字</span></span><br><span class="line">    <span class="comment">// 有新用户的连接，执行一个回调（打包为channel）</span></span><br><span class="line">    acceptChannel_.<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::handleRead, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>Acceptor</code>中有个<code>acceptSocket_</code>，其实就是我们平时所用的<code>listenfd</code>，构造函数中实现了<code>socket</code>，<code>bind</code>，而其余的两个函数的使用在其余代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启服务器监听</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 防止一个TcpServer被start多次</span></span><br><span class="line">    <span class="keyword">if</span> (started_++ == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        threadPool_-&gt;<span class="built_in">start</span>(threadInitCallback_); <span class="comment">// 启动底层的loop线程池,这里会按照设定了threadnum设置pool的数量</span></span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::listen, acceptor_.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道，当我们设置了<code>threadnum</code>之后，就会有一个<code>mainloop</code>，那么这个<code>loop_</code>就是那个<code>mainloop</code>，其中可以看见这个<code>loop_</code>就只做一个事情<code>Acceptor::listen</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listenning_ = <span class="literal">true</span>;</span><br><span class="line">    acceptSocket_.<span class="built_in">listen</span>();         <span class="comment">// listen</span></span><br><span class="line">    acceptChannel_.<span class="built_in">enableReading</span>(); <span class="comment">// acceptChannel_ =&gt; Poller</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里就实现了<code>listen</code>函数，还有最后一个函数<code>accept</code>，我们慢慢向下分析，从代码可以知道<code>acceptChannel_.enableReading()</code>之后就会使得这个<code>listenfd</code>所在的<code>channel</code>对读事件感兴趣，那什么时候会有读事件呢，就是当用户建立新连接的时候，那么我们应该想一下，那当感兴趣的事件发生之后，<code>listenfd</code>应该干什么呢，应该执行一个回调函数呀。注意<code>Acceptor</code>构造函数中有这样一行代码<code>acceptChannel_.setReadCallback(std::bind(&amp;Acceptor::handleRead, this));</code>这就是那个回调，我们去看下<code>handleRead</code>在干嘛。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// listenfd有事件发生了，就是有新用户连接了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InetAddress peerAddr;</span><br><span class="line">    <span class="type">int</span> connfd = acceptSocket_.<span class="built_in">accept</span>(&amp;peerAddr);</span><br><span class="line">    <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若用户实现定义了，则执行，否则说明用户对新到来的连接没有需要执行的，所以直接关闭</span></span><br><span class="line">        <span class="keyword">if</span> (newConnectionCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">newConnectionCallback_</span>(connfd, peerAddr); <span class="comment">// 轮询找到subLoop，唤醒，分发当前的新客户端的Channel</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ::<span class="built_in">close</span>(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是不是就实现了<code>accept</code>函数，至此当用户建立一个新的连接时候，<code>Acceptor</code>就会得到一个<code>connfd</code>和其对应的<code>peerAddr</code>返回给<code>mainloop</code>，这时候我们在注意到<code>TcpServer</code>构造函数中有这样一行代码<code>acceptor_-&gt;setNewConnectionCallback(std::bind(&amp;TcpServer::newConnection, this,std::placeholders::_1, std::placeholders::_2));</code>我们给<code>acceptor_</code>设置了一个<code>newConnectionCallback_</code>，于是由上面的代码就可以知道，<code>if (newConnectionCallback_)</code>为真，就会执行这个回调函数，于是就会执行<code>TcpServer::newConnection</code>，我们去看下这个函数是在干嘛。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress &amp;peerAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 轮询算法选择一个subloop来管理对应的这个新连接</span></span><br><span class="line">    EventLoop *ioLoop = threadPool_-&gt;<span class="built_in">getNextLoop</span>(); </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;-%s#%d&quot;</span>, ipPort_.<span class="built_in">c_str</span>(), nextConnId_);</span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    std::string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpServer::newConnection [%s] - new connection [%s] from %s \n&quot;</span>,</span><br><span class="line">        name_.<span class="built_in">c_str</span>(), connName.<span class="built_in">c_str</span>(), peerAddr.<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过sockfd获取其绑定的本地ip和端口</span></span><br><span class="line">    sockaddr_in local;</span><br><span class="line">    ::<span class="built_in">bzero</span>(&amp;local, <span class="keyword">sizeof</span> local);</span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span> local;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">getsockname</span>(sockfd, (sockaddr*)&amp;local, &amp;addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;sockets::getLocalAddr&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(local)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据连接成功的sockfd,创建TcpConnection</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(</span></span></span><br><span class="line"><span class="params"><span class="function">                            ioLoop,</span></span></span><br><span class="line"><span class="params"><span class="function">                            connName,</span></span></span><br><span class="line"><span class="params"><span class="function">                            sockfd,   <span class="comment">// Socket Channel</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            localAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                            peerAddr))</span></span>;</span><br><span class="line">    connections_[connName] = conn;</span><br><span class="line">	<span class="comment">// 下面的回调时用户设置给TcpServer，TcpServer又设置给TcpConnection，TcpConnetion又设置给Channel，Channel又设置给Poller，Poller通知channel调用这个回调</span></span><br><span class="line">    conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置了如何关闭连接的回调</span></span><br><span class="line">    conn-&gt;<span class="built_in">setCloseCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接调用connectEstablished</span></span><br><span class="line">    ioLoop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就比较长了，我先说下大概他干了啥事情：首先通过轮询找到下一个<code>subloop</code>，然后将刚刚返回的<code>connfd</code>和对应的<code>peerAddr</code>以及<code>localAddr</code>构造为一个<code>TcpConnection</code>给<code>subloop</code>，然后给这个<code>conn</code>设置了一系列的回调函数，比如读回调，写回调，断开回调等等。下一章我们来说下上面的代码最后几行在干嘛。</p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo源码分析之muduo简单运用</title>
    <url>/posts/713527548.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<p>今天不先实现<code>muduo</code>项目，我们先来看下<code>muduo</code>库的基本使用，只有了解了如何用，才能在写代码的时候知道自己写的找个函数是干嘛的，实际上是怎么使用的这个函数。首先说简单点，就是定义一个<code>Server</code>，设置两个回调函数</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回调连接相关的事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line"><span class="comment">// 回调读写事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, Buffer *buffer, Timestamp time)</span></span>;</span><br></pre></td></tr></table></figure>
<p>意思就是当有客户连接或者断开连接的时候，需要<code>Server</code>做什么，当连接上有读写事件发生时候，需要<code>Server</code>做什么。<br>比如一个<code>EchoServer</code>，当建立连接的时候，会自动调用<code>onConnection</code>函数，当比如我们发送一个消息时候，会自动调用<code>onMessage</code>函数。还有2个重要函数<code>loop</code>，<code>start</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">server.<span class="built_in">start</span>();</span><br><span class="line">loop.<span class="built_in">loop</span>();</span><br></pre></td></tr></table></figure>
<p>这里简答讲下这2个的区别，其实如果和<code>Epoll</code>做对比的话，<code>start</code>就相当于<code>epoll_create</code>，<code>loop</code>就相当于<code>epoll_wait</code>，后面再根据代码具体说明2个的区别。</br><br>以上就是基本的<code>muduo</code>使用，下一章就开始具体的<code>muduo</code>代码实现。</p>
<blockquote>
<p>自己的网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>欢迎加群聊天 452380935</p>
</blockquote>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo源码分析之Buffer</title>
    <url>/posts/620043534.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<p>这一次我们来分析下<code>muduo</code>中<code>Buffer</code>的作用，我们知道，当我们客户端向服务器发送数据时候，服务器就会读取我们发送的数据，然后进行一系列处理，然后再发送到其他地方，在这里我们想象一下最简单的<code>EchoServer</code>服务器，客户端建立一个连接，以后服务器和客户端之间的通信都是通过这个<code>connfd</code>发送和接受数据，于是每一个<code>connfd</code>都应该有一个自己<code>buffer</code>，当我们发送数据太快，服务器发送的太慢，则服务器会将待发送的数据这个<code>buffer</code>中，所以这就是这个类的作用。我们先看下<code>buffer</code>的结构是什么：</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/d2466fdf-c322-417a-9a80-2900d415d81d.png" alt="buffer1"></p>
<p>我们这里主要针对<code>connfd</code>这个对应的<code>channel</code>进行分析，首先上图是<code>buffer</code>的初始状态，前面<code>8</code>个字节中表示该<code>buffer</code>的大小，初始大小为<code>1024</code>。当客户端发送数据给服务器，同时若服务器接受缓慢，则会向<code>buffer</code>中开始写数据，则<code>writerIndex_</code>会向右移动，假如此时移动到如下形式：</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/10505139-a325-4e85-bea0-b845fad0fd51.png" alt="buffer2"></p>
<p>则此时缓冲区可以读的数据为<code>writerIndex_ - readerIndex_</code>，可以写的数据为<code>buffer_.size() - writerIndex_</code>。这时候当服务器有多余资源进行读操作，就可以去缓冲区读数据了，假如这时候的状态为如下：</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/c2fc3414-189b-41bf-b649-1c0ba90763e1.png" alt="buffer3"></p>
<p>这就是常见的几个状态，下面我们去看几个重点的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 把onMessage函数上报的buffer内容转为string</span></span><br><span class="line">  <span class="function">std::string <span class="title">retrieveAllAsString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">retrieveAsString</span>(<span class="built_in">readableBytes</span>()); <span class="comment">// 应用可读取数据的长度</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 可读的数据 就是存放的是即发送的数据</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">readableBytes</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> writerIndex_ - readerIndex_;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">std::string <span class="title">retrieveAsString</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"><span class="comment">// 从可读数据开始位置，长度为len的char构造为一个string</span></span><br><span class="line">      <span class="function">std::string <span class="title">result</span><span class="params">(peek(), len)</span></span>;</span><br><span class="line">      <span class="built_in">retrieve</span>(len); <span class="comment">// 上面一句把缓冲区中可读的数据，已经读取出来，这里肯定要对缓冲区进行复位操作</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将缓冲区len的长度进行复位</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">retrieve</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"><span class="comment">// 表示还没有读完数据</span></span><br><span class="line">      <span class="keyword">if</span> (len &lt; <span class="built_in">readableBytes</span>())</span><br><span class="line">      &#123;</span><br><span class="line">          readerIndex_ += len; <span class="comment">// 应用只读取了刻度缓冲区数据的一部分，就是len，还剩下readerIndex_ += len -&gt; writerIndex_</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>   <span class="comment">// len == readableBytes()</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">retrieveAll</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>以上是基本的操作，下面的2个函数很重要，一个是向<code>connfd</code>写数据，一个是读数据，对于一个<code>TcpConnection</code>而言，当有数据来的时候，回去调用<code>handleRead</code>回调函数。我们知道<code>muduo</code>设置的每次读取的大小为<code>65536</code>字节，当缓冲区可写的数据大小大于<code>65536</code>，就会直接将读到的数据写入到缓冲区中，但当缓冲区的可写数据大小小于<code>65536</code>的时候，就会将剩余数据先写到一个额外的空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::readFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> extrabuf[<span class="number">65536</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 栈上的内存空间  64K</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> vec[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 这是buffer可写的数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> writable = <span class="built_in">writableBytes</span>(); </span><br><span class="line">    vec[<span class="number">0</span>].iov_base = <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">    vec[<span class="number">0</span>].iov_len = writable;</span><br><span class="line"></span><br><span class="line">    vec[<span class="number">1</span>].iov_base = extrabuf;</span><br><span class="line">    vec[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span> extrabuf;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iovcnt = (writable &lt; <span class="keyword">sizeof</span> extrabuf) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 去百度下readv</span></span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> n = ::<span class="built_in">readv</span>(fd, vec, iovcnt);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= writable) <span class="comment">// Buffer的可写缓冲区已经够存储读出来的数据了</span></span><br><span class="line">    &#123;</span><br><span class="line">        writerIndex_ += n;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// extrabuf 也写了数据</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        writerIndex_ = buffer_.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">append</span>(extrabuf, n - writable);  <span class="comment">// writerIndex_开始写 n - writable大小的数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里巧妙的使用了一个<code>readv</code>函数，可以通过按照大小自动写到不同的地方。其中当<code>extrabuf</code>也写了数据，就会调用<code>append</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要写len长度的数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ensureWriteableBytes</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">makeSpace</span>(len); <span class="comment">// 扩容函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向缓冲区添加数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ensureWriteableBytes</span>(len);</span><br><span class="line">    std::<span class="built_in">copy</span>(data, data+len, <span class="built_in">beginWrite</span>());</span><br><span class="line">    writerIndex_ += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到有一个<code>makeSpace</code>函数，其中有一个注意点，比如当如下这种状态的时候：</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/c2fc3414-189b-41bf-b649-1c0ba90763e1.png" alt="buffer4"></p>
<p>此时<code>readerIndex_</code>前面有一部分其实已经被读完了，是空的数据，所以<code>makeSpace</code>函数考虑了这一点，采用内存重组的方式，将<code>readerIndex_</code>向前移动到<code>kCheapPrepend</code>处，然后就可以让空余的内存挨在一起</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeSpace</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() + <span class="built_in">prependableBytes</span>() &lt; len + kCheapPrepend)</span><br><span class="line">    &#123;</span><br><span class="line">        buffer_.<span class="built_in">resize</span>(writerIndex_ + len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> readalbe = <span class="built_in">readableBytes</span>();</span><br><span class="line">        std::<span class="built_in">copy</span>(<span class="built_in">begin</span>() + readerIndex_, </span><br><span class="line">                <span class="built_in">begin</span>() + writerIndex_,</span><br><span class="line">                <span class="built_in">begin</span>() + kCheapPrepend);</span><br><span class="line">        readerIndex_ = kCheapPrepend;</span><br><span class="line">        writerIndex_ = readerIndex_ + readalbe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当向<code>connfd</code>发送数据的时候就比较简单了，直接将可读的数据发送给出去就行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过fd发送数据</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::writeFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n = ::<span class="built_in">write</span>(fd, <span class="built_in">peek</span>(), <span class="built_in">readableBytes</span>());</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo项目介绍</title>
    <url>/posts/3331102393.html</url>
    <content><![CDATA[<blockquote>
<p>博客网址：<a href="http://www.shicoder.top/">www.shicoder.top</a><br>微信：18223081347<br>欢迎加群聊天 ：452380935</p>
</blockquote>
<p>在上一个<a href="https://juejin.cn/post/6950230361594920996"><strong>集群聊天服务器</strong></a>项目中，我使用了<code>muduo</code>作为网络库，然后主要实现了业务逻辑等，所以为了深入网络库的代码和实现，我跟着一位老师的代码去实现了<code>muduo</code>库的基本原理和作用，当然只是实现了主体的代码，有些细节便没有深究，以下是自己的目标:</p>
<ol>
<li>从开源C++ muduo网络库，学习优秀的代码设计</li>
<li>掌握基于事件驱动和事件回调的epoll+线程池面向对象编程</li>
<li>实现<code>TcpServer</code>、<code>TcpConnection</code>、<code>Poller</code>、<code>Chanel</code>等重要部分</li>
<li>重写muduo核心组件，去依赖boost，用C++11重构</li>
<li>测试代码是否成功</li>
</ol>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
