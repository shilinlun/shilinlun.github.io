<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于我自己</title>
    <url>/posts/404665547.html</url>
    <content><![CDATA[<p>这里先自我介绍下：</p>
<p>本人是一名在读的机械研三学生，转行到计算机，准备2022年7月入职字节，有想转行的同学可以加我QQ(153604363)，大家可以一起学习啦</p>
<span id="more"></span>

<h1 id="为什么做这个博客"><a href="#为什么做这个博客" class="headerlink" title="为什么做这个博客"></a>为什么做这个博客</h1><p>这个博客主要记录自己的后端学习记录和一些刷题记录，同时可能会写一些自己的心得感悟，也为自己后面学习有一个知识点仓库，因此可能博客的内容不那么专业，更多的是以我这个水平的同学之间参考</p>
<p>如果大家觉得博客内容还可以的，也希望可以帮忙转发给朋友啦。</p>
]]></content>
      <categories>
        <category>日记杂事</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>redis数据结构附录</title>
    <url>/posts/968120137.html</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本次对上一次的数据结构知识进行补充，主要有redis数据结构的相关应用场景和内存相关知识</p>
<h1 id="引用计数-内存"><a href="#引用计数-内存" class="headerlink" title="引用计数-内存"></a>引用计数-内存</h1><p>redis中的对象回收机制是采用引用计数的方式，首先我们可以通过redis对象结构体代码可知</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Redis 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisObject</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">	...</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\shi\AppData\Roaming\Typora\typora-user-images\1649488845659.png" alt="1649488845659"></p>
<p>上面表格是和引用计数字段相关的api</p>
<h1 id="引用计数-共享"><a href="#引用计数-共享" class="headerlink" title="引用计数-共享"></a>引用计数-共享</h1><p>我们知道引用计数可以实现对象内存什么时候销毁，那么引用计数也可以用来对象共享</p>
<p>比如此时有一个对象A，值为10，新建了一个对象B，值和类型都与A一样，则可以让他们指向同一个地址，然后引用计数+1</p>
<p>注意：redis初始化时候，会自动创建10000个字符串对象，包括0-9999这10000个整数，当服务器要用到这些数字的字符串对象时候，redis就不需要重新创建。（可以修改<code>redis.h/REDIS_SHARED_INTEGERS</code>进行修改）</p>
<blockquote>
<p>redis&gt; set A 100<br>OK</p>
<p>redis&gt; OBJECT REFCOUNT A<br>(integer) 2</p>
</blockquote>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>redis由于有多种数据结构，每种数据结构都有着不同的api和对应的时间复杂度，因此在实际工作或者项目开发中，应该面对不同场景选择不同的redis数据结构，因为自己在字节工作，会常常使用redis，下面根据自己平时的一些总结进行阐述，这个部分会持续更新</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>redis数据结构</title>
    <url>/posts/2882215823.html</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>从本次开始，对Redis设计与实现进行阅读及相关读书笔记的记录。Redis版本为3.0</p>
<span id="more"></span>

<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="简单动态字符串SDS"><a href="#简单动态字符串SDS" class="headerlink" title="简单动态字符串SDS"></a>简单动态字符串SDS</h2><p><code>sds</code>数据结构位于<code>sds.h/sdshdr</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存字符串对象的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sdshdr</span> &#123;</span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度</span></span><br><span class="line">    <span class="type">int</span> free;</span><br><span class="line">    <span class="comment">// 数据空间</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相对于C语言的字符串，SDS的优点在于</p>
<ul>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少修改字符串所带来的内存重新分配（注意，释放空间时候，不会真的释放，而是设置free的值）</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表的相关代码在<code>adlist.h</code>中</p>
<p>链表节点<code>listNode</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">listNode</span> &#123;</span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">listNode</span> *prev;</span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">listNode</span> *next;</span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>由多个<code>listNode</code>组成的双端链表</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331111939637.png" alt="image-20220331111939637"></p>
<p>链表结构<code>list</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">list</span> &#123;</span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="built_in">void</span> (*free)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="built_in">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure>

<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331112050968.png" alt="image-20220331112050968"></p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p><code>redis</code>中的字典使用哈希表实现，其代码在<code>dict.h</code>中</p>
<p>哈希表结构<code>dictht</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 哈希表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每个字典都使用两个哈希表，从而实现渐进式 rehash 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dictht</span> &#123;</span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;    </span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1 比如7号，当计算索引时候， 7&amp;sizemask就可以得到</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p>其中<code>dictEntry</code>为一个键值对</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 哈希表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dictEntry</span> &#123;    </span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表 表明是一个链地址法解决哈希冲突</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dictEntry</span> *next;</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p>下面为了形象表示一个哈希表，给出一个例子</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331112501821.png" alt="image-20220331112501821"></p>
<p>下面给出一个多个<code>dictEntry</code>连接的哈希表</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331113154852.png" alt="image-20220331113154852"></p>
<p>最终<code>Redis</code>中的字典数据结构如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字典</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dict</span> &#123;</span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="type">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="comment">// 目前正在运行的安全迭代器的数量</span></span><br><span class="line">    <span class="type">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字典类型特定函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dictType</span> &#123;</span><br><span class="line">    <span class="comment">// 计算哈希值的函数 redis默认的函数算法为murmurhash2</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="built_in">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="built_in">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);  </span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="built_in">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>

<h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>redis中的跳跃表结构代码为<code>redis.h/zskiplistNode</code>和<code>redis.h/zskiplist</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> &#123;</span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 分值 注意redis跳跃表按照节点从小到大排列</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> *backward;</span><br><span class="line">    <span class="comment">// 层 数组大小按照幂次定律（越大的数出现概率越小）1-32随机数字</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">zskiplistLevel</span> &#123;</span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> *forward;</span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zskiplist</span> &#123;</span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> *header, *tail;</span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p>下面给出一个简单的跳跃表例子</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331153438053.png" alt="image-20220331153438053"></p>
<p>前进指针用于遍历跳跃表，下面的虚线为遍历过程</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331154118201.png" alt="image-20220331154118201"></p>
<h2 id="整数集合-intset"><a href="#整数集合-intset" class="headerlink" title="整数集合 intset"></a>整数集合 <code>intset</code></h2><p>当一个集合里面只有整数值元素时候，且元素数量不超过<code>REDIS_SET_MAX_INTSET_ENTRIES</code>时候，集合底层采用整数集合</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_SET_MAX_INTSET_ENTRIES 512 <span class="comment">/*集合中元素个数小于该值，set底层使用intset*/</span></span></span><br></pre></td></tr></table></figure>

<p>redis中整数集合代码位于<code>intset.h/intset</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">intset</span> &#123;   </span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 保存元素的数组 按照从小到大的顺序，且不重复</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p><code>contents</code>数组虽然是<code>int8_t</code>，但是里面存放的数据的真实类型由<code>encoding</code>字段决定</p>
<ul>
<li>升级操作</li>
</ul>
<p>假如往下面的整数集合中append类型为int32的65535，则会发生升级，升级的过程主要包括将每个元素所占空间进行扩充，然后设置encoding，升级完后为</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331171012782.png" alt="image-20220331171012782"></p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331171213794.png" alt="image-20220331171213794"></p>
<ul>
<li>降级操作</li>
</ul>
<p>注意整数集合无法进行降级，升级之后，会一直持续该编码</p>
<h2 id="压缩列表-ziplist"><a href="#压缩列表-ziplist" class="headerlink" title="压缩列表 ziplist"></a>压缩列表 <code>ziplist</code></h2><p>压缩列表其实就是一块连续内存，一个压缩列表包括多个节点（entry），每个entry保存一个字节数组或者整数值。在redis源码中， 压缩列表没有数据结构代码定义，压缩列表是一种通过内存特殊编码方式实现的数据结构。他是通过定义一些基地址，然后使用偏移量来定义ziplist，其中大量使用了宏函数定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ziplist 属性宏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 定位到 ziplist 的 bytes 属性，该属性记录了整个 ziplist 所占用的内存字节数</span></span><br><span class="line"><span class="comment">// 用于取出 bytes 属性的现有值，或者为 bytes 属性赋予新值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</span></span><br><span class="line"><span class="comment">// 定位到 ziplist 的 offset 属性，该属性记录了到达表尾节点的偏移量</span></span><br><span class="line"><span class="comment">// 用于取出 offset 属性的现有值，或者为 offset 属性赋予新值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span></span><br><span class="line"><span class="comment">// 定位到 ziplist 的 length 属性，该属性记录了 ziplist 包含的节点数量</span></span><br><span class="line"><span class="comment">// 用于取出 length 属性的现有值，或者为 length 属性赋予新值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</span></span><br><span class="line"><span class="comment">// 返回 ziplist 表头的大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span></span><br><span class="line"><span class="comment">// 返回指向 ziplist 第一个节点（的起始位置）的指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)</span></span><br><span class="line"><span class="comment">// 返回指向 ziplist 最后一个节点（的起始位置）的指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))</span></span><br><span class="line"><span class="comment">// 返回指向 ziplist 末端 ZIP_END （的起始位置）的指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649401630127.png" alt="1649401630127"></p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649401787641.png" alt="1649401787641"></p>
<p>其中，redis对entry使用了数据结构描述，如下代码<code>ziplist.c/zlentry</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存 ziplist 节点信息的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zlentry</span> &#123;</span><br><span class="line">    <span class="comment">// prevrawlen ：前置节点的长度</span></span><br><span class="line">    <span class="comment">// prevrawlensize ：编码 prevrawlen 所需的字节大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlensize, prevrawlen;</span><br><span class="line">    <span class="comment">// len ：当前节点值的长度</span></span><br><span class="line">    <span class="comment">// lensize ：编码 len 所需的字节大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lensize, len;</span><br><span class="line">    <span class="comment">// 当前节点 header 的大小</span></span><br><span class="line">    <span class="comment">// 等于 prevrawlensize + lensize</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headersize;</span><br><span class="line">    <span class="comment">// 当前节点值所使用的编码类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encoding;</span><br><span class="line">    <span class="comment">// 指向当前节点的指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure>

<ul>
<li>ziplist的创建</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new empty ziplist. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 创建并返回一个新的 ziplist </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ZIPLIST_HEADER_SIZE 是 ziplist 表头的大小</span></span><br><span class="line">    <span class="comment">// 1 字节是表末端 ZIP_END 的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bytes = ZIPLIST_HEADER_SIZE+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 为表头和表末端分配空间</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl = <span class="built_in">zmalloc</span>(bytes);</span><br><span class="line">    <span class="comment">// 初始化表属性</span></span><br><span class="line">    <span class="built_in">ZIPLIST_BYTES</span>(zl) = <span class="built_in">intrev32ifbe</span>(bytes);</span><br><span class="line">    <span class="built_in">ZIPLIST_TAIL_OFFSET</span>(zl) = <span class="built_in">intrev32ifbe</span>(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    <span class="built_in">ZIPLIST_LENGTH</span>(zl) = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置表末端</span></span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于压缩列表主要就是为了节约内存，因此对于不同的数据，其编码方式不一样，前面我们已经知道，entry中主要放字节数组和整数，下表给出两种数据不同长度时候的编码</p>
<div>            <!--块级封装-->
    <center>    <!--将图片和文字居中-->
    <img src="
https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649402330810.png"
         alt="无法显示图片时显示的文字"
         style="zoom:这里写图片的缩放百分比"/>
    <br>        <!--换行-->
    字节数组编码    <!--标题-->
    </center>
</div>

<div>            <!--块级封装-->
    <center>    <!--将图片和文字居中-->
    <img src="
https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649402910210.png"
         alt="无法显示图片时显示的文字"
         style="zoom:这里写图片的缩放百分比"/>
    <br>        <!--换行-->
    整数编码    <!--标题-->
    </center>
</div>

<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>本次首先对Redis的相关数据结构进行介绍。Redis对象主要分为5种：REDIS_STRING、REDIS_LIST、REDIS_HASH、REDIS_SET、REDIS_ZSET。下面首先给出Redis中对对象的代码表示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_STRING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_LIST 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_SET 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ZSET 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_HASH 4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_LRU_BITS 24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_LRU_CLOCK_MAX ((1<span class="string">&lt;&lt;REDIS_LRU_BITS)-1) /* Max value of obj-&gt;</span>lru */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_LRU_CLOCK_RESOLUTION 1000 <span class="comment">/* LRU clock resolution in ms */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisObject</span> &#123;</span><br><span class="line">    <span class="comment">// 类型   类型说明符      位域名：位域长度   标识type占4个二进制位 因为有可能不需要一个完整的字节</span></span><br><span class="line">    <span class="comment">// 1个字节8位</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 对象最后一次被访问的时间</span></span><br><span class="line">    <span class="type">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="comment">// 指向实际值的指针</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>首先看到有2个字段，为类型和编码，类型就是redis的5种类型，编码就是这个类型底层是用什么编码方式实现</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331110406889.png" alt="image-20220331110406889"></p>
<p>但实际上，Redis的内部并不只是这5种对象，对于上面5种对象，都有几种底层实现方式，下面给出各数据结构底层实现的对应方式</p>
<h2 id="REDIS-STRING"><a href="#REDIS-STRING" class="headerlink" title="REDIS_STRING"></a>REDIS_STRING</h2><p>​    REDIS_STRING表示redis中的字符串类型，其底层由以下三种实现方式</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331101805672.png" alt="image-20220331101805672"></p>
<h3 id="REDIS-ENCODING-INT"><a href="#REDIS-ENCODING-INT" class="headerlink" title="REDIS_ENCODING_INT"></a>REDIS_ENCODING_INT</h3><p>如果一个字符串对象保存的是整数值，且这个整数值可以用long类型表示，则字符串对象会奖整数值保存在字符串对象的ptr属性中，此时会将ptr的void*转换为long</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set number &quot;1&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding number</span><br><span class="line">&quot;int&quot;</span><br></pre></td></tr></table></figure>

<h3 id="REDIS-ENCODING-RAW"><a href="#REDIS-ENCODING-RAW" class="headerlink" title="REDIS_ENCODING_RAW"></a>REDIS_ENCODING_RAW</h3><p>​    如果字符串保存的是一个字符串值，且长度大于32字节，redis的字符串对象就会采用简单动态字符串（SDS）实现</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set longstr &quot;Hello, my name is Shi Linkun, is a programmer who loves code, I hope that each blog can let myself consolidate their knowledge, but also let everyone get a little knowledge, thank you&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding longstr</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure>

<p>这里先不对SDS进行详细简介，后续单独对其进行描述</p>
<h3 id="REDIS-ENCODING-EMBSTR"><a href="#REDIS-ENCODING-EMBSTR" class="headerlink" title="REDIS_ENCODING_EMBSTR"></a>REDIS_ENCODING_EMBSTR</h3><p>如果字符串对象保存的是一个字符串，且长度小于等于32字节，则使用embstr编码实现</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set story &quot;hello my name is shilinkun&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding story</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>

<p>注意redis3.0版本中实际间隔为39字节</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ENCODING_EMBSTR_SIZE_LIMIT 39</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= REDIS_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">createEmbeddedStringObject</span>(ptr,len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">createRawStringObject</span>(ptr,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么是39字节，这里参考这个<a href="https://www.zhihu.com/question/25624589">知乎</a>的解释</p>
<p>embstr是一块连续的内存区域，由redisObject和sdshdr组成。其中redisObject占16个字节，当buf内的字符串长度是39时，sdshdr的大小为8+39+1&#x3D;48，那一个字节是’\0’。加起来刚好64。是不是发现了什么？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从2.4版本开始，redis开始使用jemalloc内存分配器。这个比glibc的malloc要好不少，还省内存。在这里可以简单理解，jemalloc会分配8，16，32，64等字节的内存。embstr最小为16+8+8+1&#x3D;33，所以最小分配64字节。当字符数小于39时，都会分配64字节。</p>
</blockquote>
<h3 id="三个编码的转换"><a href="#三个编码的转换" class="headerlink" title="三个编码的转换"></a>三个编码的转换</h3><ul>
<li><p>int-&gt;raw</p>
<p>  向一个保存整数数值的字符串对象使用APPEND命令，就会使得int转变为raw</p>
</li>
<li><p>embstr-&gt;raw</p>
<p>  对embstr类型的字符串，执行任何的修改命令，都会变为raw</p>
</li>
</ul>
<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><p>字符串命令的实现在t_string.c中</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331110234918.png" alt="image-20220331110234918"></p>
<h2 id="REDIS-LIST"><a href="#REDIS-LIST" class="headerlink" title="REDIS_LIST"></a>REDIS_LIST</h2><p>列表对象底层主要由2种编码方式：REDIS_ENCODING_ZIPLIST、REDIS_ENCODING_LINKEDLIST</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220331110752306.png" alt="image-20220331110752306"></p>
<h3 id="REDIS-ENCODING-ZIPLIST"><a href="#REDIS-ENCODING-ZIPLIST" class="headerlink" title="REDIS_ENCODING_ZIPLIST"></a>REDIS_ENCODING_ZIPLIST</h3><p>ziplist是指使用压缩列表实现</p>
<h3 id="REDIS-ENCODING-LINKLIST"><a href="#REDIS-ENCODING-LINKLIST" class="headerlink" title="REDIS_ENCODING_LINKLIST"></a>REDIS_ENCODING_LINKLIST</h3><p>linklist是使用双端链表实现</p>
<h3 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h3><p><code>redis.h</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_LIST_MAX_ZIPLIST_ENTRIES 512 <span class="comment">/*list中元素个数小于该值，list底层使用ziplist*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_LIST_MAX_ZIPLIST_VALUE 64 <span class="comment">/*list中所有的字符串长度小于该值，list底层使用ziplist*/</span></span></span><br></pre></td></tr></table></figure>

<p>上述两个宏定义分别与redis的配置文件中<code>list-max-ziplist-entries</code>和<code>list-max-ziplist-value</code>对应</p>
<h2 id="REDIS-HASH"><a href="#REDIS-HASH" class="headerlink" title="REDIS_HASH"></a>REDIS_HASH</h2><p>哈希对象主要有2种编码方式，<code>REDIS_ENCODING_ZIPLIST</code>和<code>REDIS_ENCODING_HT</code></p>
<h3 id="REDIS-ENCODING-ZIPLIST-1"><a href="#REDIS-ENCODING-ZIPLIST-1" class="headerlink" title="REDIS_ENCODING_ZIPLIST"></a>REDIS_ENCODING_ZIPLIST</h3><p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649403963758.png" alt="1649403963758"></p>
<p>ziplist作为底层实现，先放入键，后放入值</p>
<h3 id="REDIS-ENCODING-HT"><a href="#REDIS-ENCODING-HT" class="headerlink" title="REDIS_ENCODING_HT"></a>REDIS_ENCODING_HT</h3><p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649404264852.png" alt="1649404264852"></p>
<h3 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_HASH_MAX_ZIPLIST_ENTRIES 512 <span class="comment">//哈希对象保存的键值对数量小于512个，使用ziplist;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_HASH_MAX_ZIPLIST_VALUE 64 <span class="comment">//哈希对象保存的所有键值对的键和值的字符串长度都小于64字节,使用ziplist;</span></span></span><br></pre></td></tr></table></figure>

<p>上述两个宏定义分别与redis的配置文件中<code>hash-max-ziplist-entries</code>和<code>hash-max-ziplist-value</code>对应</p>
<h2 id="REDIS-SET"><a href="#REDIS-SET" class="headerlink" title="REDIS_SET"></a>REDIS_SET</h2><p>集合的底层编码方式也是两种：<code>REDIS_ENCODING_INTSET</code>和<code>REDIS_ENCODING_HT</code></p>
<h3 id="REDIS-ENCODING-INTSET"><a href="#REDIS-ENCODING-INTSET" class="headerlink" title="REDIS_ENCODING_INTSET"></a>REDIS_ENCODING_INTSET</h3><p>使用该编码方式作为集合的底层实现时候，一般是整数集合，比如</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649404584469.png" alt="1649404584469"></p>
<h3 id="REDIS-ENCODING-HT-1"><a href="#REDIS-ENCODING-HT-1" class="headerlink" title="REDIS_ENCODING_HT"></a>REDIS_ENCODING_HT</h3><p>使用哈希表作为集合的底层实现方式时，所有的值作为键，但对应的值为null</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649404635934.png" alt="1649404635934"></p>
<h3 id="编码转换-2"><a href="#编码转换-2" class="headerlink" title="编码转换"></a>编码转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_SET_MAX_INTSET_ENTRIES 512 <span class="comment">/*集合中元素个数小于该值，且全为整数，set底层使用intset*/</span></span></span><br></pre></td></tr></table></figure>

<p>对应的redis配置文件选项为<code>set-max-intset-entries</code></p>
<h2 id="REDIS-ZSET"><a href="#REDIS-ZSET" class="headerlink" title="REDIS_ZSET"></a>REDIS_ZSET</h2><p>有序集合底层实现为：<code>REDIS_ENCODING_ZIPLIST</code>和<code>REDIS_ENCODING_SKIPLIST</code></p>
<h3 id="REDIS-ENCODING-ZIPLIST-2"><a href="#REDIS-ENCODING-ZIPLIST-2" class="headerlink" title="REDIS_ENCODING_ZIPLIST"></a>REDIS_ENCODING_ZIPLIST</h3><p>当使用压缩列表作为有序集合的底层实现时候，压缩列表的entry有2个值，一个是值，一个是得分，同时按照得分由小到大进行排列</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649404859400.png" alt="1649404859400"></p>
<h3 id="REDIS-ENCODING-SKIPLIST"><a href="#REDIS-ENCODING-SKIPLIST" class="headerlink" title="REDIS_ENCODING_SKIPLIST"></a>REDIS_ENCODING_SKIPLIST</h3><p>当使用跳跃表进行底层实现时候，一个有序集合同时包括：</p>
<ul>
<li>一个跳跃表</li>
<li>一个字典</li>
</ul>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/1649404927877.png" alt="1649404927877"></p>
<blockquote>
<p>为什么有序集合需要同时使用跳跃表和字典来实现?</p>
<p>在理论上，有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现，但无论单独使用字典还是跳跃表，在性能上对比起同时使用字典和跳跃表都会有所降低。举个例子，如果我们只使用字典来实现有序集合，那么虽然以O(1)复杂度查找成员的分值这一特性会被保留，但是，因为字典以无序的方式来保存集合元素，所以每次在执行范围型操作——比如ZRANK、ZRANGE等命令时，程序都需要对字典保存的所有元素进行排序，完成这种排序需要至少O(NlogN)时间复杂度，以及额外的O(N)内存空间（因为要创建一个数组来保存排序后的元素)。</p>
<p>另一方面，如果我们只使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O(1)上升为O(logN)。因为以上原因，为了让有序集合的查找和范围型操作都尽可能快地执行，Redis 选择了同时使用字典和跳跃表两种数据结构来实现有序集合。</p>
</blockquote>
<h3 id="编码转换-3"><a href="#编码转换-3" class="headerlink" title="编码转换"></a>编码转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ZSET_MAX_ZIPLIST_ENTRIES 128 <span class="comment">/*有序集合中元素个数小于该值，zset底层使用ziplist*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ZSET_MAX_ZIPLIST_VALUE 64 <span class="comment">/*有序集合中元素长度小于该值，zset底层使用ziplist*/</span></span></span><br></pre></td></tr></table></figure>

<p>上述两个宏定义分别与redis的配置文件中<code>zset-max-ziplist-entries</code>和<code>zset-max-ziplist-value</code>对应</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一次把redis的数据结构和对应的对象实现方式大致说了一遍，最重要的还是什么时候使用什么数据结构，并且各种数据结构一些命令的时间复杂度等，这些其实还没有进行阐述，后面会单独开一章进行讲解，因为在实际项目中，我们要针对不同场景对数据结构进行选取</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo源码分析之回调模块</title>
    <url>/posts/3047269001.html</url>
    <content><![CDATA[<p>这次我们主要来说说<code>muduo</code>库中大量使用的回调机制。<code>muduo</code>主要使用的是利用<code>Callback</code>的方式来实现回调，首先我们在自己的<code>EchoServer</code>构造函数中有这样几行代码</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">EchoServer</span>(EventLoop *loop,</span><br><span class="line">        <span class="type">const</span> InetAddress &amp;addr, </span><br><span class="line">        <span class="type">const</span> std::string &amp;name)</span><br><span class="line">    : <span class="built_in">server_</span>(loop, addr, name)</span><br><span class="line">    , <span class="built_in">loop_</span>(loop)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注册回调函数</span></span><br><span class="line">    server_.<span class="built_in">setConnectionCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;EchoServer::onConnection, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    server_.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;EchoServer::onMessage, <span class="keyword">this</span>,</span><br><span class="line">            std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置合适的loop线程数量 loopthread</span></span><br><span class="line">    server_.<span class="built_in">setThreadNum</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了<code>setConnectionCallback</code>和<code>setMessageCallback</code>，我们去看下<code>TcpServer</code>对<code>setConnectionCallback</code>怎么实现的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setConnectionCallback</span><span class="params">(<span class="type">const</span> ConnectionCallback &amp;cb)</span> </span>&#123; connectionCallback_ = cb; &#125;</span><br></pre></td></tr></table></figure>
<p>这样当有新的连接建立时候，就会执行我们设置的<code>EchoServer::onConnection</code>，这样我们就给<code>TcpServer</code>设置了一个回调函数，同时当<code>TcpServer</code>中的<code>Acceptor</code>接受到一个新的连接，<code>TcpServer</code>就会去用这个<code>connfd</code>和对应的<code>peerAddr</code>建立一个新的<code>TcpConnection</code>，同时<code>TcpServer</code>会给这个<code>TcpConnection</code>设置一个回调，而这个回调就是我们给<code>TcpServer</code>设置的回调</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 根据连接成功的sockfd,创建TcpConnection</span></span><br><span class="line">   <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(</span></span></span><br><span class="line"><span class="params"><span class="function">                           ioLoop,</span></span></span><br><span class="line"><span class="params"><span class="function">                           connName,</span></span></span><br><span class="line"><span class="params"><span class="function">                           sockfd,   <span class="comment">// Socket Channel</span></span></span></span><br><span class="line"><span class="params"><span class="function">                           localAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                           peerAddr))</span></span>;</span><br><span class="line">   connections_[connName] = conn;</span><br><span class="line"><span class="comment">// 下面的回调时用户设置给TcpServer，TcpServer又设置给TcpConnection，TcpConnetion又设置给Channel，Channel又设置给Poller，Poller通知channel调用这个回调</span></span><br><span class="line">   conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">   conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">   conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br></pre></td></tr></table></figure>

<p>当已经建立的连接有新消息来的时候，<code>conn-&gt;setMessageCallback(messageCallback_);</code>这一行代码表示我们给这个<code>conn</code>设置了一个有消息来的时候回调，我们去看下<code>TcpConnection</code>中对<code>setMessageCallback</code>是怎么处理的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setConnectionCallback</span><span class="params">(<span class="type">const</span> ConnectionCallback&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123; connectionCallback_ = cb; &#125;</span><br></pre></td></tr></table></figure>
<p>所以有消息来的时候，就会执行我们所设置的回调函数<code>onMessage</code>。到这里我么就基本知道新连接的建立和旧连接的消息到来应该做什么，下一章我们说一下消息之间发送的<code>Buffer</code>类。</p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo源码分析之TcpServer模块</title>
    <url>/posts/335272509.html</url>
    <content><![CDATA[<p>这次我们开始<code>muduo</code>源代码的实际编写，首先我们知道<code>muduo</code>是<code>LT</code>模式，<code>Reactor</code>模式，下图为<code>Reactor</code>模式的流程图[来源1]</p>
<span id="more"></span>

<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20220220154310731.png" alt="image-20220220154310731"></p>
<p>然后我们来看下<code>muduo</code>的整体架构[来源1]</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/image-20210422204939773.png" alt="muduo"></p>
<p>首先<code>muduo</code>有一个主反应堆<code>mainReactor</code>以及几个子反应堆<code>subReactor</code>，其中子反应堆的个数由用户使用<code>setThreadNum</code>函数设置，<code>mainReactor</code>中主要有一个<code>Acceptor</code>，当用户建立新的连接的时候，<code>Acceptor</code>会将<code>connfd</code>和对应的事件打包为一个<code>channel</code>然后采用轮询的算法，指定将该<code>channel</code>给所选择的<code>subReactor</code>，以后该<code>subReactor</code>就负责该<code>channel</code>的所有工作。</p>
<h1 id="TcpServer类"><a href="#TcpServer类" class="headerlink" title="TcpServer类"></a>TcpServer类</h1><p>我们按照从上到下的思路进行讲解，以下内容我们按照一个简单的<code>EchoServer</code>的实现思路来讲解，我们知道当我们自己实现一个<code>Server</code>的时候，会在构造函数中实例化一个<code>TcpServer</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">EchoServer</span>(EventLoop *loop,</span><br><span class="line">           <span class="type">const</span> InetAddress &amp;addr, </span><br><span class="line">           <span class="type">const</span> std::string &amp;name)</span><br><span class="line">    : <span class="built_in">server_</span>(loop, addr, name)</span><br><span class="line">        , <span class="built_in">loop_</span>(loop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注册回调函数</span></span><br><span class="line">        server_.<span class="built_in">setConnectionCallback</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onConnection, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        server_.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;EchoServer::onMessage, <span class="keyword">this</span>,</span><br><span class="line">                      std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置合适的loop线程数量 loopthread 不包括baseloop</span></span><br><span class="line">        server_.<span class="built_in">setThreadNum</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>于是我们去看下<code>TcpServer</code>的构造函数是在干什么</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TcpServer::<span class="built_in">TcpServer</span>(EventLoop *loop,</span><br><span class="line">                <span class="type">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                <span class="type">const</span> std::string &amp;nameArg,</span><br><span class="line">                Option option)</span><br><span class="line">                : <span class="built_in">loop_</span>(<span class="built_in">CheckLoopNotNull</span>(loop))</span><br><span class="line">                , <span class="built_in">ipPort_</span>(listenAddr.<span class="built_in">toIpPort</span>())</span><br><span class="line">                , <span class="built_in">name_</span>(nameArg)</span><br><span class="line">                , <span class="built_in">acceptor_</span>(<span class="keyword">new</span> <span class="built_in">Acceptor</span>(loop, listenAddr, option == kReusePort))</span><br><span class="line">                , <span class="built_in">threadPool_</span>(<span class="keyword">new</span> <span class="built_in">EventLoopThreadPool</span>(loop, name_))</span><br><span class="line">                , <span class="built_in">connectionCallback_</span>()</span><br><span class="line">                , <span class="built_in">messageCallback_</span>()</span><br><span class="line">                , <span class="built_in">nextConnId_</span>(<span class="number">1</span>)</span><br><span class="line">                , <span class="built_in">started_</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当有新用户连接时候，会执行该回调函数</span></span><br><span class="line">    acceptor_-&gt;<span class="built_in">setNewConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::newConnection, <span class="keyword">this</span>, </span><br><span class="line">        std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只需要关注<code>acceptor_(new Acceptor(loop, listenAddr, option == kReusePort))</code>和<code>threadPool_(new EventLoopThreadPool(loop, name_))</code><br>首先很明确的一点，构造了一个<code>Acceptor</code>，我们首先要知道<code>Acceptor</code>主要就是连接新用户并打包为一个<code>Channel</code>，所以我们就应该知道<code>Acceptor</code>按道理应该实现<code>socket</code>，<code>bind</code>，<code>listen</code>，<code>accept</code>这四个函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Acceptor::<span class="built_in">Acceptor</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr, <span class="type">bool</span> reuseport)</span><br><span class="line">    : <span class="built_in">loop_</span>(loop), <span class="built_in">acceptSocket_</span>(<span class="built_in">createNonblocking</span>()) <span class="comment">// socket</span></span><br><span class="line">      ,</span><br><span class="line">      <span class="built_in">acceptChannel_</span>(loop, acceptSocket_.<span class="built_in">fd</span>()), <span class="built_in">listenning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    acceptSocket_.<span class="built_in">setReuseAddr</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">setReusePort</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">bindAddress</span>(listenAddr); <span class="comment">// 绑定套接字</span></span><br><span class="line">    <span class="comment">// 有新用户的连接，执行一个回调（打包为channel）</span></span><br><span class="line">    acceptChannel_.<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::handleRead, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>Acceptor</code>中有个<code>acceptSocket_</code>，其实就是我们平时所用的<code>listenfd</code>，构造函数中实现了<code>socket</code>，<code>bind</code>，而其余的两个函数的使用在其余代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启服务器监听</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 防止一个TcpServer被start多次</span></span><br><span class="line">    <span class="keyword">if</span> (started_++ == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        threadPool_-&gt;<span class="built_in">start</span>(threadInitCallback_); <span class="comment">// 启动底层的loop线程池,这里会按照设定了threadnum设置pool的数量</span></span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::listen, acceptor_.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道，当我们设置了<code>threadnum</code>之后，就会有一个<code>mainloop</code>，那么这个<code>loop_</code>就是那个<code>mainloop</code>，其中可以看见这个<code>loop_</code>就只做一个事情<code>Acceptor::listen</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listenning_ = <span class="literal">true</span>;</span><br><span class="line">    acceptSocket_.<span class="built_in">listen</span>();         <span class="comment">// listen</span></span><br><span class="line">    acceptChannel_.<span class="built_in">enableReading</span>(); <span class="comment">// acceptChannel_ =&gt; Poller</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里就实现了<code>listen</code>函数，还有最后一个函数<code>accept</code>，我们慢慢向下分析，从代码可以知道<code>acceptChannel_.enableReading()</code>之后就会使得这个<code>listenfd</code>所在的<code>channel</code>对读事件感兴趣，那什么时候会有读事件呢，就是当用户建立新连接的时候，那么我们应该想一下，那当感兴趣的事件发生之后，<code>listenfd</code>应该干什么呢，应该执行一个回调函数呀。注意<code>Acceptor</code>构造函数中有这样一行代码<code>acceptChannel_.setReadCallback(std::bind(&amp;Acceptor::handleRead, this));</code>这就是那个回调，我们去看下<code>handleRead</code>在干嘛。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// listenfd有事件发生了，就是有新用户连接了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InetAddress peerAddr;</span><br><span class="line">    <span class="type">int</span> connfd = acceptSocket_.<span class="built_in">accept</span>(&amp;peerAddr);</span><br><span class="line">    <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若用户实现定义了，则执行，否则说明用户对新到来的连接没有需要执行的，所以直接关闭</span></span><br><span class="line">        <span class="keyword">if</span> (newConnectionCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">newConnectionCallback_</span>(connfd, peerAddr); <span class="comment">// 轮询找到subLoop，唤醒，分发当前的新客户端的Channel</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ::<span class="built_in">close</span>(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是不是就实现了<code>accept</code>函数，至此当用户建立一个新的连接时候，<code>Acceptor</code>就会得到一个<code>connfd</code>和其对应的<code>peerAddr</code>返回给<code>mainloop</code>，这时候我们在注意到<code>TcpServer</code>构造函数中有这样一行代码<code>acceptor_-&gt;setNewConnectionCallback(std::bind(&amp;TcpServer::newConnection, this,std::placeholders::_1, std::placeholders::_2));</code>我们给<code>acceptor_</code>设置了一个<code>newConnectionCallback_</code>，于是由上面的代码就可以知道，<code>if (newConnectionCallback_)</code>为真，就会执行这个回调函数，于是就会执行<code>TcpServer::newConnection</code>，我们去看下这个函数是在干嘛。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress &amp;peerAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 轮询算法选择一个subloop来管理对应的这个新连接</span></span><br><span class="line">    EventLoop *ioLoop = threadPool_-&gt;<span class="built_in">getNextLoop</span>(); </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;-%s#%d&quot;</span>, ipPort_.<span class="built_in">c_str</span>(), nextConnId_);</span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    std::string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpServer::newConnection [%s] - new connection [%s] from %s \n&quot;</span>,</span><br><span class="line">        name_.<span class="built_in">c_str</span>(), connName.<span class="built_in">c_str</span>(), peerAddr.<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过sockfd获取其绑定的本地ip和端口</span></span><br><span class="line">    sockaddr_in local;</span><br><span class="line">    ::<span class="built_in">bzero</span>(&amp;local, <span class="keyword">sizeof</span> local);</span><br><span class="line">    <span class="type">socklen_t</span> addrlen = <span class="keyword">sizeof</span> local;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">getsockname</span>(sockfd, (sockaddr*)&amp;local, &amp;addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;sockets::getLocalAddr&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(local)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据连接成功的sockfd,创建TcpConnection</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(</span></span></span><br><span class="line"><span class="params"><span class="function">                            ioLoop,</span></span></span><br><span class="line"><span class="params"><span class="function">                            connName,</span></span></span><br><span class="line"><span class="params"><span class="function">                            sockfd,   <span class="comment">// Socket Channel</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            localAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                            peerAddr))</span></span>;</span><br><span class="line">    connections_[connName] = conn;</span><br><span class="line">	<span class="comment">// 下面的回调时用户设置给TcpServer，TcpServer又设置给TcpConnection，TcpConnetion又设置给Channel，Channel又设置给Poller，Poller通知channel调用这个回调</span></span><br><span class="line">    conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置了如何关闭连接的回调</span></span><br><span class="line">    conn-&gt;<span class="built_in">setCloseCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接调用connectEstablished</span></span><br><span class="line">    ioLoop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就比较长了，我先说下大概他干了啥事情：首先通过轮询找到下一个<code>subloop</code>，然后将刚刚返回的<code>connfd</code>和对应的<code>peerAddr</code>以及<code>localAddr</code>构造为一个<code>TcpConnection</code>给<code>subloop</code>，然后给这个<code>conn</code>设置了一系列的回调函数，比如读回调，写回调，断开回调等等。下一章我们来说下上面的代码最后几行在干嘛。</p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo源码分析之muduo简单运用</title>
    <url>/posts/713527548.html</url>
    <content><![CDATA[<p>今天不先实现<code>muduo</code>项目，我们先来看下<code>muduo</code>库的基本使用，只有了解了如何用，才能在写代码的时候知道自己写的找个函数是干嘛的，实际上是怎么使用的这个函数。首先说简单点，就是定义一个<code>Server</code>，设置两个回调函数</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回调连接相关的事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line"><span class="comment">// 回调读写事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, Buffer *buffer, Timestamp time)</span></span>;</span><br></pre></td></tr></table></figure>
<p>意思就是当有客户连接或者断开连接的时候，需要<code>Server</code>做什么，当连接上有读写事件发生时候，需要<code>Server</code>做什么。<br>比如一个<code>EchoServer</code>，当建立连接的时候，会自动调用<code>onConnection</code>函数，当比如我们发送一个消息时候，会自动调用<code>onMessage</code>函数。还有2个重要函数<code>loop</code>，<code>start</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">server.<span class="built_in">start</span>();</span><br><span class="line">loop.<span class="built_in">loop</span>();</span><br></pre></td></tr></table></figure>
<p>这里简答讲下这2个的区别，其实如果和<code>Epoll</code>做对比的话，<code>start</code>就相当于<code>epoll_create</code>，<code>loop</code>就相当于<code>epoll_wait</code>，后面再根据代码具体说明2个的区别。</br><br>以上就是基本的<code>muduo</code>使用，下一章就开始具体的<code>muduo</code>代码实现。</p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo源码分析之Buffer</title>
    <url>/posts/620043534.html</url>
    <content><![CDATA[<p>这一次我们来分析下<code>muduo</code>中<code>Buffer</code>的作用，我们知道，当我们客户端向服务器发送数据时候，服务器就会读取我们发送的数据，然后进行一系列处理，然后再发送到其他地方，在这里我们想象一下最简单的<code>EchoServer</code>服务器，客户端建立一个连接，以后服务器和客户端之间的通信都是通过这个<code>connfd</code>发送和接受数据，于是每一个<code>connfd</code>都应该有一个自己<code>buffer</code>，当我们发送数据太快，服务器发送的太慢，则服务器会将待发送的数据这个<code>buffer</code>中，所以这就是这个类的作用。我们先看下<code>buffer</code>的结构是什么：</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/d2466fdf-c322-417a-9a80-2900d415d81d.png" alt="buffer1"></p>
<p>我们这里主要针对<code>connfd</code>这个对应的<code>channel</code>进行分析，首先上图是<code>buffer</code>的初始状态，前面<code>8</code>个字节中表示该<code>buffer</code>的大小，初始大小为<code>1024</code>。当客户端发送数据给服务器，同时若服务器接受缓慢，则会向<code>buffer</code>中开始写数据，则<code>writerIndex_</code>会向右移动，假如此时移动到如下形式：</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/10505139-a325-4e85-bea0-b845fad0fd51.png" alt="buffer2"></p>
<p>则此时缓冲区可以读的数据为<code>writerIndex_ - readerIndex_</code>，可以写的数据为<code>buffer_.size() - writerIndex_</code>。这时候当服务器有多余资源进行读操作，就可以去缓冲区读数据了，假如这时候的状态为如下：</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/c2fc3414-189b-41bf-b649-1c0ba90763e1.png" alt="buffer3"></p>
<p>这就是常见的几个状态，下面我们去看几个重点的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 把onMessage函数上报的buffer内容转为string</span></span><br><span class="line">  <span class="function">std::string <span class="title">retrieveAllAsString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">retrieveAsString</span>(<span class="built_in">readableBytes</span>()); <span class="comment">// 应用可读取数据的长度</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 可读的数据 就是存放的是即发送的数据</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">readableBytes</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> writerIndex_ - readerIndex_;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">std::string <span class="title">retrieveAsString</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"><span class="comment">// 从可读数据开始位置，长度为len的char构造为一个string</span></span><br><span class="line">      <span class="function">std::string <span class="title">result</span><span class="params">(peek(), len)</span></span>;</span><br><span class="line">      <span class="built_in">retrieve</span>(len); <span class="comment">// 上面一句把缓冲区中可读的数据，已经读取出来，这里肯定要对缓冲区进行复位操作</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将缓冲区len的长度进行复位</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">retrieve</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"><span class="comment">// 表示还没有读完数据</span></span><br><span class="line">      <span class="keyword">if</span> (len &lt; <span class="built_in">readableBytes</span>())</span><br><span class="line">      &#123;</span><br><span class="line">          readerIndex_ += len; <span class="comment">// 应用只读取了刻度缓冲区数据的一部分，就是len，还剩下readerIndex_ += len -&gt; writerIndex_</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>   <span class="comment">// len == readableBytes()</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">retrieveAll</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>以上是基本的操作，下面的2个函数很重要，一个是向<code>connfd</code>写数据，一个是读数据，对于一个<code>TcpConnection</code>而言，当有数据来的时候，回去调用<code>handleRead</code>回调函数。我们知道<code>muduo</code>设置的每次读取的大小为<code>65536</code>字节，当缓冲区可写的数据大小大于<code>65536</code>，就会直接将读到的数据写入到缓冲区中，但当缓冲区的可写数据大小小于<code>65536</code>的时候，就会将剩余数据先写到一个额外的空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::readFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> extrabuf[<span class="number">65536</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 栈上的内存空间  64K</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> vec[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 这是buffer可写的数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> writable = <span class="built_in">writableBytes</span>(); </span><br><span class="line">    vec[<span class="number">0</span>].iov_base = <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">    vec[<span class="number">0</span>].iov_len = writable;</span><br><span class="line"></span><br><span class="line">    vec[<span class="number">1</span>].iov_base = extrabuf;</span><br><span class="line">    vec[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span> extrabuf;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iovcnt = (writable &lt; <span class="keyword">sizeof</span> extrabuf) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 去百度下readv</span></span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> n = ::<span class="built_in">readv</span>(fd, vec, iovcnt);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= writable) <span class="comment">// Buffer的可写缓冲区已经够存储读出来的数据了</span></span><br><span class="line">    &#123;</span><br><span class="line">        writerIndex_ += n;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// extrabuf 也写了数据</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        writerIndex_ = buffer_.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">append</span>(extrabuf, n - writable);  <span class="comment">// writerIndex_开始写 n - writable大小的数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里巧妙的使用了一个<code>readv</code>函数，可以通过按照大小自动写到不同的地方。其中当<code>extrabuf</code>也写了数据，就会调用<code>append</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要写len长度的数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ensureWriteableBytes</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">makeSpace</span>(len); <span class="comment">// 扩容函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向缓冲区添加数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ensureWriteableBytes</span>(len);</span><br><span class="line">    std::<span class="built_in">copy</span>(data, data+len, <span class="built_in">beginWrite</span>());</span><br><span class="line">    writerIndex_ += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到有一个<code>makeSpace</code>函数，其中有一个注意点，比如当如下这种状态的时候：</p>
<p><img src="https://smypicture.oss-cn-beijing.aliyuncs.com/img/c2fc3414-189b-41bf-b649-1c0ba90763e1.png" alt="buffer4"></p>
<p>此时<code>readerIndex_</code>前面有一部分其实已经被读完了，是空的数据，所以<code>makeSpace</code>函数考虑了这一点，采用内存重组的方式，将<code>readerIndex_</code>向前移动到<code>kCheapPrepend</code>处，然后就可以让空余的内存挨在一起</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeSpace</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() + <span class="built_in">prependableBytes</span>() &lt; len + kCheapPrepend)</span><br><span class="line">    &#123;</span><br><span class="line">        buffer_.<span class="built_in">resize</span>(writerIndex_ + len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> readalbe = <span class="built_in">readableBytes</span>();</span><br><span class="line">        std::<span class="built_in">copy</span>(<span class="built_in">begin</span>() + readerIndex_, </span><br><span class="line">                <span class="built_in">begin</span>() + writerIndex_,</span><br><span class="line">                <span class="built_in">begin</span>() + kCheapPrepend);</span><br><span class="line">        readerIndex_ = kCheapPrepend;</span><br><span class="line">        writerIndex_ = readerIndex_ + readalbe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当向<code>connfd</code>发送数据的时候就比较简单了，直接将可读的数据发送给出去就行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过fd发送数据</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::writeFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n = ::<span class="built_in">write</span>(fd, <span class="built_in">peek</span>(), <span class="built_in">readableBytes</span>());</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo项目介绍</title>
    <url>/posts/3331102393.html</url>
    <content><![CDATA[<p>在上一个<a href="https://juejin.cn/post/6950230361594920996"><strong>集群聊天服务器</strong></a>项目中，我使用了<code>muduo</code>作为网络库，然后主要实现了业务逻辑等，所以为了深入网络库的代码和实现，我跟着一位老师的代码去实现了<code>muduo</code>库的基本原理和作用，当然只是实现了主体的代码，有些细节便没有深究，以下是自己的目标:</p>
<ol>
<li>从开源C++ muduo网络库，学习优秀的代码设计</li>
<li>掌握基于事件驱动和事件回调的epoll+线程池面向对象编程</li>
<li>实现<code>TcpServer</code>、<code>TcpConnection</code>、<code>Poller</code>、<code>Chanel</code>等重要部分</li>
<li>重写muduo核心组件，去依赖boost，用C++11重构</li>
<li>测试代码是否成功</li>
</ol>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
